/* tslint:disable */
/* eslint-disable */
/**
 * DigitalX Game API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionImpactModel
 */
export interface ActionImpactModel {
    /**
     * 
     * @type {ImpactType}
     * @memberof ActionImpactModel
     */
    'type': ImpactType;
    /**
     * 
     * @type {ImpactViolationType}
     * @memberof ActionImpactModel
     */
    'violation': ImpactViolationType;
    /**
     * 
     * @type {number}
     * @memberof ActionImpactModel
     */
    'size': number;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof ActionImpactModel
     */
    'dice_roll_result': DiceRollResult;
}


/**
 * 
 * @export
 * @interface ActionModel
 */
export interface ActionModel {
    /**
     * 
     * @type {PlayerActionType}
     * @memberof ActionModel
     */
    'action_type': PlayerActionType;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'initiator_id': string;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'skill_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_dimension_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_location_id': string | null;
}


/**
 * * `USE_SKILL` - USE_SKILL * `USE_ITEM` - USE_ITEM * `DIMENSION_SHIFT` - DIMENSION_SHIFT * `CHANGE_POSITION` - CHANGE_POSITION * `START_DIALOGUE` - START_DIALOGUE * `MAKE_DUEL_INVITATION` - MAKE_DUEL_INVITATION * `ACCEPT_DUEL_INVITATION` - ACCEPT_DUEL_INVITATION * `REJECT_DUEL_INVITATION` - REJECT_DUEL_INVITATION * `START_FIGHT` - START_FIGHT
 * @export
 * @enum {string}
 */

export const ActionTypeEnum = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT'
} as const;

export type ActionTypeEnum = typeof ActionTypeEnum[keyof typeof ActionTypeEnum];


/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'id': string;
    /**
     * 
     * @type {Array<SubLocation>}
     * @memberof Area
     */
    'sub_locations': Array<SubLocation>;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Area
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'city': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Area
     */
    'border_with': Array<string>;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {NameEnum}
     * @memberof Attribute
     */
    'name': NameEnum;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface AttributeHolder
 */
export interface AttributeHolder {
    /**
     * 
     * @type {AttributeType}
     * @memberof AttributeHolder
     */
    'name': AttributeType;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'max': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AttributeType = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributeType = typeof AttributeType[keyof typeof AttributeType];


/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof City
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof City
     */
    'border_with': Array<string>;
}
/**
 * \"client\": \"435f309f-32f4-485d-9b88-6c2daca71555\", \"transport\": \"websocket\", \"protocol\": \"json\", \"encoding\": \"json\", \"name\": \"js\"
 * @export
 * @interface ConnectRequest
 */
export interface ConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'transport': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CurrentFight
 */
export interface CurrentFight {
    /**
     * 
     * @type {FightMini}
     * @memberof CurrentFight
     */
    'fight': FightMini;
    /**
     * 
     * @type {Array<FightParticipant>}
     * @memberof CurrentFight
     */
    'allies': Array<FightParticipant>;
    /**
     * 
     * @type {Array<FightParticipant>}
     * @memberof CurrentFight
     */
    'enemies': Array<FightParticipant>;
}
/**
 * 
 * @export
 * @interface CurrentTurn
 */
export interface CurrentTurn {
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'started_at': string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTurn
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field2': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface DiceRollResult
 */
export interface DiceRollResult {
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'dice_side': number;
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'multiplier': number | null;
    /**
     * 
     * @type {RollOutcome}
     * @memberof DiceRollResult
     */
    'outcome': RollOutcome;
}


/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'energy': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Dimension
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface DuelInvitation
 */
export interface DuelInvitation {
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof DuelInvitation
     */
    'is_accepted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DuelInvitation
     */
    'is_rejected': boolean;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'fight': string | null;
}
/**
 * 
 * @export
 * @interface DuelInvitationRequest
 */
export interface DuelInvitationRequest {
    /**
     * 
     * @type {string}
     * @memberof DuelInvitationRequest
     */
    'target': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EventCategory = {
    Player: 'player',
    Location: 'location',
    Fight: 'fight',
    Game: 'game'
} as const;

export type EventCategory = typeof EventCategory[keyof typeof EventCategory];


/**
 * 
 * @export
 * @interface Fight
 */
export interface Fight {
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Fight
     */
    'is_open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Fight
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'current_turn'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fight
     */
    'side_a_participants'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fight
     */
    'side_b_participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FightMini
 */
export interface FightMini {
    /**
     * 
     * @type {string}
     * @memberof FightMini
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof FightMini
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FightMini
     */
    'current_turn'?: string | null;
}
/**
 * 
 * @export
 * @interface FightParticipant
 */
export interface FightParticipant {
    /**
     * 
     * @type {string}
     * @memberof FightParticipant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FightParticipant
     */
    'name': string;
    /**
     * 
     * @type {Array<PlayerAttribute>}
     * @memberof FightParticipant
     */
    'attributes': Array<PlayerAttribute>;
    /**
     * 
     * @type {number}
     * @memberof FightParticipant
     */
    'dimension': number;
    /**
     * 
     * @type {number}
     * @memberof FightParticipant
     */
    'rank_grade': number;
}
/**
 * 
 * @export
 * @interface FightRequest
 */
export interface FightRequest {
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FightRequest
     */
    'is_open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FightRequest
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'current_turn'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightRequest
     */
    'side_a_participants'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightRequest
     */
    'side_b_participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FightTurnAction
 */
export interface FightTurnAction {
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'updated_at': string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof FightTurnAction
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'order': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnAction
     */
    'is_finished': boolean;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'initiator': string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'target_dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'target_location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'turn': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightTurnAction
     */
    'targets': Array<string>;
}


/**
 * 
 * @export
 * @interface FightTurnActionRequest
 */
export interface FightTurnActionRequest {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof FightTurnActionRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionRequest
     */
    'target_dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionRequest
     */
    'target_location'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightTurnActionRequest
     */
    'targets': Array<string>;
}


/**
 * 
 * @export
 * @interface FightTurnActionResultGameEvent
 */
export interface FightTurnActionResultGameEvent {
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionResultGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightTurnActionResultGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {TurnActionResultGameEventData}
     * @memberof FightTurnActionResultGameEvent
     */
    'data': TurnActionResultGameEventData;
}


/**
 * 
 * @export
 * @interface FullPlayerInfo
 */
export interface FullPlayerInfo {
    /**
     * 
     * @type {string}
     * @memberof FullPlayerInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullPlayerInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FullPlayerInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<AttributeHolder>}
     * @memberof FullPlayerInfo
     */
    'attributes': Array<AttributeHolder>;
    /**
     * 
     * @type {number}
     * @memberof FullPlayerInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof FullPlayerInfo
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof FullPlayerInfo
     */
    'fight': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FullPlayerInfo
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface GameEventRequest
 */
export interface GameEventRequest {
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GameEventRequest
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof GameEventRequest
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {Data}
     * @memberof GameEventRequest
     */
    'data': Data;
}


/**
 * * `Male` - Male * `Female` - Female * `Other` - Other
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Other: 'Other'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactType = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactType = typeof ImpactType[keyof typeof ImpactType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactViolationType = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationType = typeof ImpactViolationType[keyof typeof ImpactViolationType];


/**
 * 
 * @export
 * @interface LearnedSchool
 */
export interface LearnedSchool {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'player': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSchoolRequest
 */
export interface LearnedSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchoolRequest
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSkill
 */
export interface LearnedSkill {
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'player': string;
    /**
     * 
     * @type {OpenaiSkill}
     * @memberof LearnedSkill
     */
    'skill': OpenaiSkill;
}
/**
 * 
 * @export
 * @interface LearnedSkillRequest
 */
export interface LearnedSkillRequest {
    /**
     * 
     * @type {OpenaiSkillRequest}
     * @memberof LearnedSkillRequest
     */
    'skill': OpenaiSkillRequest;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Location
     */
    'border_with': Array<string>;
}
/**
 * * `Health` - Health * `Energy` - Energy * `Action Points` - Action Points
 * @export
 * @enum {string}
 */

export const NameEnum = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type NameEnum = typeof NameEnum[keyof typeof NameEnum];


/**
 * 
 * @export
 * @interface OpenAIClientManagement
 */
export interface OpenAIClientManagement {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'updated_at': string;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OpenAIClientManagement
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_staff': boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'player'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'user_permissions'?: Array<number>;
}


/**
 * 
 * @export
 * @interface OpenAIClientManagementRequest
 */
export interface OpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'player'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface OpenaiCharacter
 */
export interface OpenaiCharacter {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacter
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacter
     */
    'gender': GenderEnum;
}


/**
 * 
 * @export
 * @interface OpenaiCharacterRequest
 */
export interface OpenaiCharacterRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterRequest
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacterRequest
     */
    'gender': GenderEnum;
}


/**
 * 
 * @export
 * @interface OpenaiPath
 */
export interface OpenaiPath {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface OpenaiSchool
 */
export interface OpenaiSchool {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OpenaiSchool
     */
    'path': Array<string>;
}
/**
 * 
 * @export
 * @interface OpenaiSkill
 */
export interface OpenaiSkill {
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeEnum}
     * @memberof OpenaiSkill
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkill
     */
    'impact'?: any;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkill
     */
    'cost'?: any;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkill
     */
    'effect'?: any;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'school': string | null;
}


/**
 * 
 * @export
 * @interface OpenaiSkillRequest
 */
export interface OpenaiSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeEnum}
     * @memberof OpenaiSkillRequest
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'impact'?: any;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'cost'?: any;
    /**
     * 
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'effect'?: any;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'school': string | null;
}


/**
 * 
 * @export
 * @interface PatchedOpenAIClientManagementRequest
 */
export interface PatchedOpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'player'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedOpenaiCharacterRequest
 */
export interface PatchedOpenaiCharacterRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiCharacterRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOpenaiCharacterRequest
     */
    'age'?: number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof PatchedOpenaiCharacterRequest
     */
    'gender'?: GenderEnum;
}


/**
 * 
 * @export
 * @interface PlayerAction
 */
export interface PlayerAction {
    /**
     * 
     * @type {string}
     * @memberof PlayerAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerAction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerAction
     */
    'updated_at': string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof PlayerAction
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PlayerAction
     */
    'initiator': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerAction
     */
    'target_dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerAction
     */
    'target_location'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerAction
     */
    'targets': Array<string>;
}


/**
 * 
 * @export
 * @interface PlayerActionRequest
 */
export interface PlayerActionRequest {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof PlayerActionRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PlayerActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerActionRequest
     */
    'target_dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerActionRequest
     */
    'target_location'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerActionRequest
     */
    'targets': Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PlayerActionType = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT'
} as const;

export type PlayerActionType = typeof PlayerActionType[keyof typeof PlayerActionType];


/**
 * 
 * @export
 * @interface PlayerAttribute
 */
export interface PlayerAttribute {
    /**
     * 
     * @type {NameEnum}
     * @memberof PlayerAttribute
     */
    'name': NameEnum;
    /**
     * 
     * @type {number}
     * @memberof PlayerAttribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerAttribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface PlayerExample1GameEvent
 */
export interface PlayerExample1GameEvent {
    /**
     * 
     * @type {string}
     * @memberof PlayerExample1GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerExample1GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerExample1GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof PlayerExample1GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {PlayerExample1GameEventData}
     * @memberof PlayerExample1GameEvent
     */
    'data': PlayerExample1GameEventData;
}


/**
 * 
 * @export
 * @interface PlayerExample1GameEventData
 */
export interface PlayerExample1GameEventData {
    /**
     * 
     * @type {string}
     * @memberof PlayerExample1GameEventData
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface PlayerExample2GameEvent
 */
export interface PlayerExample2GameEvent {
    /**
     * 
     * @type {string}
     * @memberof PlayerExample2GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerExample2GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerExample2GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof PlayerExample2GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {PlayerExample2GameEventData}
     * @memberof PlayerExample2GameEvent
     */
    'data': PlayerExample2GameEventData;
}


/**
 * 
 * @export
 * @interface PlayerExample2GameEventData
 */
export interface PlayerExample2GameEventData {
    /**
     * 
     * @type {string}
     * @memberof PlayerExample2GameEventData
     */
    'field2': string;
}
/**
 * 
 * @export
 * @interface PlayerInfo
 */
export interface PlayerInfo {
    /**
     * 
     * @type {string}
     * @memberof PlayerInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof PlayerInfo
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {number}
     * @memberof PlayerInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerInfo
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerInfo
     */
    'fight': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerInfo
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface PlayerNewTurnGameEvent
 */
export interface PlayerNewTurnGameEvent {
    /**
     * 
     * @type {string}
     * @memberof PlayerNewTurnGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerNewTurnGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerNewTurnGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof PlayerNewTurnGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {PlayerNewTurnGameEventData}
     * @memberof PlayerNewTurnGameEvent
     */
    'data': PlayerNewTurnGameEventData;
}


/**
 * 
 * @export
 * @interface PlayerNewTurnGameEventData
 */
export interface PlayerNewTurnGameEventData {
    /**
     * 
     * @type {CurrentTurn}
     * @memberof PlayerNewTurnGameEventData
     */
    'current_turn': CurrentTurn;
    /**
     * 
     * @type {FullPlayerInfo}
     * @memberof PlayerNewTurnGameEventData
     */
    'player_info': FullPlayerInfo;
}
/**
 * 
 * @export
 * @interface PlayerPath
 */
export interface PlayerPath {
    /**
     * 
     * @type {string}
     * @memberof PlayerPath
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface PlayerPathRequest
 */
export interface PlayerPathRequest {
    /**
     * 
     * @type {string}
     * @memberof PlayerPathRequest
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {Location}
     * @memberof Position
     */
    'location': Location;
    /**
     * 
     * @type {Area}
     * @memberof Position
     */
    'area': Area;
    /**
     * 
     * @type {City}
     * @memberof Position
     */
    'city': City;
    /**
     * 
     * @type {Dimension}
     * @memberof Position
     */
    'dimension': Dimension;
    /**
     * 
     * @type {Array<PlayerInfo>}
     * @memberof Position
     */
    'visitors': Array<PlayerInfo>;
}
/**
 * * `openai` - OpenAI * `google` - Google * `local` - Local
 * @export
 * @enum {string}
 */

export const ProviderEnum = {
    Openai: 'openai',
    Google: 'google',
    Local: 'local'
} as const;

export type ProviderEnum = typeof ProviderEnum[keyof typeof ProviderEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const RollOutcome = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type RollOutcome = typeof RollOutcome[keyof typeof RollOutcome];


/**
 * 
 * @export
 * @interface SubLocation
 */
export interface SubLocation {
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocation
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'location': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SubLocation
     */
    'border_with': Array<string>;
}
/**
 * 
 * @export
 * @interface SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeRequest
     */
    'channel': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPairRequest
 */
export interface TokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyRequest
 */
export interface TokenVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TurnActionResultGameEventData
 */
export interface TurnActionResultGameEventData {
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'turn_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'initiator_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'target_id': string;
    /**
     * 
     * @type {ActionModel}
     * @memberof TurnActionResultGameEventData
     */
    'action': ActionModel;
    /**
     * 
     * @type {ActionImpactModel}
     * @memberof TurnActionResultGameEventData
     */
    'impact': ActionImpactModel;
}
/**
 * * `attack` - Attack * `defense` - Defense * `heal` - Heal * `buff` - Buff * `debuff` - Debuff * `utility` - Utility
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    Attack: 'attack',
    Defense: 'defense',
    Heal: 'heal',
    Buff: 'buff',
    Debuff: 'debuff',
    Utility: 'utility'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];



/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayerActionRequest} playerActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate: async (playerActionRequest: PlayerActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerActionRequest' is not null or undefined
            assertParamExists('actionCreate', 'playerActionRequest', playerActionRequest)
            const localVarPath = `/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayerActionRequest} playerActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCreate(playerActionRequest: PlayerActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCreate(playerActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayerActionRequest} playerActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate(playerActionRequest: PlayerActionRequest, options?: any): AxiosPromise<PlayerAction> {
            return localVarFp.actionCreate(playerActionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * 
     * @param {PlayerActionRequest} playerActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCreate(playerActionRequest: PlayerActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCreate(playerActionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdaptersApi - axios parameter creator
 * @export
 */
export const AdaptersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate: async (connectRequest: ConnectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoConnectCreate', 'connectRequest', connectRequest)
            const localVarPath = `/adapters/centrifugo/connect/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate: async (gameEventRequest: GameEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameEventRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoPublishCreate', 'gameEventRequest', gameEventRequest)
            const localVarPath = `/adapters/centrifugo/publish/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoSubscribeCreate', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/adapters/centrifugo/subscribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdaptersApi - functional programming interface
 * @export
 */
export const AdaptersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdaptersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoConnectCreate(connectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoConnectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoPublishCreate(gameEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoPublishCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoSubscribeCreate(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoSubscribeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdaptersApi - factory interface
 * @export
 */
export const AdaptersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdaptersApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdaptersApi - object-oriented interface
 * @export
 * @class AdaptersApi
 * @extends {BaseAPI}
 */
export class AdaptersApi extends BaseAPI {
    /**
     * 
     * @param {ConnectRequest} connectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameEventRequest} gameEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate: async (tokenObtainPairRequest: TokenObtainPairRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPairRequest' is not null or undefined
            assertParamExists('authJwtTokenCreate', 'tokenObtainPairRequest', tokenObtainPairRequest)
            const localVarPath = `/auth/jwt/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('authJwtTokenRefreshCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/jwt/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate: async (tokenVerifyRequest: TokenVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyRequest' is not null or undefined
            assertParamExists('authJwtTokenVerifyCreate', 'tokenVerifyRequest', tokenVerifyRequest)
            const localVarPath = `/auth/jwt/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenCreate(tokenObtainPairRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenRefreshCreate(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenVerifyCreate(tokenVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPairRequest} tokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerifyRequest} tokenVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate: async (openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientCreate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientDestroy', 'id', id)
            const localVarPath = `/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate: async (id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientPartialUpdate', 'id', id)
            const localVarPath = `/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientRetrieve', 'id', id)
            const localVarPath = `/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate: async (id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientUpdate', 'id', id)
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientUpdate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCreate(openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenAIClientManagement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientUpdate(id, openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientCreate(openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList(options?: any): AxiosPromise<Array<OpenAIClientManagement>> {
            return localVarFp.clientList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve(id: string, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCreate(openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientList(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FightApi - axios parameter creator
 * @export
 */
export const FightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightActionCreate: async (fightTurnActionRequest: FightTurnActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fightTurnActionRequest' is not null or undefined
            assertParamExists('fightActionCreate', 'fightTurnActionRequest', fightTurnActionRequest)
            const localVarPath = `/fight/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightTurnActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fight/fight/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightHistoryRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fight/fight/history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToAttackerSideCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightJoinToAttackerSideCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightJoinToAttackerSideCreate', 'fightRequest', fightRequest)
            const localVarPath = `/fight/fight/{id}/join_to_attacker_side/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToDefenderSideCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightJoinToDefenderSideCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightJoinToDefenderSideCreate', 'fightRequest', fightRequest)
            const localVarPath = `/fight/fight/{id}/join_to_defender_side/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightLeaveCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightLeaveCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightLeaveCreate', 'fightRequest', fightRequest)
            const localVarPath = `/fight/fight/{id}/leave/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightRetrieve', 'id', id)
            const localVarPath = `/fight/fight/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationAcceptCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationAcceptCreate', 'id', id)
            const localVarPath = `/fight/invitation/{id}/accept/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationCreate: async (duelInvitationRequest: DuelInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duelInvitationRequest' is not null or undefined
            assertParamExists('fightInvitationCreate', 'duelInvitationRequest', duelInvitationRequest)
            const localVarPath = `/fight/invitation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duelInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fight/invitation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRejectCreate: async (id: string, duelInvitationRequest: DuelInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationRejectCreate', 'id', id)
            // verify required parameter 'duelInvitationRequest' is not null or undefined
            assertParamExists('fightInvitationRejectCreate', 'duelInvitationRequest', duelInvitationRequest)
            const localVarPath = `/fight/invitation/{id}/reject/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duelInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationRetrieve', 'id', id)
            const localVarPath = `/fight/invitation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FightApi - functional programming interface
 * @export
 */
export const FightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FightTurnAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightActionCreate(fightTurnActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightActionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentFight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightHistoryRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightHistoryRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightHistoryRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightJoinToAttackerSideCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightJoinToAttackerSideCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightJoinToDefenderSideCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightJoinToDefenderSideCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightLeaveCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightLeaveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationAcceptCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationAcceptCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationAcceptCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationCreate(duelInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DuelInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationRejectCreate(id, duelInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationRejectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FightApi - factory interface
 * @export
 */
export const FightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FightApiFp(configuration)
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: any): AxiosPromise<FightTurnAction> {
            return localVarFp.fightActionCreate(fightTurnActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightCurrentRetrieve(options?: any): AxiosPromise<CurrentFight> {
            return localVarFp.fightFightCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightHistoryRetrieve(options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightHistoryRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightJoinToAttackerSideCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightJoinToDefenderSideCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightLeaveCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve(id: string, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationAcceptCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.fightInvitationAcceptCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationCreate(duelInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationList(options?: any): AxiosPromise<Array<DuelInvitation>> {
            return localVarFp.fightInvitationList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationRejectCreate(id, duelInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRetrieve(id: string, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FightApi - object-oriented interface
 * @export
 * @class FightApi
 * @extends {BaseAPI}
 */
export class FightApi extends BaseAPI {
    /**
     * 
     * @param {FightTurnActionRequest} fightTurnActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightActionCreate(fightTurnActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightHistoryRetrieve(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightHistoryRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightJoinToAttackerSideCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightJoinToDefenderSideCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightLeaveCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationAcceptCreate(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationAcceptCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DuelInvitationRequest} duelInvitationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationCreate(duelInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationList(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {DuelInvitationRequest} duelInvitationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationRejectCreate(id, duelInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlayerApi - axios parameter creator
 * @export
 */
export const PlayerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayerPathRequest} [playerPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerChosePathCreate: async (playerPathRequest?: PlayerPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/chose_path/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCreate: async (openaiCharacterRequest: OpenaiCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openaiCharacterRequest' is not null or undefined
            assertParamExists('playerCreate', 'openaiCharacterRequest', openaiCharacterRequest)
            const localVarPath = `/player/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerDestroy', 'id', id)
            const localVarPath = `/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {PatchedOpenaiCharacterRequest} [patchedOpenaiCharacterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerPartialUpdate: async (id: string, patchedOpenaiCharacterRequest?: PatchedOpenaiCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerPartialUpdate', 'id', id)
            const localVarPath = `/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenaiCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerPlayerInfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/player_info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerRetrieve', 'id', id)
            const localVarPath = `/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerUpdate: async (id: string, openaiCharacterRequest: OpenaiCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerUpdate', 'id', id)
            // verify required parameter 'openaiCharacterRequest' is not null or undefined
            assertParamExists('playerUpdate', 'openaiCharacterRequest', openaiCharacterRequest)
            const localVarPath = `/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayerPathRequest} [playerPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerChosePathCreate(playerPathRequest?: PlayerPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerChosePathCreate(playerPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerChosePathCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerCreate(openaiCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {PatchedOpenaiCharacterRequest} [patchedOpenaiCharacterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerPartialUpdate(id: string, patchedOpenaiCharacterRequest?: PatchedOpenaiCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerPartialUpdate(id, patchedOpenaiCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerPlayerInfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerPlayerInfoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerPlayerInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerUpdate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerUpdate(id, openaiCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayerApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayerPathRequest} [playerPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerChosePathCreate(playerPathRequest?: PlayerPathRequest, options?: any): AxiosPromise<PlayerPath> {
            return localVarFp.playerChosePathCreate(playerPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.playerCreate(openaiCharacterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.playerDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerList(options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.playerList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {PatchedOpenaiCharacterRequest} [patchedOpenaiCharacterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerPartialUpdate(id: string, patchedOpenaiCharacterRequest?: PatchedOpenaiCharacterRequest, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.playerPartialUpdate(id, patchedOpenaiCharacterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerPlayerInfoRetrieve(options?: any): AxiosPromise<PlayerInfo> {
            return localVarFp.playerPlayerInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.playerRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this player.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerUpdate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.playerUpdate(id, openaiCharacterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
    /**
     * 
     * @param {PlayerPathRequest} [playerPathRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerChosePathCreate(playerPathRequest?: PlayerPathRequest, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerChosePathCreate(playerPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OpenaiCharacterRequest} openaiCharacterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerCreate(openaiCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerDestroy(id: string, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerList(options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this player.
     * @param {PatchedOpenaiCharacterRequest} [patchedOpenaiCharacterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerPartialUpdate(id: string, patchedOpenaiCharacterRequest?: PatchedOpenaiCharacterRequest, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerPartialUpdate(id, patchedOpenaiCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerPlayerInfoRetrieve(options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerPlayerInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this player.
     * @param {OpenaiCharacterRequest} openaiCharacterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerUpdate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerUpdate(id, openaiCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/school/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolPathsRetrieve', 'id', id)
            const localVarPath = `/school/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/school/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsRetrieve', 'id', id)
            const localVarPath = `/school/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsList', 'schoolPk', schoolPk)
            const localVarPath = `/school/schools/{school_pk}/skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve: async (id: string, schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'id', id)
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/school/schools/{school_pk}/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsList(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsRetrieve(id, schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList(options?: any): AxiosPromise<Array<OpenaiPath>> {
            return localVarFp.schoolPathsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.schoolPathsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList(options?: any): AxiosPromise<Array<OpenaiSchool>> {
            return localVarFp.schoolSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList(schoolPk: string, options?: any): AxiosPromise<Array<OpenaiSkill>> {
            return localVarFp.schoolSchoolsSkillsList(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsList(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate: async (learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('skillsShoolsCreate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsDestroy', 'id', id)
            const localVarPath = `/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsRetrieve', 'id', id)
            const localVarPath = `/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate: async (learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('skillsSkillsCreate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsDestroy', 'id', id)
            const localVarPath = `/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsRetrieve', 'id', id)
            const localVarPath = `/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsCreate(learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsCreate(learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsShoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList(options?: any): AxiosPromise<Array<LearnedSchool>> {
            return localVarFp.skillsShoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve(id: string, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList(options?: any): AxiosPromise<Array<LearnedSkill>> {
            return localVarFp.skillsSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * 
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorldApi - axios parameter creator
 * @export
 */
export const WorldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/areas/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldAreasRetrieve', 'id', id)
            const localVarPath = `/world/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/cities/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldCitiesRetrieve', 'id', id)
            const localVarPath = `/world/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/dimensions/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldDimensionsRetrieve', 'id', id)
            const localVarPath = `/world/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsChangeCreate', 'id', id)
            const localVarPath = `/world/locations/{id}/change/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/locations/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsRetrieve', 'id', id)
            const localVarPath = `/world/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/position/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldApi - functional programming interface
 * @export
 */
export const WorldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dimension>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsChangeCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsChangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorldApi - factory interface
 * @export
 */
export const WorldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorldApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve(options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList(options?: any): AxiosPromise<Array<Area>> {
            return localVarFp.worldAreasList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve(id: string, options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve(options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList(options?: any): AxiosPromise<Array<City>> {
            return localVarFp.worldCitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve(id: string, options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve(options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList(options?: any): AxiosPromise<Array<Dimension>> {
            return localVarFp.worldDimensionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve(id: number, options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldLocationsChangeCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve(options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList(options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.worldLocationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve(id: string, options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve(options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorldApi - object-oriented interface
 * @export
 * @class WorldApi
 * @extends {BaseAPI}
 */
export class WorldApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsChangeCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



