/* tslint:disable */
/* eslint-disable */
/**
 * DigitalX Game API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractSpawner
 */
export interface AbstractSpawner {
    /**
     * 
     * @type {string}
     * @memberof AbstractSpawner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AbstractSpawner
     */
    'position': string | null;
    /**
     * 
     * @type {number}
     * @memberof AbstractSpawner
     */
    'dimension': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractSpawner
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof AbstractSpawner
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface ActionCycle
 */
export interface ActionCycle {
    /**
     * 
     * @type {number}
     * @memberof ActionCycle
     */
    'id': number;
    /**
     * Cycle number in the campaign
     * @type {number}
     * @memberof ActionCycle
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof ActionCycle
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface ActionImpactModel
 */
export interface ActionImpactModel {
    /**
     * 
     * @type {ImpactType}
     * @memberof ActionImpactModel
     */
    'type': ImpactType;
    /**
     * 
     * @type {ImpactViolationType}
     * @memberof ActionImpactModel
     */
    'violation': ImpactViolationType;
    /**
     * 
     * @type {number}
     * @memberof ActionImpactModel
     */
    'size': number;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof ActionImpactModel
     */
    'dice_roll_result': DiceRollResult;
}


/**
 * 
 * @export
 * @interface ActionModel
 */
export interface ActionModel {
    /**
     * 
     * @type {CharacterActionType}
     * @memberof ActionModel
     */
    'action_type': CharacterActionType;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'initiator_id': string;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'skill_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_dimension_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_location_id': string | null;
}


/**
 * * `USE_SKILL` - USE_SKILL * `USE_ITEM` - USE_ITEM * `DIMENSION_SHIFT` - DIMENSION_SHIFT * `CHANGE_POSITION` - CHANGE_POSITION * `START_DIALOGUE` - START_DIALOGUE * `MAKE_DUEL_INVITATION` - MAKE_DUEL_INVITATION * `ACCEPT_DUEL_INVITATION` - ACCEPT_DUEL_INVITATION * `REJECT_DUEL_INVITATION` - REJECT_DUEL_INVITATION * `START_FIGHT` - START_FIGHT * `MOVE` - MOVE * `DICE_ROLL` - DICE_ROLL * `GIFT` - GIFT * `ANOMALY` - ANOMALY * `GOD_INTERVENTION` - GOD_INTERVENTION * `LONG_REST` - LONG_REST * `BACK_TO_SAFE_ZONE` - BACK_TO_SAFE_ZONE * `INSPECT` - INSPECT * `SNATCH_ITEM` - SNATCH_ITEM
 * @export
 * @enum {string}
 */

export const ActionType5f8Enum = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    DiceRoll: 'DICE_ROLL',
    Gift: 'GIFT',
    Anomaly: 'ANOMALY',
    GodIntervention: 'GOD_INTERVENTION',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM'
} as const;

export type ActionType5f8Enum = typeof ActionType5f8Enum[keyof typeof ActionType5f8Enum];


/**
 * 
 * @export
 * @interface ActiveEffect
 */
export interface ActiveEffect {
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'id': string;
    /**
     * 
     * @type {Effect}
     * @memberof ActiveEffect
     */
    'effect': Effect;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'cycle_left': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'ends_in'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'duration'?: number;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    'impact'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveEffect
     */
    'active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    '_data'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ActiveShield
 */
export interface ActiveShield {
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'id': string;
    /**
     * 
     * @type {Shield}
     * @memberof ActiveShield
     */
    'shield': Shield;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'efficiency': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'cycles_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'health'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'id': string;
    /**
     * 
     * @type {Array<SubLocation>}
     * @memberof Area
     */
    'sub_locations': Array<SubLocation>;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Area
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'city': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Area
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Art
 */
export interface Art {
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'image': string;
}
/**
 * Serializer for assignable effects.
 * @export
 * @interface AssignableEffectRequest
 */
export interface AssignableEffectRequest {
    /**
     * 
     * @type {EffectEnum}
     * @memberof AssignableEffectRequest
     */
    'name': EffectEnum;
    /**
     * 
     * @type {ImpactRequest}
     * @memberof AssignableEffectRequest
     */
    'impact'?: ImpactRequest | null;
    /**
     * 
     * @type {number}
     * @memberof AssignableEffectRequest
     */
    'base_chance': number;
    /**
     * 
     * @type {ModifierRequest}
     * @memberof AssignableEffectRequest
     */
    'duration_modifier': ModifierRequest;
    /**
     * 
     * @type {Array<ModifierRequest>}
     * @memberof AssignableEffectRequest
     */
    'stat_modifiers'?: Array<ModifierRequest>;
}


/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {AttributesEnum}
     * @memberof Attribute
     */
    'name': AttributesEnum;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface AttributeHolder
 */
export interface AttributeHolder {
    /**
     * 
     * @type {AttributeType}
     * @memberof AttributeHolder
     */
    'name': AttributeType;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'current': number | null;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'max': number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AttributeType = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributeType = typeof AttributeType[keyof typeof AttributeType];


/**
 * * `Health` - Health * `Energy` - Energy * `Action Points` - Action Points
 * @export
 * @enum {string}
 */

export const AttributesEnum = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributesEnum = typeof AttributesEnum[keyof typeof AttributesEnum];


/**
 * 
 * @export
 * @interface Bargain
 */
export interface Bargain {
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'id': string;
    /**
     * 
     * @type {Array<OfferedItem>}
     * @memberof Bargain
     */
    'side_a_offered_items': Array<OfferedItem>;
    /**
     * 
     * @type {Array<OfferedItem>}
     * @memberof Bargain
     */
    'side_b_offered_items': Array<OfferedItem>;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'side_a_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'side_b_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'side_a'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'side_b'?: string | null;
}
/**
 * 
 * @export
 * @interface BargainCreateRequest
 */
export interface BargainCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof BargainCreateRequest
     */
    'target_character_id': string;
}
/**
 * Serializer for BaseSkill DTO.
 * @export
 * @interface BaseSkill
 */
export interface BaseSkill {
    /**
     * 
     * @type {string}
     * @memberof BaseSkill
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseSkill
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BaseSkill
     */
    'school': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseSkill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof BaseSkill
     */
    'type': TypeC27Enum;
    /**
     * 
     * @type {number}
     * @memberof BaseSkill
     */
    'grade': number;
    /**
     * 
     * @type {Array<SkillCost>}
     * @memberof BaseSkill
     */
    'cost': Array<SkillCost>;
    /**
     * 
     * @type {Array<Effect>}
     * @memberof BaseSkill
     */
    'effect': Array<Effect>;
    /**
     * 
     * @type {Array<Impact>}
     * @memberof BaseSkill
     */
    'impact': Array<Impact>;
}


/**
 * * `Passive` - Passive * `Aggressive` - Aggressive * `Friendly` - Friendly
 * @export
 * @enum {string}
 */

export const BehaviorEnum = {
    Passive: 'Passive',
    Aggressive: 'Aggressive',
    Friendly: 'Friendly'
} as const;

export type BehaviorEnum = typeof BehaviorEnum[keyof typeof BehaviorEnum];


/**
 * 
 * @export
 * @interface Bio
 */
export interface Bio {
    /**
     * 
     * @type {number}
     * @memberof Bio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof Bio
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'background': string;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'avatar'?: string | null;
}


/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CampaignRequest
 */
export interface CampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRequest
     */
    'name': string;
}
/**
 * * `events` - Events * `rules` - Rules * `lore` - Lore * `stories` - Stories * `guides` - Guides * `items` - Items * `characters` - Characters * `locations` - Locations * `places` - Places * `factions` - Factions * `creatures` - Creatures * `skills` - Skills * `spells` - Spells * `abilities` - Abilities * `other` - Other
 * @export
 * @enum {string}
 */

export const CategoriesEnum = {
    Events: 'events',
    Rules: 'rules',
    Lore: 'lore',
    Stories: 'stories',
    Guides: 'guides',
    Items: 'items',
    Characters: 'characters',
    Locations: 'locations',
    Places: 'places',
    Factions: 'factions',
    Creatures: 'creatures',
    Skills: 'skills',
    Spells: 'spells',
    Abilities: 'abilities',
    Other: 'other'
} as const;

export type CategoriesEnum = typeof CategoriesEnum[keyof typeof CategoriesEnum];


/**
 * Event fired when a new challenge is created for a character.
 * @export
 * @interface ChallengeCreatedEvent
 */
export interface ChallengeCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ChallengeCreatedEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChallengeCreatedEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChallengeCreatedEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof ChallengeCreatedEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {ChallengeCreatedEventData}
     * @memberof ChallengeCreatedEvent
     */
    'data': ChallengeCreatedEventData;
}


/**
 * Data for challenge created event with full typing coverage.
 * @export
 * @interface ChallengeCreatedEventData
 */
export interface ChallengeCreatedEventData {
    /**
     * 
     * @type {string}
     * @memberof ChallengeCreatedEventData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeCreatedEventData
     */
    'character_id': string;
}
/**
 * 
 * @export
 * @interface ChallengeGeneric
 */
export interface ChallengeGeneric {
    /**
     * 
     * @type {string}
     * @memberof ChallengeGeneric
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ChallengeGeneric
     */
    'difficulty'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChallengeGeneric
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChallengeGeneric
     */
    'dice_sides'?: number;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof ChallengeGeneric
     */
    'outcome': DiceRollResult;
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof ChallengeGeneric
     */
    'stat'?: IdEa2Enum;
    /**
     * 
     * @type {boolean}
     * @memberof ChallengeGeneric
     */
    'advantage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChallengeGeneric
     */
    'disadvantage'?: boolean;
    /**
     * 
     * @type {Array<ChallengeModifier>}
     * @memberof ChallengeGeneric
     */
    'modifiers': Array<ChallengeModifier>;
}


/**
 * 
 * @export
 * @interface ChallengeModifier
 */
export interface ChallengeModifier {
    /**
     * 
     * @type {string}
     * @memberof ChallengeModifier
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeModifier
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeModifier
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChallengeModifier
     */
    'value': number;
}
/**
 * Serializer for Chapter model.
 * @export
 * @interface Chapter
 */
export interface Chapter {
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'description': string;
    /**
     * Optional URL to an image representing the chapter
     * @type {string}
     * @memberof Chapter
     */
    'image'?: string | null;
    /**
     * Order of the chapter within the story
     * @type {number}
     * @memberof Chapter
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'story': string;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof Chapter
     */
    'quests': Array<Quest>;
}
/**
 * Serializer for Chapter model.
 * @export
 * @interface ChapterRequest
 */
export interface ChapterRequest {
    /**
     * 
     * @type {string}
     * @memberof ChapterRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChapterRequest
     */
    'description': string;
    /**
     * Optional URL to an image representing the chapter
     * @type {File}
     * @memberof ChapterRequest
     */
    'image'?: File | null;
    /**
     * Order of the chapter within the story
     * @type {number}
     * @memberof ChapterRequest
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChapterRequest
     */
    'story': string;
}
/**
 * 
 * @export
 * @interface CharacterAction
 */
export interface CharacterAction {
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof CharacterAction
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {number}
     * @memberof CharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface CharacterActionLog
 */
export interface CharacterActionLog {
    /**
     * 
     * @type {string}
     * @memberof CharacterActionLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionLog
     */
    'initiator': string;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof CharacterActionLog
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {Skill}
     * @memberof CharacterActionLog
     */
    'skill': Skill;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionLog
     */
    'data'?: any;
    /**
     * 
     * @type {Array<CharacterLogActionImpact>}
     * @memberof CharacterActionLog
     */
    'impacts': Array<CharacterLogActionImpact>;
    /**
     * 
     * @type {ActionCycle}
     * @memberof CharacterActionLog
     */
    'cycle': ActionCycle;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLog
     */
    'performed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLog
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterActionLog
     */
    'targets': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionLog
     */
    'order'?: number;
}


/**
 * 
 * @export
 * @interface CharacterActionRequest
 */
export interface CharacterActionRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof CharacterActionRequest
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CharacterActionType = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    DiceRoll: 'DICE_ROLL',
    Gift: 'GIFT',
    Anomaly: 'ANOMALY',
    GodIntervention: 'GOD_INTERVENTION',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM'
} as const;

export type CharacterActionType = typeof CharacterActionType[keyof typeof CharacterActionType];


/**
 * 
 * @export
 * @interface CharacterBioDraft
 */
export interface CharacterBioDraft {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraft
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraft
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterBioDraftRequest
 */
export interface CharacterBioDraftRequest {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraftRequest
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraftRequest
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterCurrency
 */
export interface CharacterCurrency {
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'character': string;
    /**
     * 
     * @type {CurrencyToken}
     * @memberof CharacterCurrency
     */
    'currency': CurrencyToken;
    /**
     * 
     * @type {number}
     * @memberof CharacterCurrency
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CharacterExample1GameEvent
 */
export interface CharacterExample1GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample1GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample1GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample1GameEventData}
     * @memberof CharacterExample1GameEvent
     */
    'data': CharacterExample1GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample1GameEventData
 */
export interface CharacterExample1GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEventData
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface CharacterExample2GameEvent
 */
export interface CharacterExample2GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample2GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample2GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample2GameEventData}
     * @memberof CharacterExample2GameEvent
     */
    'data': CharacterExample2GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample2GameEventData
 */
export interface CharacterExample2GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEventData
     */
    'field2': string;
}
/**
 * 
 * @export
 * @interface CharacterGenericData
 */
export interface CharacterGenericData {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraft}
     * @memberof CharacterGenericData
     */
    'bio': CharacterBioDraft;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericData
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStat>}
     * @memberof CharacterGenericData
     */
    'stats': Array<CharacterStat>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericData
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterGenericDataRequest
 */
export interface CharacterGenericDataRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraftRequest}
     * @memberof CharacterGenericDataRequest
     */
    'bio': CharacterBioDraftRequest;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericDataRequest
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStatRequest>}
     * @memberof CharacterGenericDataRequest
     */
    'stats': Array<CharacterStatRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericDataRequest
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterInfo
 */
export interface CharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof CharacterInfo
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'fight': string | null;
}
/**
 * 
 * @export
 * @interface CharacterItem
 */
export interface CharacterItem {
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'id': string;
    /**
     * 
     * @type {WorldItem}
     * @memberof CharacterItem
     */
    'world_item': WorldItem;
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'character': string;
}
/**
 * 
 * @export
 * @interface CharacterJoinFightEvent
 */
export interface CharacterJoinFightEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterJoinFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterJoinFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterJoinFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterJoinFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterJoinFightEventData}
     * @memberof CharacterJoinFightEvent
     */
    'data': CharacterJoinFightEventData;
}


/**
 * 
 * @export
 * @interface CharacterJoinFightEventData
 */
export interface CharacterJoinFightEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterJoinFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterJoinFightEventData
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterJoinFightEventData
     */
    'position_id': string;
}
/**
 * 
 * @export
 * @interface CharacterLeaveFightEvent
 */
export interface CharacterLeaveFightEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterLeaveFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterLeaveFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterLeaveFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterLeaveFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterLeaveFightEventData}
     * @memberof CharacterLeaveFightEvent
     */
    'data': CharacterLeaveFightEventData;
}


/**
 * 
 * @export
 * @interface CharacterLeaveFightEventData
 */
export interface CharacterLeaveFightEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterLeaveFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterLeaveFightEventData
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterLeaveFightEventData
     */
    'position_id': string;
}
/**
 * 
 * @export
 * @interface CharacterLogActionImpact
 */
export interface CharacterLogActionImpact {
    /**
     * 
     * @type {string}
     * @memberof CharacterLogActionImpact
     */
    'id': string;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof CharacterLogActionImpact
     */
    'dice_roll_result': DiceRollResult;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof CharacterLogActionImpact
     */
    'type': ImpactTypeEnum;
    /**
     * 
     * @type {ViolationEnum}
     * @memberof CharacterLogActionImpact
     */
    'violation': ViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterLogActionImpact
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterLogActionImpact
     */
    'target': string;
}


/**
 * 
 * @export
 * @interface CharacterModificator
 */
export interface CharacterModificator {
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'character': string;
    /**
     * 
     * @type {Modificator}
     * @memberof CharacterModificator
     */
    'modificator': Modificator;
}
/**
 * 
 * @export
 * @interface CharacterNewTurnGameEvent
 */
export interface CharacterNewTurnGameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterNewTurnGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterNewTurnGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterNewTurnGameEventData}
     * @memberof CharacterNewTurnGameEvent
     */
    'data': CharacterNewTurnGameEventData;
}


/**
 * 
 * @export
 * @interface CharacterNewTurnGameEventData
 */
export interface CharacterNewTurnGameEventData {
    /**
     * 
     * @type {CurrentTurn}
     * @memberof CharacterNewTurnGameEventData
     */
    'current_turn': CurrentTurn;
    /**
     * 
     * @type {FullCharacterInfo}
     * @memberof CharacterNewTurnGameEventData
     */
    'character_info': FullCharacterInfo;
}
/**
 * 
 * @export
 * @interface CharacterOnPosition
 */
export interface CharacterOnPosition {
    /**
     * 
     * @type {string}
     * @memberof CharacterOnPosition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterOnPosition
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterOnPosition
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CharacterOnPosition
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterOnPosition
     */
    'npc'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterOnPosition
     */
    'alive': boolean;
}
/**
 * 
 * @export
 * @interface CharacterPath
 */
export interface CharacterPath {
    /**
     * 
     * @type {string}
     * @memberof CharacterPath
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterPathRequest
 */
export interface CharacterPathRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterPathRequest
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterPendingJoinFightEvent
 */
export interface CharacterPendingJoinFightEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterPendingJoinFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterPendingJoinFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterPendingJoinFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterPendingJoinFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterPendingJoinFightEventData}
     * @memberof CharacterPendingJoinFightEvent
     */
    'data': CharacterPendingJoinFightEventData;
}


/**
 * 
 * @export
 * @interface CharacterPendingJoinFightEventData
 */
export interface CharacterPendingJoinFightEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterPendingJoinFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterPendingJoinFightEventData
     */
    'character_id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterPendingJoinFightEventData
     */
    'position_id': string;
}
/**
 * 
 * @export
 * @interface CharacterStat
 */
export interface CharacterStat {
    /**
     * 
     * @type {string}
     * @memberof CharacterStat
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStat
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterStatRequest
 */
export interface CharacterStatRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterStatRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStatRequest
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterStats
 */
export interface CharacterStats {
    /**
     * 
     * @type {Array<Stat>}
     * @memberof CharacterStats
     */
    'stats': Array<Stat>;
}
/**
 * 
 * @export
 * @interface CharacterTemplate
 */
export interface CharacterTemplate {
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Bio}
     * @memberof CharacterTemplate
     */
    'bio': Bio;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplate
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'path': string | null;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof CharacterTemplate
     */
    'stats'?: Array<Stat>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'modificators'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'items'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'schools'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'spells'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CharacterTemplateFull
 */
export interface CharacterTemplateFull {
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateFull
     */
    'id'?: string | null;
    /**
     * 
     * @type {CharacterTemplate}
     * @memberof CharacterTemplateFull
     */
    'data': CharacterTemplate;
    /**
     * 
     * @type {CharacterTemplateValidation}
     * @memberof CharacterTemplateFull
     */
    'validation': CharacterTemplateValidation;
}
/**
 * Serializer for CharacterTemplate model.  This serializer provides the necessary data for listing character templates, including template name, id, behavior, organization, avatar, grade, and path.
 * @export
 * @interface CharacterTemplateGameMaster
 */
export interface CharacterTemplateGameMaster {
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'name': string;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof CharacterTemplateGameMaster
     */
    'behavior': BehaviorEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'organization': string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'organization_name': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplateGameMaster
     */
    'grade': string;
    /**
     * 
     * @type {ThePath}
     * @memberof CharacterTemplateGameMaster
     */
    'path': ThePath;
}


/**
 * 
 * @export
 * @interface CharacterTemplateValidation
 */
export interface CharacterTemplateValidation {
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_stats_points_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_modificators_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_items_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_spells_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_rank_grade': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_schools_count': number;
}
/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof City
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof City
     */
    'border_with'?: Array<string>;
}
/**
 * Serializer for Condition model.
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    'id': string;
    /**
     * 
     * @type {ConditionTypeEnum}
     * @memberof Condition
     */
    'type'?: ConditionTypeEnum;
    /**
     * 
     * @type {Array<Trigger>}
     * @memberof Condition
     */
    'triggers': Array<Trigger>;
}


/**
 * Serializer for Condition model.
 * @export
 * @interface ConditionRequest
 */
export interface ConditionRequest {
    /**
     * 
     * @type {ConditionTypeEnum}
     * @memberof ConditionRequest
     */
    'type'?: ConditionTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionRequest
     */
    'trigger_ids'?: Array<string>;
}


/**
 * * `all` - All * `any` - Any * `none` - None
 * @export
 * @enum {string}
 */

export const ConditionTypeEnum = {
    All: 'all',
    Any: 'any',
    None: 'none'
} as const;

export type ConditionTypeEnum = typeof ConditionTypeEnum[keyof typeof ConditionTypeEnum];


/**
 * \"client\": \"435f309f-32f4-485d-9b88-6c2daca71555\", \"transport\": \"websocket\", \"protocol\": \"json\", \"encoding\": \"json\", \"name\": \"js\"
 * @export
 * @interface ConnectRequest
 */
export interface ConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'transport': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Coordinate
 */
export interface Coordinate {
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'z': number;
}
/**
 * Serializer for skill costs.
 * @export
 * @interface CostRequest
 */
export interface CostRequest {
    /**
     * 
     * @type {AttributesEnum}
     * @memberof CostRequest
     */
    'kind': AttributesEnum;
    /**
     * 
     * @type {number}
     * @memberof CostRequest
     */
    'value': number;
}


/**
 * Serializer for creating an NPC from a template.  This serializer validates the data needed to create an NPC from a template, including the template ID and position ID.
 * @export
 * @interface CreateNPCFromTemplate
 */
export interface CreateNPCFromTemplate {
    /**
     * 
     * @type {string}
     * @memberof CreateNPCFromTemplate
     */
    'template_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCFromTemplate
     */
    'position_id': string;
}
/**
 * Serializer for creating an NPC from a template.  This serializer validates the data needed to create an NPC from a template, including the template ID and position ID.
 * @export
 * @interface CreateNPCFromTemplateRequest
 */
export interface CreateNPCFromTemplateRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNPCFromTemplateRequest
     */
    'template_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNPCFromTemplateRequest
     */
    'position_id': string;
}
/**
 * 
 * @export
 * @interface CurrencyToken
 */
export interface CurrencyToken {
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface CurrencyTokenRequest
 */
export interface CurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof CurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface CurrentClientInfo
 */
export interface CurrentClientInfo {
    /**
     * 
     * @type {string}
     * @memberof CurrentClientInfo
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentClientInfo
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {OpenAICampaign}
     * @memberof CurrentClientInfo
     */
    'current_campaign': OpenAICampaign;
    /**
     * 
     * @type {OpenaiCharacter}
     * @memberof CurrentClientInfo
     */
    'main_character': OpenaiCharacter;
    /**
     * 
     * @type {Array<OpenAICampaign>}
     * @memberof CurrentClientInfo
     */
    'play_campaigns': Array<OpenAICampaign>;
    /**
     * 
     * @type {Array<OpenAICampaign>}
     * @memberof CurrentClientInfo
     */
    'master_campaigns': Array<OpenAICampaign>;
    /**
     * 
     * @type {Array<OpenaiCharacter>}
     * @memberof CurrentClientInfo
     */
    'owned_characters': Array<OpenaiCharacter>;
}
/**
 * 
 * @export
 * @interface CurrentTurn
 */
export interface CurrentTurn {
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'started_at': string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTurn
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field2': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field1': string;
}
/**
 * Serializer for DateTimeInfo objects
 * @export
 * @interface DateTimeInfo
 */
export interface DateTimeInfo {
    /**
     * 
     * @type {string}
     * @memberof DateTimeInfo
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof DateTimeInfo
     */
    'active_glow'?: boolean;
    /**
     * Number of sol\'s since the start of the calendar
     * @type {number}
     * @memberof DateTimeInfo
     */
    'sol'?: number;
    /**
     * Number of solar years since the start of the calendar
     * @type {number}
     * @memberof DateTimeInfo
     */
    'solar_year'?: number;
}
/**
 * Serializer for DateTimeInfo objects
 * @export
 * @interface DateTimeInfoRequest
 */
export interface DateTimeInfoRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DateTimeInfoRequest
     */
    'active_glow'?: boolean;
    /**
     * Number of sol\'s since the start of the calendar
     * @type {number}
     * @memberof DateTimeInfoRequest
     */
    'sol'?: number;
    /**
     * Number of solar years since the start of the calendar
     * @type {number}
     * @memberof DateTimeInfoRequest
     */
    'solar_year'?: number;
}
/**
 * 
 * @export
 * @interface DetailStat
 */
export interface DetailStat {
    /**
     * 
     * @type {string}
     * @memberof DetailStat
     */
    'id': string;
    /**
     * 
     * @type {Array<DiceRollResult>}
     * @memberof DetailStat
     */
    'dice_rolls': Array<DiceRollResult>;
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof DetailStat
     */
    'name'?: IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof DetailStat
     */
    'additional_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof DetailStat
     */
    'base_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof DetailStat
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface DetailedBargain
 */
export interface DetailedBargain {
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'id': string;
    /**
     * 
     * @type {Array<DetailedOfferedItem>}
     * @memberof DetailedBargain
     */
    'side_a_offered_items': Array<DetailedOfferedItem>;
    /**
     * 
     * @type {Array<DetailedOfferedItem>}
     * @memberof DetailedBargain
     */
    'side_b_offered_items': Array<DetailedOfferedItem>;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'side_a_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'side_b_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'side_a'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'side_b'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailedOfferedItem
 */
export interface DetailedOfferedItem {
    /**
     * 
     * @type {string}
     * @memberof DetailedOfferedItem
     */
    'id': string;
    /**
     * 
     * @type {Nested}
     * @memberof DetailedOfferedItem
     */
    'item': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof DetailedOfferedItem
     */
    'bargain': Nested;
}
/**
 * Serializer for detailed Rank information.  Includes all relevant fields from the Rank model to provide comprehensive information about a character\'s rank.
 * @export
 * @interface DetailedRank
 */
export interface DetailedRank {
    /**
     * 
     * @type {string}
     * @memberof DetailedRank
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DetailedRank
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DetailedRank
     */
    'grade': number;
    /**
     * 
     * @type {number}
     * @memberof DetailedRank
     */
    'grade_rank': number;
    /**
     * 
     * @type {string}
     * @memberof DetailedRank
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof DetailedRank
     */
    'experience_needed': number;
    /**
     * 
     * @type {number}
     * @memberof DetailedRank
     */
    'additional_stat_points': number;
}
/**
 * 
 * @export
 * @interface DiceRollResult
 */
export interface DiceRollResult {
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'dice_side': number;
    /**
     * 
     * @type {OutcomeEnum}
     * @memberof DiceRollResult
     */
    'outcome': OutcomeEnum;
}


/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'energy': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Dimension
     */
    'is_active'?: boolean;
}
/**
 * Serializer for Document objects
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'content': string;
    /**
     * 
     * @type {Array<CategoriesEnum>}
     * @memberof Document
     */
    'categories'?: Array<CategoriesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'image'?: string | null;
}
/**
 * Serializer for Document objects
 * @export
 * @interface DocumentRequest
 */
export interface DocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentRequest
     */
    'content': string;
    /**
     * 
     * @type {Array<CategoriesEnum>}
     * @memberof DocumentRequest
     */
    'categories'?: Array<CategoriesEnum>;
    /**
     * 
     * @type {File}
     * @memberof DocumentRequest
     */
    'image'?: File | null;
}
/**
 * 
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * 
     * @type {EffectEnum}
     * @memberof Effect
     */
    'id'?: EffectEnum;
    /**
     * 
     * @type {string}
     * @memberof Effect
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Effect
     */
    'permanent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Effect
     */
    'ends_in'?: number | null;
}


/**
 * * `Knocked out` - Knocked out * `Coma` - Coma * `None` - None * `Burning` - Burning * `Poisoned` - Poisoned * `Sleeping` - Sleeping * `Confused` - Confused * `Paralyzed` - Paralyzed * `Fear` - Fear * `Slowness` - Slowness * `Cold` - Cold * `Cursed` - Cursed * `Blindness` - Blindness * `Haste` - Haste * `Regeneration` - Regeneration * `Blessed` - Blessed * `Arcane Surge` - Arcane Surge * `Marked` - Marked
 * @export
 * @enum {string}
 */

export const EffectEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;

export type EffectEnum = typeof EffectEnum[keyof typeof EffectEnum];


/**
 * Serializer for EffectReward model.
 * @export
 * @interface EffectReward
 */
export interface EffectReward {
    /**
     * 
     * @type {string}
     * @memberof EffectReward
     */
    'id': string;
    /**
     * 
     * @type {EffectEnum}
     * @memberof EffectReward
     */
    'effect': EffectEnum;
    /**
     * Duration of the effect in turns
     * @type {number}
     * @memberof EffectReward
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof EffectReward
     */
    'reward'?: string | null;
}


/**
 * Serializer for EffectReward model.
 * @export
 * @interface EffectRewardRequest
 */
export interface EffectRewardRequest {
    /**
     * 
     * @type {EffectEnum}
     * @memberof EffectRewardRequest
     */
    'effect': EffectEnum;
    /**
     * Duration of the effect in turns
     * @type {number}
     * @memberof EffectRewardRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof EffectRewardRequest
     */
    'reward'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EventCategory = {
    Character: 'character',
    Location: 'location',
    Fight: 'fight',
    Game: 'game',
    World: 'world'
} as const;

export type EventCategory = typeof EventCategory[keyof typeof EventCategory];


/**
 * 
 * @export
 * @interface FightEndedEvent
 */
export interface FightEndedEvent {
    /**
     * 
     * @type {string}
     * @memberof FightEndedEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightEndedEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightEndedEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightEndedEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {FightEndedEventData}
     * @memberof FightEndedEvent
     */
    'data': FightEndedEventData;
}


/**
 * 
 * @export
 * @interface FightEndedEventData
 */
export interface FightEndedEventData {
    /**
     * 
     * @type {string}
     * @memberof FightEndedEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof FightEndedEventData
     */
    'position_id': string;
    /**
     * 
     * @type {number}
     * @memberof FightEndedEventData
     */
    'cycle_id': number;
}
/**
 * 
 * @export
 * @interface FightGeneric
 */
export interface FightGeneric {
    /**
     * 
     * @type {string}
     * @memberof FightGeneric
     */
    'id': string;
    /**
     * 
     * @type {Array<Fighter>}
     * @memberof FightGeneric
     */
    'joined': Array<Fighter>;
    /**
     * 
     * @type {Array<Fighter>}
     * @memberof FightGeneric
     */
    'pending_join': Array<Fighter>;
    /**
     * 
     * @type {Fighter}
     * @memberof FightGeneric
     */
    'attacker': Fighter;
    /**
     * 
     * @type {Fighter}
     * @memberof FightGeneric
     */
    'defender': Fighter;
    /**
     * 
     * @type {boolean}
     * @memberof FightGeneric
     */
    'duel'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FightGeneric
     */
    'current_round'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FightGeneric
     */
    'open'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FightGeneric
     */
    'campaign': string;
    /**
     * 
     * @type {string}
     * @memberof FightGeneric
     */
    'position': string;
    /**
     * 
     * @type {number}
     * @memberof FightGeneric
     */
    'created'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FightGeneric
     */
    'ended_at'?: number | null;
}
/**
 * 
 * @export
 * @interface FightStartedEvent
 */
export interface FightStartedEvent {
    /**
     * 
     * @type {string}
     * @memberof FightStartedEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightStartedEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightStartedEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightStartedEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {FightStartedEventData}
     * @memberof FightStartedEvent
     */
    'data': FightStartedEventData;
}


/**
 * 
 * @export
 * @interface FightStartedEventData
 */
export interface FightStartedEventData {
    /**
     * 
     * @type {string}
     * @memberof FightStartedEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof FightStartedEventData
     */
    'position_id': string;
    /**
     * 
     * @type {string}
     * @memberof FightStartedEventData
     */
    'attacker_id': string;
    /**
     * 
     * @type {string}
     * @memberof FightStartedEventData
     */
    'defender_id': string;
}
/**
 * 
 * @export
 * @interface FightTurnActionResultGameEvent
 */
export interface FightTurnActionResultGameEvent {
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionResultGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightTurnActionResultGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {TurnActionResultGameEventData}
     * @memberof FightTurnActionResultGameEvent
     */
    'data': TurnActionResultGameEventData;
}


/**
 * 
 * @export
 * @interface Fighter
 */
export interface Fighter {
    /**
     * 
     * @type {string}
     * @memberof Fighter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Fighter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Fighter
     */
    'path_name': string;
    /**
     * 
     * @type {string}
     * @memberof Fighter
     */
    'rank_name': string;
    /**
     * 
     * @type {string}
     * @memberof Fighter
     */
    'avatar': string;
    /**
     * 
     * @type {boolean}
     * @memberof Fighter
     */
    'alive': boolean;
}
/**
 * Serializer for Formula DTO.
 * @export
 * @interface Formula
 */
export interface Formula {
    /**
     * 
     * @type {number}
     * @memberof Formula
     */
    'base': number;
    /**
     * 
     * @type {Array<StatRequirement>}
     * @memberof Formula
     */
    'requires': Array<StatRequirement>;
    /**
     * 
     * @type {Array<Scaling>}
     * @memberof Formula
     */
    'scaling': Array<Scaling>;
    /**
     * 
     * @type {number}
     * @memberof Formula
     */
    'max_efficiency'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Formula
     */
    'min_efficiency'?: number | null;
}
/**
 * Serializer for formula calculations.
 * @export
 * @interface FormulaRequest
 */
export interface FormulaRequest {
    /**
     * 
     * @type {number}
     * @memberof FormulaRequest
     */
    'base': number;
    /**
     * 
     * @type {Array<StatRequirementRequest>}
     * @memberof FormulaRequest
     */
    'requires'?: Array<StatRequirementRequest>;
    /**
     * 
     * @type {Array<ScalingRequest>}
     * @memberof FormulaRequest
     */
    'scaling'?: Array<ScalingRequest>;
    /**
     * 
     * @type {number}
     * @memberof FormulaRequest
     */
    'max_efficiency'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FormulaRequest
     */
    'min_efficiency'?: number | null;
}
/**
 * 
 * @export
 * @interface FullCharacterInfo
 */
export interface FullCharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<AttributeHolder>}
     * @memberof FullCharacterInfo
     */
    'attributes': Array<AttributeHolder>;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'position': string | null;
    /**
     * 
     * @type {Coordinate}
     * @memberof FullCharacterInfo
     */
    'coordinates': Coordinate | null;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'fight': string | null;
}
/**
 * 
 * @export
 * @interface GameCycle
 */
export interface GameCycle {
    /**
     * 
     * @type {number}
     * @memberof GameCycle
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof GameCycle
     */
    'is_current': boolean;
    /**
     * 
     * @type {string}
     * @memberof GameCycle
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof GameCycle
     */
    'updated_at': string;
    /**
     * Cycle number in the campaign
     * @type {number}
     * @memberof GameCycle
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof GameCycle
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface GameEventRequest
 */
export interface GameEventRequest {
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GameEventRequest
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof GameEventRequest
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {Data}
     * @memberof GameEventRequest
     */
    'data': Data;
}


/**
 * 
 * @export
 * @interface GameMasterChallengeResponse
 */
export interface GameMasterChallengeResponse {
    /**
     * 
     * @type {string}
     * @memberof GameMasterChallengeResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof GameMasterChallengeResponse
     */
    'difficulty': number;
    /**
     * 
     * @type {string}
     * @memberof GameMasterChallengeResponse
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof GameMasterChallengeResponse
     */
    'dice_sides': number;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterChallengeResponse
     */
    'outcome': Nested;
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof GameMasterChallengeResponse
     */
    'stat': IdEa2Enum;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterChallengeResponse
     */
    'advantage': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterChallengeResponse
     */
    'disadvantage': boolean;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof GameMasterChallengeResponse
     */
    'modifiers': Array<Nested>;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterChallengeResponse
     */
    'target': Nested;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterAction
 */
export interface GameMasterCharacterAction {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof GameMasterCharacterAction
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionLog
 */
export interface GameMasterCharacterActionLog {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionLog
     */
    'id': string;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'initiator': Nested;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof GameMasterCharacterActionLog
     */
    'targets': Array<Nested>;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof GameMasterCharacterActionLog
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {Skill}
     * @memberof GameMasterCharacterActionLog
     */
    'skill': Skill;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionLog
     */
    'data'?: any;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'position': Nested;
    /**
     * 
     * @type {Array<GameMasterCharacterLogActionImpact>}
     * @memberof GameMasterCharacterActionLog
     */
    'impacts': Array<GameMasterCharacterLogActionImpact>;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'cycle': Nested;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionLog
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionLogRequest
 */
export interface GameMasterCharacterActionLogRequest {
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionRequest
 */
export interface GameMasterCharacterActionRequest {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof GameMasterCharacterActionRequest
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * Serializer for Game Master character information.  This serializer provides all the necessary data for rendering a GameMasterCharacterCard component.  Included data: 1. Shields: Using ActiveShieldSerializer to include shields related to the character. 2. Attributes: Using AttributeSerializer to include character attributes. 3. Active Effects: Using ActiveEffectSerializer to include active effects on the character. 4. Items: Using CharacterItemSerializer to include character\'s equipped items. 5. Currency: Using CharacterCurrencySerializer to include character\'s currency information. 6. Biography: Using OpenaiCharacterBioSerializer to include character\'s biographical information    (age, gender, background, appearance, avatar). 7. Path: Using ThePathSerializer to include character\'s path information (name, description, icon). 8. Rank: Using DetailedRankSerializer to include detailed rank information    (grade, grade_rank, description, experience_needed, etc.).  Character Card Layout Description for Frontend Developers: --------------------------------------------------------  The GameMasterCharacterCard is a vertically oriented card with the following layout:  1. Top Section:    - Character avatar (large, centered, from biography.avatar)    - Character name (prominent, below avatar)    - Character biographical details (age, gender from biography)    - Character rank and path information (below name)      * Rank displayed with grade, grade_rank, and name      * Path displayed with name and icon    - Other basic character info like organization, tags, etc.    - Left side overlay: Active shields displayed as vertical bars or icons      * Each shield shows its type, level, and efficiency      * Visual indicator of shield health/status    - Right side overlay: Active effects displayed as icons with tooltips      * Each effect shows its type and remaining cycles      * Visual indicator for permanent vs temporary effects  2. Middle Section:    - Character background and appearance information (from biography)      * Background displayed as a collapsible text section      * Appearance displayed as a collapsible text section  3. Bottom Section:    - Character attributes displayed as horizontal bars      * Each attribute shows name, current value, and max value      * Color-coded bars for different attribute types  4. External Sections:    - Bottom panel main: Inventory items displayed as a grid      * Each item shows its icon, name, type, and quantity      * Items grouped by type if possible    - Bottom panel bottom: Currency information      * Each currency type with icon and amount      * Totals and conversions if applicable  Responsive Design Considerations: - On smaller screens, the layout should adjust to maintain readability - Consider collapsible sections for detailed information - Ensure tooltips are accessible on touch devices  Interaction Guidelines: - Hover on shields, effects, or items should show detailed information in alt like tooltips - Consider item selection for further actions (e.g., emmit event to upper components) - Provide visual feedback for interactive elements
 * @export
 * @interface GameMasterCharacterInfo
 */
export interface GameMasterCharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'id': string;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof GameMasterCharacterInfo
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {Array<ActiveShield>}
     * @memberof GameMasterCharacterInfo
     */
    'shields': Array<ActiveShield>;
    /**
     * 
     * @type {Array<ActiveEffect>}
     * @memberof GameMasterCharacterInfo
     */
    'effects': Array<ActiveEffect>;
    /**
     * 
     * @type {Array<CharacterItem>}
     * @memberof GameMasterCharacterInfo
     */
    'equipped_items': Array<CharacterItem>;
    /**
     * 
     * @type {Array<CharacterCurrency>}
     * @memberof GameMasterCharacterInfo
     */
    'tokens': Array<CharacterCurrency>;
    /**
     * 
     * @type {OpenaiCharacterBio}
     * @memberof GameMasterCharacterInfo
     */
    'biography': OpenaiCharacterBio;
    /**
     * 
     * @type {ThePath}
     * @memberof GameMasterCharacterInfo
     */
    'path': ThePath;
    /**
     * 
     * @type {DetailedRank}
     * @memberof GameMasterCharacterInfo
     */
    'rank': DetailedRank;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterInfo
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterInfo
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterInfo
     */
    'npc'?: boolean;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof GameMasterCharacterInfo
     */
    'behavior'?: BehaviorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterInfo
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'polymorphic_ctype': number | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterInfo
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'campaign': string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'template'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'last_safe_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterInfo
     */
    'challenge'?: string | null;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterLogActionImpact
 */
export interface GameMasterCharacterLogActionImpact {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'id': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'type': ImpactTypeEnum;
    /**
     * 
     * @type {ViolationEnum}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'violation': ViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'size': number;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'target': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'dice_roll_result': Nested;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterLogActionImpactRequest
 */
export interface GameMasterCharacterLogActionImpactRequest {
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'type': ImpactTypeEnum;
    /**
     * 
     * @type {ViolationEnum}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'violation': ViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'size': number;
}


/**
 * Serialize character stats for Game Master.
 * @export
 * @interface GameMasterCharacterStat
 */
export interface GameMasterCharacterStat {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterStat
     */
    'id': string;
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof GameMasterCharacterStat
     */
    'name'?: IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterStat
     */
    'additional_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterStat
     */
    'base_value'?: number;
}


/**
 * Serializer for character stats card. Used in GameMasterCharacterCard component.  This serializer provides a compact view of character stats, suitable for displaying in a character stats card component.
 * @export
 * @interface GameMasterCharacterStatsCard
 */
export interface GameMasterCharacterStatsCard {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterStatsCard
     */
    'id': string;
    /**
     * 
     * @type {Array<GameMasterCharacterStat>}
     * @memberof GameMasterCharacterStatsCard
     */
    'stats': Array<GameMasterCharacterStat>;
}
/**
 * Serializer for GameMaster challenge creation requests.  This serializer handles the data needed to create a challenge for a character, including target selection, dice configuration, difficulty, and modifiers.
 * @export
 * @interface GameMasterCreateChallengeRequest
 */
export interface GameMasterCreateChallengeRequest {
    /**
     * The character who will face this challenge
     * @type {string}
     * @memberof GameMasterCreateChallengeRequest
     */
    'target_character': string;
    /**
     * Difficulty Class (DC) for the challenge
     * @type {number}
     * @memberof GameMasterCreateChallengeRequest
     */
    'difficulty': number;
    /**
     * Number of sides on the dice (default: 20)
     * @type {number}
     * @memberof GameMasterCreateChallengeRequest
     */
    'dice_sides'?: number;
    /**
     * Character stat to use for the challenge  * `Physical Strength` - Physical Strength * `Mental Strength` - Mental Strength * `Flow Resonance` - Flow Resonance * `Concentration` - Concentration * `Flow Manipulation` - Flow Manipulation * `Flow Connection` - Flow Connection * `Knowledge` - Knowledge * `Speed` - Speed * `Luck` - Luck * `Charisma` - Charisma
     * @type {IdEa2Enum}
     * @memberof GameMasterCreateChallengeRequest
     */
    'stat'?: IdEa2Enum;
    /**
     * Whether the character has advantage on this challenge
     * @type {boolean}
     * @memberof GameMasterCreateChallengeRequest
     */
    'advantage'?: boolean;
    /**
     * Whether the character has disadvantage on this challenge
     * @type {boolean}
     * @memberof GameMasterCreateChallengeRequest
     */
    'disadvantage'?: boolean;
    /**
     * Optional description of the challenge
     * @type {string}
     * @memberof GameMasterCreateChallengeRequest
     */
    'description'?: string;
    /**
     * List of modifiers to apply to the challenge
     * @type {Array<string>}
     * @memberof GameMasterCreateChallengeRequest
     */
    'modifiers'?: Array<string>;
}


/**
 * 
 * @export
 * @interface GameMasterItem
 */
export interface GameMasterItem {
    /**
     * 
     * @type {string}
     * @memberof GameMasterItem
     */
    'id': string;
    /**
     * 
     * @type {BaseSkill}
     * @memberof GameMasterItem
     */
    'skill': BaseSkill;
    /**
     * 
     * @type {Effect}
     * @memberof GameMasterItem
     */
    'effect': Effect;
    /**
     * 
     * @type {string}
     * @memberof GameMasterItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterItem
     */
    'icon'?: string | null;
    /**
     * 
     * @type {Type496Enum}
     * @memberof GameMasterItem
     */
    'type'?: Type496Enum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterItem
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterItem
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterItem
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameMasterItem
     */
    'base_price'?: number;
}


/**
 * 
 * @export
 * @interface GameObject
 */
export interface GameObject {
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GameObject
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GameObject
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'campaign': string;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'object_type': string;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'real_instance': string;
}
/**
 * 
 * @export
 * @interface GameObjectRequest
 */
export interface GameObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof GameObjectRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GameObjectRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GameObjectRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GameObjectRequest
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface GameObjectType
 */
export interface GameObjectType {
    /**
     * 
     * @type {string}
     * @memberof GameObjectType
     */
    'model': string;
    /**
     * 
     * @type {string}
     * @memberof GameObjectType
     */
    'app_label': string;
    /**
     * 
     * @type {string}
     * @memberof GameObjectType
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GamemasterImpersonationImpersonateCreate400Response
 */
export interface GamemasterImpersonationImpersonateCreate400Response {
    /**
     * 
     * @type {string}
     * @memberof GamemasterImpersonationImpersonateCreate400Response
     */
    'detail'?: string;
}
/**
 * * `Male` - Male * `Female` - Female * `Other` - Other
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Other: 'Other'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * 
 * @export
 * @interface GenericPosition
 */
export interface GenericPosition {
    /**
     * 
     * @type {string}
     * @memberof GenericPosition
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof GenericPosition
     */
    'sub_location': string;
}
/**
 * 
 * @export
 * @interface GenericPositionId
 */
export interface GenericPositionId {
    /**
     * 
     * @type {string}
     * @memberof GenericPositionId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GenericPositionIdRequest
 */
export interface GenericPositionIdRequest {
    /**
     * 
     * @type {string}
     * @memberof GenericPositionIdRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GenericSpawner
 */
export interface GenericSpawner {
    /**
     * 
     * @type {string}
     * @memberof GenericSpawner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericSpawner
     */
    'position': string | null;
    /**
     * 
     * @type {number}
     * @memberof GenericSpawner
     */
    'dimension': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenericSpawner
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof GenericSpawner
     */
    'campaign': string;
    /**
     * 
     * @type {GameObjectType}
     * @memberof GenericSpawner
     */
    'object_type': GameObjectType;
    /**
     * 
     * @type {OneOf}
     * @memberof GenericSpawner
     */
    'real_instance': OneOf;
    /**
     * 
     * @type {number}
     * @memberof GenericSpawner
     */
    'spawn_limit': number;
    /**
     * 
     * @type {number}
     * @memberof GenericSpawner
     */
    'respawn_cycles': number;
    /**
     * Cycle number when the next spawn should occur
     * @type {number}
     * @memberof GenericSpawner
     */
    'next_spawn_cycle_number': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GenericSpawner
     */
    'spawned_entities': Array<string>;
}
/**
 * Serializer for God Intervention actions.  This serializer is used for the god_intervention endpoint in GameMasterCharacterViewSet. It validates the data needed to create a GodIntervention object.
 * @export
 * @interface GodIntervention
 */
export interface GodIntervention {
    /**
     * 
     * @type {GodInterventionTypeEnum}
     * @memberof GodIntervention
     */
    'type': GodInterventionTypeEnum;
    /**
     * 
     * @type {SizeEnum}
     * @memberof GodIntervention
     */
    'size': SizeEnum;
    /**
     * 
     * @type {Array<AttributesEnum>}
     * @memberof GodIntervention
     */
    'attributes': Array<AttributesEnum>;
}


/**
 * Serializer for God Intervention actions.  This serializer is used for the god_intervention endpoint in GameMasterCharacterViewSet. It validates the data needed to create a GodIntervention object.
 * @export
 * @interface GodInterventionRequest
 */
export interface GodInterventionRequest {
    /**
     * 
     * @type {GodInterventionTypeEnum}
     * @memberof GodInterventionRequest
     */
    'type': GodInterventionTypeEnum;
    /**
     * 
     * @type {SizeEnum}
     * @memberof GodInterventionRequest
     */
    'size': SizeEnum;
    /**
     * 
     * @type {Array<AttributesEnum>}
     * @memberof GodInterventionRequest
     */
    'attributes': Array<AttributesEnum>;
}


/**
 * * `Blessing` - Blessing * `Curse` - Curse
 * @export
 * @enum {string}
 */

export const GodInterventionTypeEnum = {
    Blessing: 'Blessing',
    Curse: 'Curse'
} as const;

export type GodInterventionTypeEnum = typeof GodInterventionTypeEnum[keyof typeof GodInterventionTypeEnum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const Id82bEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type Id82bEnum = typeof Id82bEnum[keyof typeof Id82bEnum];


/**
 * * `Physical Strength` - Physical Strength * `Mental Strength` - Mental Strength * `Flow Resonance` - Flow Resonance * `Concentration` - Concentration * `Flow Manipulation` - Flow Manipulation * `Flow Connection` - Flow Connection * `Knowledge` - Knowledge * `Speed` - Speed * `Luck` - Luck * `Charisma` - Charisma
 * @export
 * @enum {string}
 */

export const IdEa2Enum = {
    PhysicalStrength: 'Physical Strength',
    MentalStrength: 'Mental Strength',
    FlowResonance: 'Flow Resonance',
    Concentration: 'Concentration',
    FlowManipulation: 'Flow Manipulation',
    FlowConnection: 'Flow Connection',
    Knowledge: 'Knowledge',
    Speed: 'Speed',
    Luck: 'Luck',
    Charisma: 'Charisma'
} as const;

export type IdEa2Enum = typeof IdEa2Enum[keyof typeof IdEa2Enum];


/**
 * Serializer for Impact DTO.
 * @export
 * @interface Impact
 */
export interface Impact {
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof Impact
     */
    'kind': ImpactTypeEnum;
    /**
     * 
     * @type {Type82bEnum}
     * @memberof Impact
     */
    'type': Type82bEnum;
    /**
     * 
     * @type {Formula}
     * @memberof Impact
     */
    'formula': Formula;
}


/**
 * Serializer for skill impacts.
 * @export
 * @interface ImpactRequest
 */
export interface ImpactRequest {
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof ImpactRequest
     */
    'kind': ImpactTypeEnum;
    /**
     * 
     * @type {Type82bEnum}
     * @memberof ImpactRequest
     */
    'type': Type82bEnum;
    /**
     * 
     * @type {FormulaRequest}
     * @memberof ImpactRequest
     */
    'formula': FormulaRequest;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactType = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactType = typeof ImpactType[keyof typeof ImpactType];


/**
 * * `None` - None * `Knock out` - Knock out * `Damage` - Damage * `Heal` - Heal * `Shield` - Shield * `Buff` - Buff * `Debuff` - Debuff * `Stun` - Stun * `Sleep` - Sleep * `Confusion` - Confusion * `Paralysis` - Paralysis * `Fear` - Fear * `Freeze` - Freeze * `Burn` - Burn * `Poison` - Poison * `Slow` - Slow * `Haste` - Haste * `Blind` - Blind * `Silence` - Silence * `Bleed` - Bleed * `Disarm` - Disarm * `Root` - Root * `Energy Decrease` - Energy Decrease * `Reflect` - Reflect * `Absorb` - Absorb * `Dodge` - Dodge * `Resist` - Resist * `Immunity` - Immunity * `Regeneration` - Regeneration * `Lifesteal` - Lifesteal
 * @export
 * @enum {string}
 */

export const ImpactTypeEnum = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactTypeEnum = typeof ImpactTypeEnum[keyof typeof ImpactTypeEnum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const ImpactViolationEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationEnum = typeof ImpactViolationEnum[keyof typeof ImpactViolationEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactViolationType = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationType = typeof ImpactViolationType[keyof typeof ImpactViolationType];


/**
 * Serializer for the impersonation request.
 * @export
 * @interface ImpersonationRequestRequest
 */
export interface ImpersonationRequestRequest {
    /**
     * UUID of the character to impersonate
     * @type {string}
     * @memberof ImpersonationRequestRequest
     */
    'character_id': string;
}
/**
 * Serializer for the impersonation response.
 * @export
 * @interface ImpersonationResponse
 */
export interface ImpersonationResponse {
    /**
     * JWT refresh token for the impersonated user
     * @type {string}
     * @memberof ImpersonationResponse
     */
    'refresh': string;
    /**
     * JWT access token for the impersonated user
     * @type {string}
     * @memberof ImpersonationResponse
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'icon'?: string | null;
    /**
     * 
     * @type {Type496Enum}
     * @memberof Item
     */
    'type'?: Type496Enum;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'base_price'?: number;
    /**
     * 
     * @type {Nested}
     * @memberof Item
     */
    'skill': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof Item
     */
    'effect': Nested;
}


/**
 * 
 * @export
 * @interface ItemRequest
 */
export interface ItemRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof ItemRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Type496Enum}
     * @memberof ItemRequest
     */
    'type'?: Type496Enum;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'base_price'?: number;
}


/**
 * Serializer for ItemReward model.
 * @export
 * @interface ItemReward
 */
export interface ItemReward {
    /**
     * 
     * @type {string}
     * @memberof ItemReward
     */
    'id': string;
    /**
     * Amount of items to reward
     * @type {number}
     * @memberof ItemReward
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemReward
     */
    'item': string;
    /**
     * 
     * @type {string}
     * @memberof ItemReward
     */
    'reward'?: string | null;
}
/**
 * Serializer for ItemReward model.
 * @export
 * @interface ItemRewardRequest
 */
export interface ItemRewardRequest {
    /**
     * Amount of items to reward
     * @type {number}
     * @memberof ItemRewardRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemRewardRequest
     */
    'item': string;
    /**
     * 
     * @type {string}
     * @memberof ItemRewardRequest
     */
    'reward'?: string | null;
}
/**
 * 
 * @export
 * @interface JoinedFightEvent
 */
export interface JoinedFightEvent {
    /**
     * 
     * @type {string}
     * @memberof JoinedFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof JoinedFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof JoinedFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof JoinedFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {JoinedFightEventData}
     * @memberof JoinedFightEvent
     */
    'data': JoinedFightEventData;
}


/**
 * 
 * @export
 * @interface JoinedFightEventData
 */
export interface JoinedFightEventData {
    /**
     * 
     * @type {string}
     * @memberof JoinedFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof JoinedFightEventData
     */
    'character_id': string;
}
/**
 * 
 * @export
 * @interface LearnedSchool
 */
export interface LearnedSchool {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'character': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSchoolRequest
 */
export interface LearnedSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchoolRequest
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSkill
 */
export interface LearnedSkill {
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'character': string;
    /**
     * 
     * @type {OpenaiSkill}
     * @memberof LearnedSkill
     */
    'skill': OpenaiSkill;
}
/**
 * 
 * @export
 * @interface LearnedSkillRequest
 */
export interface LearnedSkillRequest {
    /**
     * 
     * @type {OpenaiSkillRequest}
     * @memberof LearnedSkillRequest
     */
    'skill': OpenaiSkillRequest;
}
/**
 * 
 * @export
 * @interface LeftFightEvent
 */
export interface LeftFightEvent {
    /**
     * 
     * @type {string}
     * @memberof LeftFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LeftFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof LeftFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof LeftFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {LeftFightEventData}
     * @memberof LeftFightEvent
     */
    'data': LeftFightEventData;
}


/**
 * 
 * @export
 * @interface LeftFightEventData
 */
export interface LeftFightEventData {
    /**
     * 
     * @type {string}
     * @memberof LeftFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof LeftFightEventData
     */
    'character_id': string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Location
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MapPosition
 */
export interface MapPosition {
    /**
     * 
     * @type {GenericPosition}
     * @memberof MapPosition
     */
    'position': GenericPosition;
    /**
     * 
     * @type {boolean}
     * @memberof MapPosition
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof MapPosition
     */
    'labels'?: any | null;
}
/**
 * 
 * @export
 * @interface MapPositionMutableRequest
 */
export interface MapPositionMutableRequest {
    /**
     * 
     * @type {string}
     * @memberof MapPositionMutableRequest
     */
    'position_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MapPositionMutableRequest
     */
    'labels'?: Array<string>;
}
/**
 * Response serializer for the map endpoint.
 * @export
 * @interface MapResponse
 */
export interface MapResponse {
    /**
     * 
     * @type {Array<Position>}
     * @memberof MapResponse
     */
    'positions': Array<Position>;
    /**
     * 
     * @type {Array<PositionConnection>}
     * @memberof MapResponse
     */
    'connections': Array<PositionConnection>;
}
/**
 * 
 * @export
 * @interface MiniMap
 */
export interface MiniMap {
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'organization': string;
    /**
     * 
     * @type {boolean}
     * @memberof MiniMap
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'positions': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'characters': string;
    /**
     * The position of the current user\'s character on the map.
     * @type {string}
     * @memberof MiniMap
     */
    'current_position': string;
}
/**
 * 
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'organization': string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelMap
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'positions': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'characters': string;
    /**
     * The position of the current user\'s character on the map.
     * @type {string}
     * @memberof ModelMap
     */
    'current_position': string;
}
/**
 * 
 * @export
 * @interface Modificator
 */
export interface Modificator {
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'stat_changes': string;
}
/**
 * 
 * @export
 * @interface ModificatorRequest
 */
export interface ModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof ModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof ModificatorRequest
     */
    'stat_modificators': Array<StatModificatorRequest>;
}
/**
 * Serializer for effect modifiers.
 * @export
 * @interface ModifierRequest
 */
export interface ModifierRequest {
    /**
     * 
     * @type {string}
     * @memberof ModifierRequest
     */
    'label': string;
    /**
     * 
     * @type {FormulaRequest}
     * @memberof ModifierRequest
     */
    'formula': FormulaRequest;
}
/**
 * Serializer for NPCSpawner model for Game Master API.  This serializer provides complete functionality for creating and managing NPC spawners with position, campaign, character template, and spawn settings.
 * @export
 * @interface NPCGenericSpawner
 */
export interface NPCGenericSpawner {
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawner
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof NPCGenericSpawner
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawner
     */
    'spawn_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawner
     */
    'respawn_cycles'?: number;
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawner
     */
    'character_template': string;
    /**
     * Cycle number when the next spawn should occur
     * @type {number}
     * @memberof NPCGenericSpawner
     */
    'next_spawn_cycle_number': number;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawner
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawner
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawner
     */
    'campaign': string;
    /**
     * 
     * @type {Array<SpawnedEntity>}
     * @memberof NPCGenericSpawner
     */
    'spawned_entities': Array<SpawnedEntity>;
}
/**
 * Serializer for NPCSpawner model for Game Master API.  This serializer provides complete functionality for creating and managing NPC spawners with position, campaign, character template, and spawn settings.
 * @export
 * @interface NPCGenericSpawnerRequest
 */
export interface NPCGenericSpawnerRequest {
    /**
     * 
     * @type {boolean}
     * @memberof NPCGenericSpawnerRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawnerRequest
     */
    'spawn_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawnerRequest
     */
    'respawn_cycles'?: number;
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawnerRequest
     */
    'character_template': string;
    /**
     * 
     * @type {number}
     * @memberof NPCGenericSpawnerRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NPCGenericSpawnerRequest
     */
    'position'?: string | null;
}
/**
 * 
 * @export
 * @interface NPCSpawnerCreate
 */
export interface NPCSpawnerCreate {
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreate
     */
    'spawn_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreate
     */
    'respawn_cycles'?: number;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreate
     */
    'character_template': string;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreate
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreate
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreate
     */
    'campaign': string;
    /**
     * 
     * @type {boolean}
     * @memberof NPCSpawnerCreate
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreate
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NPCSpawnerCreateRequest
 */
export interface NPCSpawnerCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreateRequest
     */
    'spawn_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreateRequest
     */
    'respawn_cycles'?: number;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreateRequest
     */
    'character_template': string;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerCreateRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerCreateRequest
     */
    'position'?: string | null;
}
/**
 * 
 * @export
 * @interface NPCSpawnerList
 */
export interface NPCSpawnerList {
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerList
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof NPCSpawnerList
     */
    'is_active': boolean;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerList
     */
    'spawn_limit': number;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerList
     */
    'respawn_cycles': number;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerList
     */
    'character_template': string;
    /**
     * Cycle number when the next spawn should occur
     * @type {number}
     * @memberof NPCSpawnerList
     */
    'next_spawn_cycle_number': number;
    /**
     * 
     * @type {number}
     * @memberof NPCSpawnerList
     */
    'dimension': number | null;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerList
     */
    'position': string | null;
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerList
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface NPCSpawnerMinimalPreview
 */
export interface NPCSpawnerMinimalPreview {
    /**
     * 
     * @type {string}
     * @memberof NPCSpawnerMinimalPreview
     */
    'character_template': string;
}
/**
 * * `Path of John` - Path of John * `Path of JSon` - Path of JSon * `Not Chosen` - Not Chosen
 * @export
 * @enum {string}
 */

export const Name535Enum = {
    PathOfJohn: 'Path of John',
    PathOfJSon: 'Path of JSon',
    NotChosen: 'Not Chosen'
} as const;

export type Name535Enum = typeof Name535Enum[keyof typeof Name535Enum];


/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof Nested
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'npc'?: boolean;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof Nested
     */
    'behavior'?: BehaviorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'polymorphic_ctype': number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'campaign': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'template'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'last_safe_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'challenge'?: string | null;
}


/**
 * 
 * @export
 * @interface NestedRequest
 */
export interface NestedRequest {
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof NestedRequest
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'npc'?: boolean;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof NestedRequest
     */
    'behavior'?: BehaviorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'campaign': string;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'template'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'last_safe_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'challenge'?: string | null;
}


/**
 * 
 * @export
 * @interface NewCoordinatesRequest
 */
export interface NewCoordinatesRequest {
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_z': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewCoordinatesRequest
     */
    'labels'?: Array<string>;
}
/**
 * Serializer for Note model.
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'quest': string;
    /**
     * Optional URL to an image representing the note
     * @type {string}
     * @memberof Note
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'content': string;
    /**
     * Order of the note within the quest
     * @type {number}
     * @memberof Note
     */
    'order'?: number;
}
/**
 * Serializer for Note model.
 * @export
 * @interface NoteRequest
 */
export interface NoteRequest {
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'quest': string;
    /**
     * Optional URL to an image representing the note
     * @type {File}
     * @memberof NoteRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof NoteRequest
     */
    'content': string;
    /**
     * Order of the note within the quest
     * @type {number}
     * @memberof NoteRequest
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface OfferedItem
 */
export interface OfferedItem {
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'item': string;
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'bargain': string;
}
/**
 * 
 * @export
 * @interface OfferedItemRequest
 */
export interface OfferedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof OfferedItemRequest
     */
    'item': string;
}
/**
 * @type OneOf
 * @export
 */
export type OneOf = { object_type_model: 'AbstractSpawner' } & AbstractSpawner | { object_type_model: 'NPCSpawnerMinimalPreview' } & NPCSpawnerMinimalPreview;

/**
 * 
 * @export
 * @interface OpenAICampaign
 */
export interface OpenAICampaign {
    /**
     * 
     * @type {string}
     * @memberof OpenAICampaign
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAICampaign
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAICampaign
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAICampaign
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAICampaign
     */
    'is_completed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAICampaign
     */
    'background_image'?: string | null;
}
/**
 * 
 * @export
 * @interface OpenAIClientManagement
 */
export interface OpenAIClientManagement {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'updated_at': string;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OpenAIClientManagement
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_staff': boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'current_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'user_permissions'?: Array<number>;
}


/**
 * 
 * @export
 * @interface OpenAIClientManagementRequest
 */
export interface OpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'current_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface OpenaiCharacter
 */
export interface OpenaiCharacter {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'name': string;
    /**
     * 
     * @type {OpenaiCharacterBio}
     * @memberof OpenaiCharacter
     */
    'biography': OpenaiCharacterBio;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'npc'?: boolean;
    /**
     * 
     * @type {Rank}
     * @memberof OpenaiCharacter
     */
    'rank': Rank;
    /**
     * 
     * @type {ThePath}
     * @memberof OpenaiCharacter
     */
    'path': ThePath;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacter
     */
    'experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof OpenaiCharacter
     */
    'tags'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Campaign}
     * @memberof OpenaiCharacter
     */
    'campaign': Campaign;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'challenge'?: string | null;
    /**
     * 
     * @type {Organization}
     * @memberof OpenaiCharacter
     */
    'organization': Organization | null;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'position_id': string | null;
}
/**
 * 
 * @export
 * @interface OpenaiCharacterBio
 */
export interface OpenaiCharacterBio {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterBio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacterBio
     */
    'gender'?: GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'background'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'appearance'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface OpenaiCharacterBioRequest
 */
export interface OpenaiCharacterBioRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBioRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterBioRequest
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacterBioRequest
     */
    'gender'?: GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBioRequest
     */
    'background'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBioRequest
     */
    'appearance'?: string;
    /**
     * 
     * @type {File}
     * @memberof OpenaiCharacterBioRequest
     */
    'avatar'?: File;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBioRequest
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface OpenaiCharacterRequest
 */
export interface OpenaiCharacterRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterRequest
     */
    'name': string;
    /**
     * 
     * @type {OpenaiCharacterBioRequest}
     * @memberof OpenaiCharacterRequest
     */
    'biography': OpenaiCharacterBioRequest;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacterRequest
     */
    'npc'?: boolean;
    /**
     * 
     * @type {RankRequest}
     * @memberof OpenaiCharacterRequest
     */
    'rank': RankRequest;
    /**
     * 
     * @type {ThePathRequest}
     * @memberof OpenaiCharacterRequest
     */
    'path': ThePathRequest;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterRequest
     */
    'experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof OpenaiCharacterRequest
     */
    'tags'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacterRequest
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacterRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {CampaignRequest}
     * @memberof OpenaiCharacterRequest
     */
    'campaign': CampaignRequest;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterRequest
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterRequest
     */
    'challenge'?: string | null;
    /**
     * 
     * @type {OrganizationRequest}
     * @memberof OpenaiCharacterRequest
     */
    'organization': OrganizationRequest | null;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterRequest
     */
    'position_id': string | null;
}
/**
 * 
 * @export
 * @interface OpenaiPath
 */
export interface OpenaiPath {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'updated_at': string;
    /**
     * 
     * @type {Name535Enum}
     * @memberof OpenaiPath
     */
    'name'?: Name535Enum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'icon'?: string | null;
}


/**
 * 
 * @export
 * @interface OpenaiPathWithSchools
 */
export interface OpenaiPathWithSchools {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'id': string;
    /**
     * 
     * @type {Array<OpenaiSchool>}
     * @memberof OpenaiPathWithSchools
     */
    'schools': Array<OpenaiSchool>;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'updated_at': string;
    /**
     * 
     * @type {Name535Enum}
     * @memberof OpenaiPathWithSchools
     */
    'name'?: Name535Enum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'icon'?: string | null;
}


/**
 * 
 * @export
 * @interface OpenaiSchool
 */
export interface OpenaiSchool {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSchool
     */
    'is_base'?: boolean;
    /**
     * If true, only game masters can create skills in this school
     * @type {boolean}
     * @memberof OpenaiSchool
     */
    'game_master_only'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof OpenaiSchool
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OpenaiSkill
 */
export interface OpenaiSkill {
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof OpenaiSkill
     */
    'type'?: TypeC27Enum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof OpenaiSkill
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'icon'?: string | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'immediate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'school': string | null;
}


/**
 * 
 * @export
 * @interface OpenaiSkillRequest
 */
export interface OpenaiSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof OpenaiSkillRequest
     */
    'type'?: TypeC27Enum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof OpenaiSkillRequest
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {File}
     * @memberof OpenaiSkillRequest
     */
    'icon'?: File | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name': string;
}
/**
 * * `Critical Fail` - Critical Fail * `Critical Success` - Critical Success * `Bad Luck` - Bad Luck * `Base Value` - Base Value * `Good Luck` - Good Luck
 * @export
 * @enum {string}
 */

export const OutcomeEnum = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type OutcomeEnum = typeof OutcomeEnum[keyof typeof OutcomeEnum];


/**
 * 
 * @export
 * @interface PaginatedCharacterActionLogList
 */
export interface PaginatedCharacterActionLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCharacterActionLogList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CharacterActionLog>}
     * @memberof PaginatedCharacterActionLogList
     */
    'results': Array<CharacterActionLog>;
}
/**
 * 
 * @export
 * @interface PaginatedCharacterTemplateGameMasterList
 */
export interface PaginatedCharacterTemplateGameMasterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCharacterTemplateGameMasterList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterTemplateGameMasterList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterTemplateGameMasterList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CharacterTemplateGameMaster>}
     * @memberof PaginatedCharacterTemplateGameMasterList
     */
    'results': Array<CharacterTemplateGameMaster>;
}
/**
 * 
 * @export
 * @interface PaginatedDocumentList
 */
export interface PaginatedDocumentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDocumentList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDocumentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDocumentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Document>}
     * @memberof PaginatedDocumentList
     */
    'results': Array<Document>;
}
/**
 * 
 * @export
 * @interface PaginatedGameMasterCharacterActionLogList
 */
export interface PaginatedGameMasterCharacterActionLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GameMasterCharacterActionLog>}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'results': Array<GameMasterCharacterActionLog>;
}
/**
 * 
 * @export
 * @interface PaginatedLearnedSkillList
 */
export interface PaginatedLearnedSkillList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLearnedSkillList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LearnedSkill>}
     * @memberof PaginatedLearnedSkillList
     */
    'results': Array<LearnedSkill>;
}
/**
 * 
 * @export
 * @interface PaginatedTimeLineEventList
 */
export interface PaginatedTimeLineEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTimeLineEventList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTimeLineEventList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTimeLineEventList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TimeLineEvent>}
     * @memberof PaginatedTimeLineEventList
     */
    'results': Array<TimeLineEvent>;
}
/**
 * Serializer for Chapter model.
 * @export
 * @interface PatchedChapterRequest
 */
export interface PatchedChapterRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedChapterRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedChapterRequest
     */
    'description'?: string;
    /**
     * Optional URL to an image representing the chapter
     * @type {File}
     * @memberof PatchedChapterRequest
     */
    'image'?: File | null;
    /**
     * Order of the chapter within the story
     * @type {number}
     * @memberof PatchedChapterRequest
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedChapterRequest
     */
    'story'?: string;
}
/**
 * Serializer for Condition model.
 * @export
 * @interface PatchedConditionRequest
 */
export interface PatchedConditionRequest {
    /**
     * 
     * @type {ConditionTypeEnum}
     * @memberof PatchedConditionRequest
     */
    'type'?: ConditionTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedConditionRequest
     */
    'trigger_ids'?: Array<string>;
}


/**
 * 
 * @export
 * @interface PatchedCurrencyTokenRequest
 */
export interface PatchedCurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedCurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * Serializer for Document objects
 * @export
 * @interface PatchedDocumentRequest
 */
export interface PatchedDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedDocumentRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDocumentRequest
     */
    'content'?: string;
    /**
     * 
     * @type {Array<CategoriesEnum>}
     * @memberof PatchedDocumentRequest
     */
    'categories'?: Array<CategoriesEnum>;
    /**
     * 
     * @type {File}
     * @memberof PatchedDocumentRequest
     */
    'image'?: File | null;
}
/**
 * Serializer for EffectReward model.
 * @export
 * @interface PatchedEffectRewardRequest
 */
export interface PatchedEffectRewardRequest {
    /**
     * 
     * @type {EffectEnum}
     * @memberof PatchedEffectRewardRequest
     */
    'effect'?: EffectEnum;
    /**
     * Duration of the effect in turns
     * @type {number}
     * @memberof PatchedEffectRewardRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedEffectRewardRequest
     */
    'reward'?: string | null;
}


/**
 * 
 * @export
 * @interface PatchedGameMasterCharacterActionLogRequest
 */
export interface PatchedGameMasterCharacterActionLogRequest {
    /**
     * 
     * @type {ActionType5f8Enum}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'action_type'?: ActionType5f8Enum;
    /**
     * 
     * @type {any}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface PatchedGameObjectRequest
 */
export interface PatchedGameObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedGameObjectRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedGameObjectRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameObjectRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedGameObjectRequest
     */
    'campaign'?: string;
}
/**
 * Serializer for ItemReward model.
 * @export
 * @interface PatchedItemRewardRequest
 */
export interface PatchedItemRewardRequest {
    /**
     * Amount of items to reward
     * @type {number}
     * @memberof PatchedItemRewardRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRewardRequest
     */
    'item'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRewardRequest
     */
    'reward'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedModificatorRequest
 */
export interface PatchedModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof PatchedModificatorRequest
     */
    'stat_modificators'?: Array<StatModificatorRequest>;
}
/**
 * Serializer for changing NPC behavior.
 * @export
 * @interface PatchedNPCBehaviorRequest
 */
export interface PatchedNPCBehaviorRequest {
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof PatchedNPCBehaviorRequest
     */
    'behavior'?: BehaviorEnum;
}


/**
 * Serializer for NPCSpawner model for Game Master API.  This serializer provides complete functionality for creating and managing NPC spawners with position, campaign, character template, and spawn settings.
 * @export
 * @interface PatchedNPCGenericSpawnerRequest
 */
export interface PatchedNPCGenericSpawnerRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'spawn_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'respawn_cycles'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'character_template'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedNPCGenericSpawnerRequest
     */
    'position'?: string | null;
}
/**
 * Serializer for Note model.
 * @export
 * @interface PatchedNoteRequest
 */
export interface PatchedNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedNoteRequest
     */
    'quest'?: string;
    /**
     * Optional URL to an image representing the note
     * @type {File}
     * @memberof PatchedNoteRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedNoteRequest
     */
    'content'?: string;
    /**
     * Order of the note within the quest
     * @type {number}
     * @memberof PatchedNoteRequest
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOpenAIClientManagementRequest
 */
export interface PatchedOpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'current_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * Serializer for PositionConnection model.
 * @export
 * @interface PatchedPositionConnectionRequest
 */
export interface PatchedPositionConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionConnectionRequest
     */
    'position_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionConnectionRequest
     */
    'position_to'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPositionConnectionRequest
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPositionConnectionRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPositionConnectionRequest
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof PatchedPositionConnectionRequest
     */
    'config'?: any | null;
}
/**
 * Serializer for Position model.
 * @export
 * @interface PatchedPositionRequest
 */
export interface PatchedPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionRequest
     */
    'sub_location'?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchedPositionRequest
     */
    'labels'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPositionRequest
     */
    'is_safe'?: boolean;
    /**
     * 
     * @type {File}
     * @memberof PatchedPositionRequest
     */
    'image'?: File | null;
}
/**
 * Serializer for Quest model.
 * @export
 * @interface PatchedQuestRequest
 */
export interface PatchedQuestRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedQuestRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedQuestRequest
     */
    'description'?: string;
    /**
     * Optional URL to an image representing the quest
     * @type {File}
     * @memberof PatchedQuestRequest
     */
    'image'?: File | null;
    /**
     * Time limit in cycles (1 cycle = 1 turn)
     * @type {number}
     * @memberof PatchedQuestRequest
     */
    'cycle_limit'?: number | null;
    /**
     * Order of the quest within the chapter
     * @type {number}
     * @memberof PatchedQuestRequest
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedQuestRequest
     */
    'chapter'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedQuestRequest
     */
    'starter_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedQuestRequest
     */
    'objective_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PatchedQuestRequest
     */
    'success_reward_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedQuestRequest
     */
    'failure_reward_id'?: string | null;
}
/**
 * Serializer for Reward model.
 * @export
 * @interface PatchedRewardRequest
 */
export interface PatchedRewardRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedRewardRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedRewardRequest
     */
    'experience'?: number;
}
/**
 * Serializer for Story model.
 * @export
 * @interface PatchedStoryRequest
 */
export interface PatchedStoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStoryRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStoryRequest
     */
    'description'?: string;
    /**
     * List of tags for the story
     * @type {any}
     * @memberof PatchedStoryRequest
     */
    'tags'?: any;
    /**
     * Optional URL to an image representing the story
     * @type {File}
     * @memberof PatchedStoryRequest
     */
    'image'?: File | null;
    /**
     * Default to false, need review by the Owner
     * @type {boolean}
     * @memberof PatchedStoryRequest
     */
    'canonical'?: boolean;
}
/**
 * Serializer for SubLocation model.
 * @export
 * @interface PatchedSubLocationRequest
 */
export interface PatchedSubLocationRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSubLocationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubLocationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSubLocationRequest
     */
    'location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSubLocationRequest
     */
    'is_active'?: boolean;
}
/**
 * Serializer for TokenReward model.
 * @export
 * @interface PatchedTokenRewardRequest
 */
export interface PatchedTokenRewardRequest {
    /**
     * Amount of tokens to reward
     * @type {number}
     * @memberof PatchedTokenRewardRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedTokenRewardRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTokenRewardRequest
     */
    'reward'?: string | null;
}
/**
 * Serializer for Trigger model.
 * @export
 * @interface PatchedTriggerRequest
 */
export interface PatchedTriggerRequest {
    /**
     * 
     * @type {TriggerTypeEnum}
     * @memberof PatchedTriggerRequest
     */
    'type'?: TriggerTypeEnum;
    /**
     * Description of the trigger
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'description'?: string;
    /**
     * Concreate - Item, Character, Anomaly
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'game_object'?: string | null;
    /**
     * Position in the game world
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'position'?: string | null;
    /**
     * Optional limit trigger to a specific location
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'location'?: string | null;
    /**
     * All NPCs that been created from this template will have this trigger
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'npc'?: string | null;
    /**
     * Optional skill that is required to trigger the action
     * @type {number}
     * @memberof PatchedTriggerRequest
     */
    'skill'?: number | null;
    /**
     * Optional item that is required to trigger the action
     * @type {string}
     * @memberof PatchedTriggerRequest
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface PatchedWorldItemRequest
 */
export interface PatchedWorldItemRequest {
    /**
     * 
     * @type {ItemRequest}
     * @memberof PatchedWorldItemRequest
     */
    'item'?: ItemRequest;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedWorldItemRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedWorldItemRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedWorldItemRequest
     */
    'campaign'?: string;
}
/**
 * 
 * @export
 * @interface PendingJoinFightEvent
 */
export interface PendingJoinFightEvent {
    /**
     * 
     * @type {string}
     * @memberof PendingJoinFightEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PendingJoinFightEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof PendingJoinFightEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof PendingJoinFightEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {PendingJoinFightEventData}
     * @memberof PendingJoinFightEvent
     */
    'data': PendingJoinFightEventData;
}


/**
 * 
 * @export
 * @interface PendingJoinFightEventData
 */
export interface PendingJoinFightEventData {
    /**
     * 
     * @type {string}
     * @memberof PendingJoinFightEventData
     */
    'fight_id': string;
    /**
     * 
     * @type {string}
     * @memberof PendingJoinFightEventData
     */
    'character_id': string;
}
/**
 * Serializer for Position model.
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'sub_location': string;
    /**
     * 
     * @type {SubLocation}
     * @memberof Position
     */
    'sub_location_details': SubLocation;
    /**
     * 
     * @type {any}
     * @memberof Position
     */
    'labels'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof Position
     */
    'is_safe'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'coordinates': string;
}
/**
 * Serializer for PositionConnection model.
 * @export
 * @interface PositionConnection
 */
export interface PositionConnection {
    /**
     * 
     * @type {number}
     * @memberof PositionConnection
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PositionConnection
     */
    'position_from': string;
    /**
     * 
     * @type {string}
     * @memberof PositionConnection
     */
    'position_to': string;
    /**
     * 
     * @type {Position}
     * @memberof PositionConnection
     */
    'position_from_details': Position;
    /**
     * 
     * @type {Position}
     * @memberof PositionConnection
     */
    'position_to_details': Position;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnection
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnection
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnection
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PositionConnection
     */
    'is_vertical': string;
    /**
     * 
     * @type {string}
     * @memberof PositionConnection
     */
    'is_horizontal': string;
    /**
     * 
     * @type {any}
     * @memberof PositionConnection
     */
    'config'?: any | null;
}
/**
 * Serializer for creating a connection between two positions.
 * @export
 * @interface PositionConnectionCreateRequest
 */
export interface PositionConnectionCreateRequest {
    /**
     * Source position UUID - identifies the starting point of the connection
     * @type {string}
     * @memberof PositionConnectionCreateRequest
     */
    'position_from': string;
    /**
     * Target position UUID - identifies the ending point of the connection
     * @type {string}
     * @memberof PositionConnectionCreateRequest
     */
    'position_to': string;
    /**
     * Controls whether players can traverse this connection
     * @type {boolean}
     * @memberof PositionConnectionCreateRequest
     */
    'locked'?: boolean;
    /**
     * Determines if the connection is currently usable in the game
     * @type {boolean}
     * @memberof PositionConnectionCreateRequest
     */
    'is_active'?: boolean;
    /**
     * Indicates if the connection is visible to all players
     * @type {boolean}
     * @memberof PositionConnectionCreateRequest
     */
    'is_public'?: boolean;
}
/**
 * Serializer for PositionConnection model.
 * @export
 * @interface PositionConnectionRequest
 */
export interface PositionConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof PositionConnectionRequest
     */
    'position_from': string;
    /**
     * 
     * @type {string}
     * @memberof PositionConnectionRequest
     */
    'position_to': string;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnectionRequest
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnectionRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionConnectionRequest
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof PositionConnectionRequest
     */
    'config'?: any | null;
}
/**
 * Serializer for PositionConnectionRequirement objects.
 * @export
 * @interface PositionConnectionRequirementRequest
 */
export interface PositionConnectionRequirementRequest {
    /**
     * 
     * @type {string}
     * @memberof PositionConnectionRequirementRequest
     */
    'item_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionConnectionRequirementRequest
     */
    'skill_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PositionConnectionRequirementRequest
     */
    'character_id'?: string | null;
}
/**
 * Serializer for moving a position to new coordinates.
 * @export
 * @interface PositionMoveRequest
 */
export interface PositionMoveRequest {
    /**
     * New X coordinate
     * @type {number}
     * @memberof PositionMoveRequest
     */
    'grid_x': number;
    /**
     * New Y coordinate
     * @type {number}
     * @memberof PositionMoveRequest
     */
    'grid_y': number;
    /**
     * New Z coordinate
     * @type {number}
     * @memberof PositionMoveRequest
     */
    'grid_z': number;
}
/**
 * Serializer for PositionConnectionConfig objects.
 * @export
 * @interface PositionRelationConfigurationRequest
 */
export interface PositionRelationConfigurationRequest {
    /**
     * 
     * @type {Array<PositionConnectionRequirementRequest>}
     * @memberof PositionRelationConfigurationRequest
     */
    'requirements'?: Array<PositionConnectionRequirementRequest>;
}
/**
 * Serializer for Position model.
 * @export
 * @interface PositionRequest
 */
export interface PositionRequest {
    /**
     * 
     * @type {string}
     * @memberof PositionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionRequest
     */
    'sub_location': string;
    /**
     * 
     * @type {any}
     * @memberof PositionRequest
     */
    'labels'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PositionRequest
     */
    'is_safe'?: boolean;
    /**
     * 
     * @type {File}
     * @memberof PositionRequest
     */
    'image'?: File | null;
}
/**
 * * `openai` - OpenAI * `google` - Google * `local` - Local
 * @export
 * @enum {string}
 */

export const ProviderEnum = {
    Openai: 'openai',
    Google: 'google',
    Local: 'local'
} as const;

export type ProviderEnum = typeof ProviderEnum[keyof typeof ProviderEnum];


/**
 * Serializer for Quest model.
 * @export
 * @interface Quest
 */
export interface Quest {
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'description': string;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Quest
     */
    'starters': Array<Condition>;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Quest
     */
    'objectives': Array<Condition>;
    /**
     * 
     * @type {Reward}
     * @memberof Quest
     */
    'on_success': Reward;
    /**
     * 
     * @type {Reward}
     * @memberof Quest
     */
    'on_failure': Reward;
    /**
     * Optional URL to an image representing the quest
     * @type {string}
     * @memberof Quest
     */
    'image'?: string | null;
    /**
     * Time limit in cycles (1 cycle = 1 turn)
     * @type {number}
     * @memberof Quest
     */
    'cycle_limit'?: number | null;
    /**
     * Order of the quest within the chapter
     * @type {number}
     * @memberof Quest
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'chapter': string;
    /**
     * 
     * @type {Array<Note>}
     * @memberof Quest
     */
    'notes': Array<Note>;
}
/**
 * Serializer for Quest model.
 * @export
 * @interface QuestRequest
 */
export interface QuestRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestRequest
     */
    'description': string;
    /**
     * Optional URL to an image representing the quest
     * @type {File}
     * @memberof QuestRequest
     */
    'image'?: File | null;
    /**
     * Time limit in cycles (1 cycle = 1 turn)
     * @type {number}
     * @memberof QuestRequest
     */
    'cycle_limit'?: number | null;
    /**
     * Order of the quest within the chapter
     * @type {number}
     * @memberof QuestRequest
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestRequest
     */
    'chapter': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestRequest
     */
    'starter_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestRequest
     */
    'objective_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestRequest
     */
    'success_reward_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestRequest
     */
    'failure_reward_id'?: string | null;
}
/**
 * 
 * @export
 * @interface Rank
 */
export interface Rank {
    /**
     * 
     * @type {string}
     * @memberof Rank
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    'grade'?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    'experience_needed'?: number;
}
/**
 * 
 * @export
 * @interface RankRequest
 */
export interface RankRequest {
    /**
     * 
     * @type {string}
     * @memberof RankRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RankRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {number}
     * @memberof RankRequest
     */
    'experience_needed'?: number;
}
/**
 * 
 * @export
 * @interface RegisterImpactAction
 */
export interface RegisterImpactAction {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactAction
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactAction
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegisterImpactActionRequest
 */
export interface RegisterImpactActionRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegistrationForm
 */
export interface RegistrationForm {
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationFormRequest
 */
export interface RegistrationFormRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'password': string;
}
/**
 * Serializer for Reward model.
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    'experience'?: number;
    /**
     * 
     * @type {Array<TokenReward>}
     * @memberof Reward
     */
    'tokens': Array<TokenReward>;
    /**
     * 
     * @type {Array<ItemReward>}
     * @memberof Reward
     */
    'items': Array<ItemReward>;
    /**
     * 
     * @type {Array<EffectReward>}
     * @memberof Reward
     */
    'effects': Array<EffectReward>;
}
/**
 * Serializer for Reward model.
 * @export
 * @interface RewardRequest
 */
export interface RewardRequest {
    /**
     * 
     * @type {string}
     * @memberof RewardRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RewardRequest
     */
    'experience'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RollOutcome = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type RollOutcome = typeof RollOutcome[keyof typeof RollOutcome];


/**
 * Serializer for Scaling DTO.
 * @export
 * @interface Scaling
 */
export interface Scaling {
    /**
     * 
     * @type {string}
     * @memberof Scaling
     */
    'stat': string;
    /**
     * 
     * @type {number}
     * @memberof Scaling
     */
    'value': number;
}
/**
 * Serializer for scaling values in formulas.
 * @export
 * @interface ScalingRequest
 */
export interface ScalingRequest {
    /**
     * 
     * @type {string}
     * @memberof ScalingRequest
     */
    'stat': string;
    /**
     * 
     * @type {number}
     * @memberof ScalingRequest
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface Shield
 */
export interface Shield {
    /**
     * 
     * @type {Id82bEnum}
     * @memberof Shield
     */
    'id'?: Id82bEnum;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_health'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_efficiency'?: number;
}


/**
 * * `Small` - Small * `Medium` - Medium * `Large` - Large * `God` - God
 * @export
 * @enum {string}
 */

export const SizeEnum = {
    Small: 'Small',
    Medium: 'Medium',
    Large: 'Large',
    God: 'God'
} as const;

export type SizeEnum = typeof SizeEnum[keyof typeof SizeEnum];


/**
 * 
 * @export
 * @interface Skill
 */
export interface Skill {
    /**
     * 
     * @type {number}
     * @memberof Skill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Skill
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Skill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof Skill
     */
    'type'?: TypeC27Enum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof Skill
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof Skill
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof Skill
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof Skill
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'icon'?: string | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof Skill
     */
    'immediate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'school'?: string | null;
}


/**
 * Serializer for Cost DTO.
 * @export
 * @interface SkillCost
 */
export interface SkillCost {
    /**
     * 
     * @type {AttributesEnum}
     * @memberof SkillCost
     */
    'kind': AttributesEnum;
    /**
     * 
     * @type {number}
     * @memberof SkillCost
     */
    'value': number;
}


/**
 * Serializer for creating a new skill. This serializer validates the input data for creating a skill with all nested structures.
 * @export
 * @interface SkillCreateRequest
 */
export interface SkillCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof SkillCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SkillCreateRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SkillCreateRequest
     */
    'school'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkillCreateRequest
     */
    'multi_target'?: boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof SkillCreateRequest
     */
    'type': TypeC27Enum;
    /**
     * 
     * @type {number}
     * @memberof SkillCreateRequest
     */
    'grade': number;
    /**
     * 
     * @type {Array<CostRequest>}
     * @memberof SkillCreateRequest
     */
    'cost'?: Array<CostRequest>;
    /**
     * 
     * @type {Array<AssignableEffectRequest>}
     * @memberof SkillCreateRequest
     */
    'effect'?: Array<AssignableEffectRequest>;
    /**
     * 
     * @type {Array<ImpactRequest>}
     * @memberof SkillCreateRequest
     */
    'impact'?: Array<ImpactRequest>;
}


/**
 * 
 * @export
 * @interface SkillRequest
 */
export interface SkillRequest {
    /**
     * 
     * @type {string}
     * @memberof SkillRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkillRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof SkillRequest
     */
    'multi_target': boolean;
    /**
     * 
     * @type {TypeC27Enum}
     * @memberof SkillRequest
     */
    'type'?: TypeC27Enum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof SkillRequest
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof SkillRequest
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof SkillRequest
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof SkillRequest
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {File}
     * @memberof SkillRequest
     */
    'icon'?: File | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof SkillRequest
     */
    'immediate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkillRequest
     */
    'school'?: string | null;
}


/**
 * Serializer for spawning an item in the game world. Accepts either a character ID or a position ID, or both.
 * @export
 * @interface SpawnItemRequest
 */
export interface SpawnItemRequest {
    /**
     * UUID of the character to assign the item to. If provided, the item will be added to the character\'s inventory.
     * @type {string}
     * @memberof SpawnItemRequest
     */
    'to_character_id'?: string | null;
    /**
     * UUID of the position to place the item at. If provided without to_character_id, the item will be placed at this position.
     * @type {string}
     * @memberof SpawnItemRequest
     */
    'to_position_id'?: string | null;
}
/**
 * 
 * @export
 * @interface SpawnedEntity
 */
export interface SpawnedEntity {
    /**
     * 
     * @type {string}
     * @memberof SpawnedEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SpawnedEntity
     */
    'game_object': string;
}
/**
 * 
 * @export
 * @interface SpecialAction
 */
export interface SpecialAction {
    /**
     * 
     * @type {SpecialActionActionTypeEnum}
     * @memberof SpecialAction
     */
    'action_type': SpecialActionActionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'description': string;
    /**
     * If true, the action will be performed immediately
     * @type {boolean}
     * @memberof SpecialAction
     */
    'immediate'?: boolean;
    /**
     * If true, the action will spend all remaining action points
     * @type {boolean}
     * @memberof SpecialAction
     */
    'final'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'icon'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof SpecialAction
     */
    'cost'?: any;
}


/**
 * * `INSPECT` - INSPECT * `SNATCH_ITEM` - SNATCH_ITEM * `BARGAIN` - BARGAIN * `GIFT` - GIFT * `LONG_REST` - LONG_REST * `BACK_TO_SAFE_ZONE` - BACK_TO_SAFE_ZONE
 * @export
 * @enum {string}
 */

export const SpecialActionActionTypeEnum = {
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM',
    Bargain: 'BARGAIN',
    Gift: 'GIFT',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE'
} as const;

export type SpecialActionActionTypeEnum = typeof SpecialActionActionTypeEnum[keyof typeof SpecialActionActionTypeEnum];


/**
 * * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
 * @export
 * @enum {string}
 */

export const SpecialEnum = {
    Action: 'ACTION',
    Teleport: 'TELEPORT',
    TeleportToCharacter: 'TELEPORT_TO_CHARACTER',
    TeleportToSafeZone: 'TELEPORT_TO_SAFE_ZONE',
    ResetStats: 'RESET_STATS',
    FlowAccumulation: 'FLOW_ACCUMULATION'
} as const;

export type SpecialEnum = typeof SpecialEnum[keyof typeof SpecialEnum];


/**
 * 
 * @export
 * @interface Stat
 */
export interface Stat {
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface StatModificator
 */
export interface StatModificator {
    /**
     * 
     * @type {string}
     * @memberof StatModificator
     */
    'id': string;
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof StatModificator
     */
    'stat'?: IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof StatModificator
     */
    'value'?: number;
}


/**
 * 
 * @export
 * @interface StatModificatorRequest
 */
export interface StatModificatorRequest {
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof StatModificatorRequest
     */
    'stat'?: IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof StatModificatorRequest
     */
    'value'?: number;
}


/**
 * 
 * @export
 * @interface StatObject
 */
export interface StatObject {
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof StatObject
     */
    'id': IdEa2Enum;
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    'description'?: string | null;
}


/**
 * Serializer for StatRequirement DTO.
 * @export
 * @interface StatRequirement
 */
export interface StatRequirement {
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof StatRequirement
     */
    'stat': IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof StatRequirement
     */
    'value': number;
}


/**
 * Serializer for stat requirements in formulas.
 * @export
 * @interface StatRequirementRequest
 */
export interface StatRequirementRequest {
    /**
     * 
     * @type {IdEa2Enum}
     * @memberof StatRequirementRequest
     */
    'stat': IdEa2Enum;
    /**
     * 
     * @type {number}
     * @memberof StatRequirementRequest
     */
    'value': number;
}


/**
 * Serializer for Story model.
 * @export
 * @interface Story
 */
export interface Story {
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    'description': string;
    /**
     * List of tags for the story
     * @type {any}
     * @memberof Story
     */
    'tags'?: any;
    /**
     * Optional URL to an image representing the story
     * @type {string}
     * @memberof Story
     */
    'image'?: string | null;
    /**
     * Default to false, need review by the Owner
     * @type {boolean}
     * @memberof Story
     */
    'canonical'?: boolean;
    /**
     * 
     * @type {Array<Chapter>}
     * @memberof Story
     */
    'chapters': Array<Chapter>;
}
/**
 * Detailed serializer for Story model with nested chapters and quests.
 * @export
 * @interface StoryDetail
 */
export interface StoryDetail {
    /**
     * 
     * @type {string}
     * @memberof StoryDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoryDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof StoryDetail
     */
    'description': string;
    /**
     * List of tags for the story
     * @type {any}
     * @memberof StoryDetail
     */
    'tags'?: any;
    /**
     * Optional URL to an image representing the story
     * @type {string}
     * @memberof StoryDetail
     */
    'image'?: string | null;
    /**
     * Default to false, need review by the Owner
     * @type {boolean}
     * @memberof StoryDetail
     */
    'canonical'?: boolean;
    /**
     * 
     * @type {Array<Chapter>}
     * @memberof StoryDetail
     */
    'chapters': Array<Chapter>;
}
/**
 * Serializer for Story model.
 * @export
 * @interface StoryRequest
 */
export interface StoryRequest {
    /**
     * 
     * @type {string}
     * @memberof StoryRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof StoryRequest
     */
    'description': string;
    /**
     * List of tags for the story
     * @type {any}
     * @memberof StoryRequest
     */
    'tags'?: any;
    /**
     * Optional URL to an image representing the story
     * @type {File}
     * @memberof StoryRequest
     */
    'image'?: File | null;
    /**
     * Default to false, need review by the Owner
     * @type {boolean}
     * @memberof StoryRequest
     */
    'canonical'?: boolean;
}
/**
 * Serializer for SubLocation model.
 * @export
 * @interface SubLocation
 */
export interface SubLocation {
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'location': string;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocation
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'updated_at': string;
}
/**
 * Serializer for SubLocation model.
 * @export
 * @interface SubLocationRequest
 */
export interface SubLocationRequest {
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'location': string;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocationRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeRequest
     */
    'channel': string;
}
/**
 * 
 * @export
 * @interface SwipeBaseStatRequest
 */
export interface SwipeBaseStatRequest {
    /**
     * The first result of the base stat generation.
     * @type {string}
     * @memberof SwipeBaseStatRequest
     */
    'from_stat': string;
    /**
     * The second result of the base stat generation.
     * @type {string}
     * @memberof SwipeBaseStatRequest
     */
    'to_stat': string;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinates
 */
export interface TeleportCoordinates {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_z': number;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinatesRequest
 */
export interface TeleportCoordinatesRequest {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_z': number;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPosition
 */
export interface TeleportPosition {
    /**
     * 
     * @type {string}
     * @memberof TeleportPosition
     */
    'id': string;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPositionRequest
 */
export interface TeleportPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof TeleportPositionRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ThePath
 */
export interface ThePath {
    /**
     * 
     * @type {Name535Enum}
     * @memberof ThePath
     */
    'name'?: Name535Enum;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface ThePathRequest
 */
export interface ThePathRequest {
    /**
     * 
     * @type {Name535Enum}
     * @memberof ThePathRequest
     */
    'name'?: Name535Enum;
    /**
     * 
     * @type {string}
     * @memberof ThePathRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof ThePathRequest
     */
    'icon'?: File | null;
}


/**
 * Serializer for TimeLineEvent objects with nested representations
 * @export
 * @interface TimeLineEvent
 */
export interface TimeLineEvent {
    /**
     * 
     * @type {string}
     * @memberof TimeLineEvent
     */
    'id': string;
    /**
     * 
     * @type {Document}
     * @memberof TimeLineEvent
     */
    'document': Document;
    /**
     * 
     * @type {DateTimeInfo}
     * @memberof TimeLineEvent
     */
    'date_time': DateTimeInfo;
}
/**
 * Serializer for importing TimeLineEvent with nested Document and DateTimeInfo. This serializer handles get_or_create logic for Document and DateTimeInfo.
 * @export
 * @interface TimeLineEventImportRequest
 */
export interface TimeLineEventImportRequest {
    /**
     * 
     * @type {DocumentRequest}
     * @memberof TimeLineEventImportRequest
     */
    'document': DocumentRequest;
    /**
     * 
     * @type {DateTimeInfoRequest}
     * @memberof TimeLineEventImportRequest
     */
    'date_time': DateTimeInfoRequest;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPairRequest
 */
export interface TokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * Serializer for TokenReward model.
 * @export
 * @interface TokenReward
 */
export interface TokenReward {
    /**
     * 
     * @type {string}
     * @memberof TokenReward
     */
    'id': string;
    /**
     * Amount of tokens to reward
     * @type {number}
     * @memberof TokenReward
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenReward
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenReward
     */
    'reward'?: string | null;
}
/**
 * Serializer for TokenReward model.
 * @export
 * @interface TokenRewardRequest
 */
export interface TokenRewardRequest {
    /**
     * Amount of tokens to reward
     * @type {number}
     * @memberof TokenRewardRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenRewardRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRewardRequest
     */
    'reward'?: string | null;
}
/**
 * 
 * @export
 * @interface TokenVerifyRequest
 */
export interface TokenVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyRequest
     */
    'token': string;
}
/**
 * Serializer for Trigger model.
 * @export
 * @interface Trigger
 */
export interface Trigger {
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'id': string;
    /**
     * 
     * @type {TriggerTypeEnum}
     * @memberof Trigger
     */
    'type': TriggerTypeEnum;
    /**
     * Description of the trigger
     * @type {string}
     * @memberof Trigger
     */
    'description': string;
    /**
     * Concreate - Item, Character, Anomaly
     * @type {string}
     * @memberof Trigger
     */
    'game_object'?: string | null;
    /**
     * Position in the game world
     * @type {string}
     * @memberof Trigger
     */
    'position'?: string | null;
    /**
     * Optional limit trigger to a specific location
     * @type {string}
     * @memberof Trigger
     */
    'location'?: string | null;
    /**
     * All NPCs that been created from this template will have this trigger
     * @type {string}
     * @memberof Trigger
     */
    'npc'?: string | null;
    /**
     * Optional skill that is required to trigger the action
     * @type {number}
     * @memberof Trigger
     */
    'skill'?: number | null;
    /**
     * Optional item that is required to trigger the action
     * @type {string}
     * @memberof Trigger
     */
    'item'?: string | null;
}


/**
 * Serializer for Trigger model.
 * @export
 * @interface TriggerRequest
 */
export interface TriggerRequest {
    /**
     * 
     * @type {TriggerTypeEnum}
     * @memberof TriggerRequest
     */
    'type': TriggerTypeEnum;
    /**
     * Description of the trigger
     * @type {string}
     * @memberof TriggerRequest
     */
    'description': string;
    /**
     * Concreate - Item, Character, Anomaly
     * @type {string}
     * @memberof TriggerRequest
     */
    'game_object'?: string | null;
    /**
     * Position in the game world
     * @type {string}
     * @memberof TriggerRequest
     */
    'position'?: string | null;
    /**
     * Optional limit trigger to a specific location
     * @type {string}
     * @memberof TriggerRequest
     */
    'location'?: string | null;
    /**
     * All NPCs that been created from this template will have this trigger
     * @type {string}
     * @memberof TriggerRequest
     */
    'npc'?: string | null;
    /**
     * Optional skill that is required to trigger the action
     * @type {number}
     * @memberof TriggerRequest
     */
    'skill'?: number | null;
    /**
     * Optional item that is required to trigger the action
     * @type {string}
     * @memberof TriggerRequest
     */
    'item'?: string | null;
}


/**
 * * `search` - search * `kill` - kill * `interaction` - interaction * `position` - position * `useItem` - useItem * `useSkill` - useSkill * `custom` - custom
 * @export
 * @enum {string}
 */

export const TriggerTypeEnum = {
    Search: 'search',
    Kill: 'kill',
    Interaction: 'interaction',
    Position: 'position',
    UseItem: 'useItem',
    UseSkill: 'useSkill',
    Custom: 'custom'
} as const;

export type TriggerTypeEnum = typeof TriggerTypeEnum[keyof typeof TriggerTypeEnum];


/**
 * 
 * @export
 * @interface TurnActionResultGameEventData
 */
export interface TurnActionResultGameEventData {
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'turn_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'initiator_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'target_id': string;
    /**
     * 
     * @type {ActionModel}
     * @memberof TurnActionResultGameEventData
     */
    'action': ActionModel;
    /**
     * 
     * @type {ActionImpactModel}
     * @memberof TurnActionResultGameEventData
     */
    'impact': ActionImpactModel;
}
/**
 * * `weapon` - weapon * `armor` - armor * `artifact` - artifact * `amulet` - amulet * `material` - material * `quest` - quest * `misc` - misc * `food` - food * `rune` - rune
 * @export
 * @enum {string}
 */

export const Type496Enum = {
    Weapon: 'weapon',
    Armor: 'armor',
    Artifact: 'artifact',
    Amulet: 'amulet',
    Material: 'material',
    Quest: 'quest',
    Misc: 'misc',
    Food: 'food',
    Rune: 'rune'
} as const;

export type Type496Enum = typeof Type496Enum[keyof typeof Type496Enum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const Type82bEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type Type82bEnum = typeof Type82bEnum[keyof typeof Type82bEnum];


/**
 * * `attack` - attack * `defense` - defense * `heal` - heal * `buff` - buff * `debuff` - debuff * `utility` - utility * `special` - special
 * @export
 * @enum {string}
 */

export const TypeC27Enum = {
    Attack: 'attack',
    Defense: 'defense',
    Heal: 'heal',
    Buff: 'buff',
    Debuff: 'debuff',
    Utility: 'utility',
    Special: 'special'
} as const;

export type TypeC27Enum = typeof TypeC27Enum[keyof typeof TypeC27Enum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const ViolationEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ViolationEnum = typeof ViolationEnum[keyof typeof ViolationEnum];


/**
 * 
 * @export
 * @interface ViolationObject
 */
export interface ViolationObject {
    /**
     * 
     * @type {Id82bEnum}
     * @memberof ViolationObject
     */
    'id': Id82bEnum;
    /**
     * 
     * @type {string}
     * @memberof ViolationObject
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ViolationObject
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface WorldItem
 */
export interface WorldItem {
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'id': string;
    /**
     * 
     * @type {Item}
     * @memberof WorldItem
     */
    'item': Item;
    /**
     * 
     * @type {boolean}
     * @memberof WorldItem
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface WorldItemRequest
 */
export interface WorldItemRequest {
    /**
     * 
     * @type {ItemRequest}
     * @memberof WorldItemRequest
     */
    'item': ItemRequest;
    /**
     * 
     * @type {boolean}
     * @memberof WorldItemRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldItemRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorldItemRequest
     */
    'campaign': string;
}
/**
 * 
 * @export
 * @interface WorldPosition
 */
export interface WorldPosition {
    /**
     * 
     * @type {string}
     * @memberof WorldPosition
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorldPosition
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldPosition
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldPosition
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldPosition
     */
    'sub_location': string;
    /**
     * 
     * @type {string}
     * @memberof WorldPosition
     */
    'location': string;
    /**
     * 
     * @type {any}
     * @memberof WorldPosition
     */
    'labels'?: any;
    /**
     * 
     * @type {Array<Array<PositionConnection>>}
     * @memberof WorldPosition
     */
    'connections': Array<Array<PositionConnection>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorldPosition
     */
    'characters': Array<string>;
    /**
     * 
     * @type {Array<CharacterOnPosition>}
     * @memberof WorldPosition
     */
    'characters_on_position': Array<CharacterOnPosition>;
    /**
     * 
     * @type {string}
     * @memberof WorldPosition
     */
    'image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorldPosition
     */
    'is_safe'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorldPosition
     */
    'anomalies': Array<string>;
}

/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate: async (characterActionRequest?: CharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/current_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate: async (gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmDestroy', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate: async (id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmPartialUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate: async (gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMasterCharacterActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterCharacterActionCreate', 'gameMasterCharacterActionRequest', gameMasterCharacterActionRequest)
            const localVarPath = `/api/action/gm/register_character_action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate: async (registerImpactActionRequest: RegisterImpactActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerImpactActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterImpactCreate', 'registerImpactActionRequest', registerImpactActionRequest)
            const localVarPath = `/api/action/gm/register_impact/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerImpactActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmRetrieve', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate: async (id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/next_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Roll dice endpoint that creates a dice roll action, executes it immediately, and returns the dice outcome result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionRollD20DiceCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/roll_d20_dice/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/scheduled_actions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialAvailableRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/special/available/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/special/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialRetrieve: async (actionType: ActionSpecialRetrieveActionTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionType' is not null or undefined
            assertParamExists('actionSpecialRetrieve', 'actionType', actionType)
            const localVarPath = `/api/action/special/{action_type}/`
                .replace(`{${"action_type"}}`, encodeURIComponent(String(actionType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionApiAxiosParamCreator(configuration)
    return {
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCreate(characterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCurrentCycleRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCurrentCycleRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmCreate(gameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGameMasterCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterCharacterActionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterImpactAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterImpactCreate(registerImpactActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterImpactCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmUpdate(id, gameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionLogList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionLogList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionNextCycleCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionNextCycleCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionNextCycleCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Roll dice endpoint that creates a dice roll action, executes it immediately, and returns the dice outcome result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionRollD20DiceCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiceRollResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionRollD20DiceCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionRollD20DiceCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionScheduledActionsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionScheduledActionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialAvailableRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecialAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialAvailableRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialAvailableRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecialAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecialAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialRetrieve(actionType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionApiFp(configuration)
    return {
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate(characterActionRequest?: CharacterActionRequest, options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionCreate(characterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve(options?: any): AxiosPromise<GameCycle> {
            return localVarFp.actionCurrentCycleRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmCreate(gameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.actionGmDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedGameMasterCharacterActionLogList> {
            return localVarFp.actionGmList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: any): AxiosPromise<GameMasterCharacterAction> {
            return localVarFp.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: any): AxiosPromise<RegisterImpactAction> {
            return localVarFp.actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve(id: string, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmUpdate(id, gameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedCharacterActionLogList> {
            return localVarFp.actionLogList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate(options?: any): AxiosPromise<void> {
            return localVarFp.actionNextCycleCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Roll dice endpoint that creates a dice roll action, executes it immediately, and returns the dice outcome result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionRollD20DiceCreate(options?: any): AxiosPromise<DiceRollResult> {
            return localVarFp.actionRollD20DiceCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve(options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionScheduledActionsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialAvailableRetrieve(options?: any): AxiosPromise<SpecialAction> {
            return localVarFp.actionSpecialAvailableRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialList(options?: any): AxiosPromise<Array<SpecialAction>> {
            return localVarFp.actionSpecialList(options).then((request) => request(axios, basePath));
        },
        /**
         * Simple mixin that filters queryset by user\'s campaign
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: any): AxiosPromise<SpecialAction> {
            return localVarFp.actionSpecialRetrieve(actionType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {CharacterActionRequest} [characterActionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCreate(characterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCurrentCycleRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmCreate(gameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {string} id A UUID string identifying this character action.
     * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {RegisterImpactActionRequest} registerImpactActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {string} id A UUID string identifying this character action.
     * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmUpdate(id, gameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionLogList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionNextCycleCreate(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionNextCycleCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roll dice endpoint that creates a dice roll action, executes it immediately, and returns the dice outcome result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionRollD20DiceCreate(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionRollD20DiceCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionScheduledActionsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialAvailableRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialAvailableRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialList(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple mixin that filters queryset by user\'s campaign
     * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialRetrieve(actionType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ActionSpecialRetrieveActionTypeEnum = {
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM',
    Bargain: 'BARGAIN',
    Gift: 'GIFT',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE'
} as const;
export type ActionSpecialRetrieveActionTypeEnum = typeof ActionSpecialRetrieveActionTypeEnum[keyof typeof ActionSpecialRetrieveActionTypeEnum];


/**
 * AdaptersApi - axios parameter creator
 * @export
 */
export const AdaptersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate: async (connectRequest: ConnectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoConnectCreate', 'connectRequest', connectRequest)
            const localVarPath = `/api/adapters/centrifugo/connect/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate: async (gameEventRequest: GameEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameEventRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoPublishCreate', 'gameEventRequest', gameEventRequest)
            const localVarPath = `/api/adapters/centrifugo/publish/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoSubscribeCreate', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/api/adapters/centrifugo/subscribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdaptersApi - functional programming interface
 * @export
 */
export const AdaptersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdaptersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoConnectCreate(connectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoConnectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoPublishCreate(gameEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoPublishCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoSubscribeCreate(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoSubscribeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdaptersApi - factory interface
 * @export
 */
export const AdaptersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdaptersApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdaptersApi - object-oriented interface
 * @export
 * @class AdaptersApi
 * @extends {BaseAPI}
 */
export class AdaptersApi extends BaseAPI {
    /**
     * 
     * @param {ConnectRequest} connectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameEventRequest} gameEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate: async (tokenObtainPairRequest: TokenObtainPairRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPairRequest' is not null or undefined
            assertParamExists('authJwtTokenCreate', 'tokenObtainPairRequest', tokenObtainPairRequest)
            const localVarPath = `/auth/jwt/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('authJwtTokenRefreshCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/jwt/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate: async (tokenVerifyRequest: TokenVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyRequest' is not null or undefined
            assertParamExists('authJwtTokenVerifyCreate', 'tokenVerifyRequest', tokenVerifyRequest)
            const localVarPath = `/auth/jwt/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenCreate(tokenObtainPairRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenRefreshCreate(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenVerifyCreate(tokenVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPairRequest} tokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerifyRequest} tokenVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BargainApi - axios parameter creator
 * @export
 */
export const BargainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsAcceptCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsAcceptCreate', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/accept/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsGiftCreate: async (bargainCreateRequest: BargainCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainCreateRequest' is not null or undefined
            assertParamExists('bargainOpenBargainsGiftCreate', 'bargainCreateRequest', bargainCreateRequest)
            const localVarPath = `/api/bargain/open_bargains/gift/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bargainCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsCreate: async (bargainPk: string, offeredItemRequest: OfferedItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsCreate', 'bargainPk', bargainPk)
            // verify required parameter 'offeredItemRequest' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsCreate', 'offeredItemRequest', offeredItemRequest)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offeredItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsDestroy: async (bargainPk: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsDestroy', 'bargainPk', bargainPk)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsDestroy', 'itemId', itemId)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/{item_id}/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsList: async (bargainPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsList', 'bargainPk', bargainPk)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bargain/open_bargains/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRejectCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsRejectCreate', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/reject/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsRetrieve', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BargainApi - functional programming interface
 * @export
 */
export const BargainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BargainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsAcceptCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsAcceptCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsAcceptCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsGiftCreate(bargainCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsGiftCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferedItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsDestroy(bargainPk, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsList(bargainPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferedItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsList(bargainPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bargain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsRejectCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsRejectCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsRejectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedBargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BargainApi - factory interface
 * @export
 */
export const BargainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BargainApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsAcceptCreate(id: string, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsAcceptCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsGiftCreate(bargainCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: any): AxiosPromise<OfferedItem> {
            return localVarFp.bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.bargainOpenBargainsItemsDestroy(bargainPk, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsList(bargainPk: string, options?: any): AxiosPromise<Array<OfferedItem>> {
            return localVarFp.bargainOpenBargainsItemsList(bargainPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsList(options?: any): AxiosPromise<Array<Bargain>> {
            return localVarFp.bargainOpenBargainsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRejectCreate(id: string, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsRejectCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRetrieve(id: string, options?: any): AxiosPromise<DetailedBargain> {
            return localVarFp.bargainOpenBargainsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BargainApi - object-oriented interface
 * @export
 * @class BargainApi
 * @extends {BaseAPI}
 */
export class BargainApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsAcceptCreate(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsAcceptCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BargainCreateRequest} bargainCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsGiftCreate(bargainCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {OfferedItemRequest} offeredItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsDestroy(bargainPk, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsList(bargainPk: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsList(bargainPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsList(options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsRejectCreate(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsRejectCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CharacterApi - axios parameter creator
 * @export
 */
export const CharacterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmCharacterInfoRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/character_info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s current main character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedCurrentCharacterRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/owned/current_character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/owned/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterOwnedRetrieve', 'id', id)
            const localVarPath = `/api/character/owned/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select a character as the user\'s main character.
         * @param {string} id A UUID string identifying this character.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedSelectCharacterCreate: async (id: string, openaiCharacterRequest: OpenaiCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterOwnedSelectCharacterCreate', 'id', id)
            // verify required parameter 'openaiCharacterRequest' is not null or undefined
            assertParamExists('characterOwnedSelectCharacterCreate', 'openaiCharacterRequest', openaiCharacterRequest)
            const localVarPath = `/api/character/owned/{id}/select_character/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterDetailsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_details/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterStatsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_template/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate: async (characterPathRequest?: CharacterPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/chose_path/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End the character\'s turn by spending all action points.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerEndTurnCreate: async (openaiCharacterRequest: OpenaiCharacterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openaiCharacterRequest' is not null or undefined
            assertParamExists('characterPlayerEndTurnCreate', 'openaiCharacterRequest', openaiCharacterRequest)
            const localVarPath = `/api/character/player/end_turn/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiCharacterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate: async (characterGenericDataRequest: CharacterGenericDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterGenericDataRequest' is not null or undefined
            assertParamExists('characterPlayerImportCharacterCreate', 'characterGenericDataRequest', characterGenericDataRequest)
            const localVarPath = `/api/character/player/import_character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterGenericDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList: async (npc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterPlayerRetrieve', 'id', id)
            const localVarPath = `/api/character/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsResetBaseStatsCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/stats/reset_base_stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterStatsRetrieve', 'id', id)
            const localVarPath = `/api/character/stats/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsSwipeBaseStatCreate: async (swipeBaseStatRequest: SwipeBaseStatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'swipeBaseStatRequest' is not null or undefined
            assertParamExists('characterStatsSwipeBaseStatCreate', 'swipeBaseStatRequest', swipeBaseStatRequest)
            const localVarPath = `/api/character/stats/swipe_base_stat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swipeBaseStatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterApi - functional programming interface
 * @export
 */
export const CharacterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmCharacterInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the user\'s current main character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterOwnedCurrentCharacterRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterOwnedCurrentCharacterRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterOwnedCurrentCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterOwnedList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterOwnedList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterOwnedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterOwnedRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterOwnedRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterOwnedRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Select a character as the user\'s main character.
         * @param {string} id A UUID string identifying this character.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterOwnedSelectCharacterCreate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterOwnedSelectCharacterCreate(id, openaiCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterOwnedSelectCharacterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterDetailsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterDetailsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterDetailsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterInfoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterStatsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterStatsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterTemplateFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterTemplateRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterTemplateRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerChosePathCreate(characterPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerChosePathCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End the character\'s turn by spending all action points.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerEndTurnCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerEndTurnCreate(openaiCharacterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerEndTurnCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterGenericData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerImportCharacterCreate(characterGenericDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerImportCharacterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerList(npc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsResetBaseStatsCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsResetBaseStatsCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsResetBaseStatsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsSwipeBaseStatCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CharacterApi - factory interface
 * @export
 */
export const CharacterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterGmCharacterInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterGmList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s current main character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedCurrentCharacterRetrieve(options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterOwnedCurrentCharacterRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterOwnedList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterOwnedRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Select a character as the user\'s main character.
         * @param {string} id A UUID string identifying this character.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterOwnedSelectCharacterCreate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterOwnedSelectCharacterCreate(id, openaiCharacterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterDetailsRetrieve(options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerCharacterDetailsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve(options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterPlayerCharacterInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterStatsRetrieve(options?: any): AxiosPromise<CharacterStats> {
            return localVarFp.characterPlayerCharacterStatsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve(options?: any): AxiosPromise<CharacterTemplateFull> {
            return localVarFp.characterPlayerCharacterTemplateRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: any): AxiosPromise<CharacterPath> {
            return localVarFp.characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * End the character\'s turn by spending all action points.
         * @param {OpenaiCharacterRequest} openaiCharacterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerEndTurnCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerEndTurnCreate(openaiCharacterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: any): AxiosPromise<CharacterGenericData> {
            return localVarFp.characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList(npc?: boolean, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterPlayerList(npc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsList(options?: any): AxiosPromise<Array<DetailStat>> {
            return localVarFp.characterStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsResetBaseStatsCreate(options?: any): AxiosPromise<Array<DetailStat>> {
            return localVarFp.characterStatsResetBaseStatsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsRetrieve(id: string, options?: any): AxiosPromise<DetailStat> {
            return localVarFp.characterStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: any): AxiosPromise<DetailStat> {
            return localVarFp.characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterApi - object-oriented interface
 * @export
 * @class CharacterApi
 * @extends {BaseAPI}
 */
export class CharacterApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmCharacterInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s current main character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterOwnedCurrentCharacterRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterOwnedCurrentCharacterRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterOwnedList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterOwnedList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for managing characters in the client application. Provides read-only access to character data.  1. **get_queryset**: Returns the queryset of characters for the authenticated user. 2. **we se all active and non active characters**: Filters characters based on the user\'s main character\'s position and campaign. 3. **no npc characters are allowed**: Ensures that only characters related to the user\'s main character\'s campaign are returned. 4. **select character** allows client to choose a character to play with.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterOwnedRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterOwnedRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select a character as the user\'s main character.
     * @param {string} id A UUID string identifying this character.
     * @param {OpenaiCharacterRequest} openaiCharacterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterOwnedSelectCharacterCreate(id: string, openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterOwnedSelectCharacterCreate(id, openaiCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterDetailsRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterDetailsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterStatsRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterStatsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterTemplateRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CharacterPathRequest} [characterPathRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End the character\'s turn by spending all action points.
     * @param {OpenaiCharacterRequest} openaiCharacterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerEndTurnCreate(openaiCharacterRequest: OpenaiCharacterRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerEndTurnCreate(openaiCharacterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new character for the user.
     * @param {CharacterGenericDataRequest} characterGenericDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerList(npc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsList(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsResetBaseStatsCreate(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsResetBaseStatsCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this stat.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Google OAuth login endpoint that handles Google ID token verification, user creation/authentication, and JWT token generation with cookie setting.  Expected request data: {     \"id_token\": \"google_id_token_from_frontend\" }  Returns JWT tokens and sets dx_backend_token cookie for seamless integration with existing authentication system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientAuthGoogleLoginCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/auth/google/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Google OAuth URL for frontend to redirect users to. This is optional - frontend can construct this URL directly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientAuthGoogleUrlCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/auth/google/url/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current campaign for the client.  Returns the current campaign ID and its details. If no current campaign is set, the current_campaign field will be null.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsCurrentCampaignRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/campaigns/current_campaign/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all campaigns for the current client (both as player and as master). Returns only active campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsListCampaignsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/campaigns/list_campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the current campaign for the client.  The campaign must be active and the client must be either a player or a master in the campaign.
         * @param {string} id A UUID string identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsSetCurrentCampaignCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientCampaignsSetCurrentCampaignCreate', 'id', id)
            const localVarPath = `/api/client/campaigns/{id}/set_current_campaign/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate: async (openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientCreate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the basic information of the current authenticated client. This enpoint used by game client to get current client information It contains information about: is_active, current_campaign, main_character, play_campaigns, master_campaigns, owned_characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCurrentInfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/current/info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientDestroy', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate: async (id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientPartialUpdate', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate: async (registrationFormRequest: RegistrationFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationFormRequest' is not null or undefined
            assertParamExists('clientRegisterLocalClientCreate', 'registrationFormRequest', registrationFormRequest)
            const localVarPath = `/api/client/register_local_client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientRetrieve', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate: async (id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientUpdate', 'id', id)
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientUpdate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Google OAuth login endpoint that handles Google ID token verification, user creation/authentication, and JWT token generation with cookie setting.  Expected request data: {     \"id_token\": \"google_id_token_from_frontend\" }  Returns JWT tokens and sets dx_backend_token cookie for seamless integration with existing authentication system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientAuthGoogleLoginCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientAuthGoogleLoginCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientAuthGoogleLoginCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the Google OAuth URL for frontend to redirect users to. This is optional - frontend can construct this URL directly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientAuthGoogleUrlCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientAuthGoogleUrlCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientAuthGoogleUrlCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current campaign for the client.  Returns the current campaign ID and its details. If no current campaign is set, the current_campaign field will be null.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCampaignsCurrentCampaignRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAICampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCampaignsCurrentCampaignRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCampaignsCurrentCampaignRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all campaigns for the current client (both as player and as master). Returns only active campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCampaignsListCampaignsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAICampaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCampaignsListCampaignsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCampaignsListCampaignsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the current campaign for the client.  The campaign must be active and the client must be either a player or a master in the campaign.
         * @param {string} id A UUID string identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCampaignsSetCurrentCampaignCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCampaignsSetCurrentCampaignCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCampaignsSetCurrentCampaignCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCreate(openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the basic information of the current authenticated client. This enpoint used by game client to get current client information It contains information about: is_active, current_campaign, main_character, play_campaigns, master_campaigns, owned_characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCurrentInfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentClientInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCurrentInfoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCurrentInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenAIClientManagement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRegisterLocalClientCreate(registrationFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRegisterLocalClientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientUpdate(id, openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * Google OAuth login endpoint that handles Google ID token verification, user creation/authentication, and JWT token generation with cookie setting.  Expected request data: {     \"id_token\": \"google_id_token_from_frontend\" }  Returns JWT tokens and sets dx_backend_token cookie for seamless integration with existing authentication system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientAuthGoogleLoginCreate(options?: any): AxiosPromise<void> {
            return localVarFp.clientAuthGoogleLoginCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Google OAuth URL for frontend to redirect users to. This is optional - frontend can construct this URL directly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientAuthGoogleUrlCreate(options?: any): AxiosPromise<void> {
            return localVarFp.clientAuthGoogleUrlCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current campaign for the client.  Returns the current campaign ID and its details. If no current campaign is set, the current_campaign field will be null.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsCurrentCampaignRetrieve(options?: any): AxiosPromise<OpenAICampaign> {
            return localVarFp.clientCampaignsCurrentCampaignRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * List all campaigns for the current client (both as player and as master). Returns only active campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsListCampaignsRetrieve(options?: any): AxiosPromise<OpenAICampaign> {
            return localVarFp.clientCampaignsListCampaignsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Set the current campaign for the client.  The campaign must be active and the client must be either a player or a master in the campaign.
         * @param {string} id A UUID string identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCampaignsSetCurrentCampaignCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientCampaignsSetCurrentCampaignCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientCreate(openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic information of the current authenticated client. This enpoint used by game client to get current client information It contains information about: is_active, current_campaign, main_character, play_campaigns, master_campaigns, owned_characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCurrentInfoRetrieve(options?: any): AxiosPromise<CurrentClientInfo> {
            return localVarFp.clientCurrentInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList(options?: any): AxiosPromise<Array<OpenAIClientManagement>> {
            return localVarFp.clientList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: any): AxiosPromise<RegistrationForm> {
            return localVarFp.clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve(id: string, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * Google OAuth login endpoint that handles Google ID token verification, user creation/authentication, and JWT token generation with cookie setting.  Expected request data: {     \"id_token\": \"google_id_token_from_frontend\" }  Returns JWT tokens and sets dx_backend_token cookie for seamless integration with existing authentication system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientAuthGoogleLoginCreate(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientAuthGoogleLoginCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Google OAuth URL for frontend to redirect users to. This is optional - frontend can construct this URL directly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientAuthGoogleUrlCreate(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientAuthGoogleUrlCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current campaign for the client.  Returns the current campaign ID and its details. If no current campaign is set, the current_campaign field will be null.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCampaignsCurrentCampaignRetrieve(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCampaignsCurrentCampaignRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all campaigns for the current client (both as player and as master). Returns only active campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCampaignsListCampaignsRetrieve(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCampaignsListCampaignsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the current campaign for the client.  The campaign must be active and the client must be either a player or a master in the campaign.
     * @param {string} id A UUID string identifying this campaign.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCampaignsSetCurrentCampaignCreate(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCampaignsSetCurrentCampaignCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCreate(openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the basic information of the current authenticated client. This enpoint used by game client to get current client information It contains information about: is_active, current_campaign, main_character, play_campaigns, master_campaigns, owned_characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCurrentInfoRetrieve(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCurrentInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientList(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegistrationFormRequest} registrationFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 * @export
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/character/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsRetrieve: async (id: CoreStatsRetrieveIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coreStatsRetrieve', 'id', id)
            const localVarPath = `/api/core/stats/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/violations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsRetrieve: async (id: CoreViolationsRetrieveIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coreViolationsRetrieve', 'id', id)
            const localVarPath = `/api/core/violations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreCharacterStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreCharacterStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreCharacterStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreViolationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ViolationObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreViolationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreViolationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreViolationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreViolationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList(options?: any): AxiosPromise<Array<CharacterStat>> {
            return localVarFp.coreCharacterStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsList(options?: any): AxiosPromise<Array<StatObject>> {
            return localVarFp.coreStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: any): AxiosPromise<StatObject> {
            return localVarFp.coreStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsList(options?: any): AxiosPromise<Array<ViolationObject>> {
            return localVarFp.coreViolationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: any): AxiosPromise<ViolationObject> {
            return localVarFp.coreViolationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreCharacterStatsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreCharacterStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreStatsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CoreStatsRetrieveIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreViolationsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreViolationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CoreViolationsRetrieveIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreViolationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CoreStatsRetrieveIdEnum = {
    PhysicalStrength: 'Physical Strength',
    MentalStrength: 'Mental Strength',
    FlowResonance: 'Flow Resonance',
    Concentration: 'Concentration',
    FlowManipulation: 'Flow Manipulation',
    FlowConnection: 'Flow Connection',
    Knowledge: 'Knowledge',
    Speed: 'Speed',
    Luck: 'Luck',
    Charisma: 'Charisma'
} as const;
export type CoreStatsRetrieveIdEnum = typeof CoreStatsRetrieveIdEnum[keyof typeof CoreStatsRetrieveIdEnum];
/**
 * @export
 */
export const CoreViolationsRetrieveIdEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;
export type CoreViolationsRetrieveIdEnum = typeof CoreViolationsRetrieveIdEnum[keyof typeof CoreViolationsRetrieveIdEnum];


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyCharacterRetrieve', 'id', id)
            const localVarPath = `/api/currency/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate: async (currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldCreate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldDestroy', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate: async (id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCurrencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldRetrieve', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate: async (id: string, currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'id', id)
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldCreate(currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencyToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldUpdate(id, currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList(options?: any): AxiosPromise<Array<CharacterCurrency>> {
            return localVarFp.currencyCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.currencyCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldCreate(currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.currencyWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList(options?: any): AxiosPromise<Array<CurrencyToken>> {
            return localVarFp.currencyWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve(id: string, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldCreate(currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiceApi - axios parameter creator
 * @export
 */
export const DiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diceChallengeList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dice/challenge/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diceChallengeRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('diceChallengeRetrieve', 'id', id)
            const localVarPath = `/api/dice/challenge/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiceApi - functional programming interface
 * @export
 */
export const DiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diceChallengeList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChallengeGeneric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diceChallengeList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiceApi.diceChallengeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diceChallengeRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChallengeGeneric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diceChallengeRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiceApi.diceChallengeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiceApi - factory interface
 * @export
 */
export const DiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiceApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diceChallengeList(options?: any): AxiosPromise<Array<ChallengeGeneric>> {
            return localVarFp.diceChallengeList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diceChallengeRetrieve(id: string, options?: any): AxiosPromise<ChallengeGeneric> {
            return localVarFp.diceChallengeRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiceApi - object-oriented interface
 * @export
 * @class DiceApi
 * @extends {BaseAPI}
 */
export class DiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiceApi
     */
    public diceChallengeList(options?: RawAxiosRequestConfig) {
        return DiceApiFp(this.configuration).diceChallengeList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiceApi
     */
    public diceChallengeRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return DiceApiFp(this.configuration).diceChallengeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/effects/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('effectsActiveRetrieve', 'id', id)
            const localVarPath = `/api/effects/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveEffect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList(options?: any): AxiosPromise<Array<ActiveEffect>> {
            return localVarFp.effectsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.effectsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveList(options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FightApi - axios parameter creator
 * @export
 */
export const FightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightRetrieve', 'id', id)
            const localVarPath = `/api/fight/fight/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FightApi - functional programming interface
 * @export
 */
export const FightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FightGeneric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FightApi - factory interface
 * @export
 */
export const FightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FightApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve(id: string, options?: any): AxiosPromise<FightGeneric> {
            return localVarFp.fightFightRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FightApi - object-oriented interface
 * @export
 * @class FightApi
 * @extends {BaseAPI}
 */
export class FightApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GMWorldEditiorPositionConnectionsApi - axios parameter creator
 * @export
 */
export const GMWorldEditiorPositionConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsActivateCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsActivateCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsActivateCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/activate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure a connection with requirements
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionRelationConfigurationRequest} [positionRelationConfigurationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsConfigureCreate: async (id: number, positionRelationConfigurationRequest?: PositionRelationConfigurationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsConfigureCreate', 'id', id)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/configure/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRelationConfigurationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a connection between two positions
         * @param {PositionConnectionCreateRequest} positionConnectionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsConnectCreate: async (positionConnectionCreateRequest: PositionConnectionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionConnectionCreateRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsConnectCreate', 'positionConnectionCreateRequest', positionConnectionCreateRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/connect/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsCreate: async (positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsDeactivateCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsDeactivateCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsDeactivateCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/deactivate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {boolean} [isActive] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsList: async (isActive?: boolean, isPublic?: boolean, ordering?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-position-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsLockCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsLockCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsLockCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/lock/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PatchedPositionConnectionRequest} [patchedPositionConnectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsPartialUpdate: async (id: number, patchedPositionConnectionRequest?: PatchedPositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPositionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a connection as private
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsSetPrivateCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsSetPrivateCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsSetPrivateCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/setPrivate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a connection as public
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsSetPublicCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsSetPublicCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsSetPublicCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/setPublic/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsUnlockCreate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsUnlockCreate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsUnlockCreate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/unlock/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsUpdate: async (id: number, positionConnectionRequest: PositionConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsUpdate', 'id', id)
            // verify required parameter 'positionConnectionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionConnectionsUpdate', 'positionConnectionRequest', positionConnectionRequest)
            const localVarPath = `/api/gamemaster/world-position-connections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GMWorldEditiorPositionConnectionsApi - functional programming interface
 * @export
 */
export const GMWorldEditiorPositionConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GMWorldEditiorPositionConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsActivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsActivateCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsActivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure a connection with requirements
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionRelationConfigurationRequest} [positionRelationConfigurationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsConfigureCreate(id: number, positionRelationConfigurationRequest?: PositionRelationConfigurationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsConfigureCreate(id, positionRelationConfigurationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsConfigureCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a connection between two positions
         * @param {PositionConnectionCreateRequest} positionConnectionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest: PositionConnectionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsConnectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsCreate(positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsCreate(positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsDeactivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsDeactivateCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsDeactivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {boolean} [isActive] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsList(isActive?: boolean, isPublic?: boolean, ordering?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionConnection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsList(isActive, isPublic, ordering, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsLockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsLockCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsLockCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PatchedPositionConnectionRequest} [patchedPositionConnectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsPartialUpdate(id: number, patchedPositionConnectionRequest?: PatchedPositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsPartialUpdate(id, patchedPositionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a connection as private
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsSetPrivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsSetPrivateCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsSetPrivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a connection as public
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsSetPublicCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsSetPublicCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsSetPublicCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsUnlockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsUnlockCreate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsUnlockCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionConnectionsUpdate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionConnectionsUpdate(id, positionConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionConnectionsApi.gamemasterWorldPositionConnectionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GMWorldEditiorPositionConnectionsApi - factory interface
 * @export
 */
export const GMWorldEditiorPositionConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GMWorldEditiorPositionConnectionsApiFp(configuration)
    return {
        /**
         * Activate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsActivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsActivateCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure a connection with requirements
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionRelationConfigurationRequest} [positionRelationConfigurationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsConfigureCreate(id: number, positionRelationConfigurationRequest?: PositionRelationConfigurationRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsConfigureCreate(id, positionRelationConfigurationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a connection between two positions
         * @param {PositionConnectionCreateRequest} positionConnectionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest: PositionConnectionCreateRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsCreate(positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsCreate(positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsDeactivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsDeactivateCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldPositionConnectionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {boolean} [isActive] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsList(isActive?: boolean, isPublic?: boolean, ordering?: string, options?: any): AxiosPromise<Array<PositionConnection>> {
            return localVarFp.gamemasterWorldPositionConnectionsList(isActive, isPublic, ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * Lock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsLockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsLockCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PatchedPositionConnectionRequest} [patchedPositionConnectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsPartialUpdate(id: number, patchedPositionConnectionRequest?: PatchedPositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsPartialUpdate(id, patchedPositionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsRetrieve(id: number, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a connection as private
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsSetPrivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsSetPrivateCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a connection as public
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsSetPublicCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsSetPublicCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlock a connection
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsUnlockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsUnlockCreate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing position connections in the world
         * @param {number} id A unique integer value identifying this position connection.
         * @param {PositionConnectionRequest} positionConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionConnectionsUpdate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: any): AxiosPromise<PositionConnection> {
            return localVarFp.gamemasterWorldPositionConnectionsUpdate(id, positionConnectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GMWorldEditiorPositionConnectionsApi - object-oriented interface
 * @export
 * @class GMWorldEditiorPositionConnectionsApi
 * @extends {BaseAPI}
 */
export class GMWorldEditiorPositionConnectionsApi extends BaseAPI {
    /**
     * Activate a connection
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsActivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsActivateCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure a connection with requirements
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionRelationConfigurationRequest} [positionRelationConfigurationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsConfigureCreate(id: number, positionRelationConfigurationRequest?: PositionRelationConfigurationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsConfigureCreate(id, positionRelationConfigurationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a connection between two positions
     * @param {PositionConnectionCreateRequest} positionConnectionCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest: PositionConnectionCreateRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsConnectCreate(positionConnectionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsCreate(positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsCreate(positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a connection
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsDeactivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsDeactivateCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {number} id A unique integer value identifying this position connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {boolean} [isActive] 
     * @param {boolean} [isPublic] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsList(isActive?: boolean, isPublic?: boolean, ordering?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsList(isActive, isPublic, ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lock a connection
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsLockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsLockCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PatchedPositionConnectionRequest} [patchedPositionConnectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsPartialUpdate(id: number, patchedPositionConnectionRequest?: PatchedPositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsPartialUpdate(id, patchedPositionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {number} id A unique integer value identifying this position connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a connection as private
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsSetPrivateCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsSetPrivateCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a connection as public
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsSetPublicCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsSetPublicCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlock a connection
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsUnlockCreate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsUnlockCreate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing position connections in the world
     * @param {number} id A unique integer value identifying this position connection.
     * @param {PositionConnectionRequest} positionConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionConnectionsApi
     */
    public gamemasterWorldPositionConnectionsUpdate(id: number, positionConnectionRequest: PositionConnectionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionConnectionsApiFp(this.configuration).gamemasterWorldPositionConnectionsUpdate(id, positionConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GMWorldEditiorPositionsApi - axios parameter creator
 * @export
 */
export const GMWorldEditiorPositionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for managing positions in the world
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsCreate: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionsCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing positions in the world
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsList: async (gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gridZ !== undefined) {
                localVarQueryParameter['grid_z'] = gridZ;
            }

            if (isSafe !== undefined) {
                localVarQueryParameter['is_safe'] = isSafe;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (subLocation !== undefined) {
                localVarQueryParameter['sub_location'] = subLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a position as dangerous
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMarkDangerousCreate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMarkDangerousCreate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMarkDangerousCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-positions/{id}/markDangerous/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a position as safe
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMarkSafeCreate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMarkSafeCreate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMarkSafeCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-positions/{id}/markSafe/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move a position to new coordinates
         * @param {string} id A UUID string identifying this position.
         * @param {PositionMoveRequest} positionMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMoveCreate: async (id: string, positionMoveRequest: PositionMoveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMoveCreate', 'id', id)
            // verify required parameter 'positionMoveRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionsMoveCreate', 'positionMoveRequest', positionMoveRequest)
            const localVarPath = `/api/gamemaster/world-positions/{id}/move/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionMoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsPartialUpdate: async (id: string, patchedPositionRequest?: PatchedPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/world-positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsUpdate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldPositionsUpdate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldPositionsUpdate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GMWorldEditiorPositionsApi - functional programming interface
 * @export
 */
export const GMWorldEditiorPositionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GMWorldEditiorPositionsApiAxiosParamCreator(configuration)
    return {
        /**
         * API for managing positions in the world
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsCreate(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing positions in the world
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsList(gridZ, isSafe, ordering, subLocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a position as dangerous
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsMarkDangerousCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsMarkDangerousCreate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsMarkDangerousCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a position as safe
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsMarkSafeCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsMarkSafeCreate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsMarkSafeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move a position to new coordinates
         * @param {string} id A UUID string identifying this position.
         * @param {PositionMoveRequest} positionMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsMoveCreate(id: string, positionMoveRequest: PositionMoveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsMoveCreate(id, positionMoveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsMoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsPartialUpdate(id, patchedPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldPositionsUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldPositionsUpdate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditiorPositionsApi.gamemasterWorldPositionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GMWorldEditiorPositionsApi - factory interface
 * @export
 */
export const GMWorldEditiorPositionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GMWorldEditiorPositionsApiFp(configuration)
    return {
        /**
         * API for managing positions in the world
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsCreate(positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsCreate(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldPositionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing positions in the world
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.gamemasterWorldPositionsList(gridZ, isSafe, ordering, subLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a position as dangerous
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMarkDangerousCreate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsMarkDangerousCreate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a position as safe
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMarkSafeCreate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsMarkSafeCreate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Move a position to new coordinates
         * @param {string} id A UUID string identifying this position.
         * @param {PositionMoveRequest} positionMoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsMoveCreate(id: string, positionMoveRequest: PositionMoveRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsMoveCreate(id, positionMoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsPartialUpdate(id, patchedPositionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsRetrieve(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing positions in the world
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldPositionsUpdate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldPositionsUpdate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GMWorldEditiorPositionsApi - object-oriented interface
 * @export
 * @class GMWorldEditiorPositionsApi
 * @extends {BaseAPI}
 */
export class GMWorldEditiorPositionsApi extends BaseAPI {
    /**
     * API for managing positions in the world
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsCreate(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing positions in the world
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing positions in the world
     * @param {number} [gridZ] 
     * @param {boolean} [isSafe] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [subLocation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsList(gridZ, isSafe, ordering, subLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a position as dangerous
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsMarkDangerousCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsMarkDangerousCreate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a position as safe
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsMarkSafeCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsMarkSafeCreate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move a position to new coordinates
     * @param {string} id A UUID string identifying this position.
     * @param {PositionMoveRequest} positionMoveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsMoveCreate(id: string, positionMoveRequest: PositionMoveRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsMoveCreate(id, positionMoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing positions in the world
     * @param {string} id A UUID string identifying this position.
     * @param {PatchedPositionRequest} [patchedPositionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsPartialUpdate(id, patchedPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing positions in the world
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing positions in the world
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditiorPositionsApi
     */
    public gamemasterWorldPositionsUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditiorPositionsApiFp(this.configuration).gamemasterWorldPositionsUpdate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GMWorldEditorAllSpawnersApi - axios parameter creator
 * @export
 */
export const GMWorldEditorAllSpawnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllActivateCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersAllActivateCreate', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/all/{id}/activate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllDeactivateCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersAllDeactivateCreate', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/all/{id}/deactivate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllList: async (campaign?: string, dimension?: number, isActive?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/spawners/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersAllRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GMWorldEditorAllSpawnersApi - functional programming interface
 * @export
 */
export const GMWorldEditorAllSpawnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GMWorldEditorAllSpawnersApiAxiosParamCreator(configuration)
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersAllActivateCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersAllActivateCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorAllSpawnersApi.gamemasterSpawnersAllActivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersAllDeactivateCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersAllDeactivateCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorAllSpawnersApi.gamemasterSpawnersAllDeactivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersAllList(campaign?: string, dimension?: number, isActive?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenericSpawner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersAllList(campaign, dimension, isActive, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorAllSpawnersApi.gamemasterSpawnersAllList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersAllRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersAllRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorAllSpawnersApi.gamemasterSpawnersAllRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GMWorldEditorAllSpawnersApi - factory interface
 * @export
 */
export const GMWorldEditorAllSpawnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GMWorldEditorAllSpawnersApiFp(configuration)
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllActivateCreate(id: string, options?: any): AxiosPromise<GenericSpawner> {
            return localVarFp.gamemasterSpawnersAllActivateCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllDeactivateCreate(id: string, options?: any): AxiosPromise<GenericSpawner> {
            return localVarFp.gamemasterSpawnersAllDeactivateCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllList(campaign?: string, dimension?: number, isActive?: boolean, position?: string, options?: any): AxiosPromise<Array<GenericSpawner>> {
            return localVarFp.gamemasterSpawnersAllList(campaign, dimension, isActive, position, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersAllRetrieve(id: string, options?: any): AxiosPromise<GenericSpawner> {
            return localVarFp.gamemasterSpawnersAllRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GMWorldEditorAllSpawnersApi - object-oriented interface
 * @export
 * @class GMWorldEditorAllSpawnersApi
 * @extends {BaseAPI}
 */
export class GMWorldEditorAllSpawnersApi extends BaseAPI {
    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorAllSpawnersApi
     */
    public gamemasterSpawnersAllActivateCreate(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorAllSpawnersApiFp(this.configuration).gamemasterSpawnersAllActivateCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorAllSpawnersApi
     */
    public gamemasterSpawnersAllDeactivateCreate(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorAllSpawnersApiFp(this.configuration).gamemasterSpawnersAllDeactivateCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} [campaign] 
     * @param {number} [dimension] 
     * @param {boolean} [isActive] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorAllSpawnersApi
     */
    public gamemasterSpawnersAllList(campaign?: string, dimension?: number, isActive?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorAllSpawnersApiFp(this.configuration).gamemasterSpawnersAllList(campaign, dimension, isActive, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorAllSpawnersApi
     */
    public gamemasterSpawnersAllRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorAllSpawnersApiFp(this.configuration).gamemasterSpawnersAllRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GMWorldEditorNPCSpawnersApi - axios parameter creator
 * @export
 */
export const GMWorldEditorNPCSpawnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {NPCSpawnerCreateRequest} nPCSpawnerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcCreate: async (nPCSpawnerCreateRequest: NPCSpawnerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nPCSpawnerCreateRequest' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcCreate', 'nPCSpawnerCreateRequest', nPCSpawnerCreateRequest)
            const localVarPath = `/api/gamemaster/spawners/npc/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nPCSpawnerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/npc/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {string} [characterTemplate] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcList: async (campaign?: string, characterTemplate?: string, dimension?: number, isActive?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/spawners/npc/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (characterTemplate !== undefined) {
                localVarQueryParameter['character_template'] = characterTemplate;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {PatchedNPCGenericSpawnerRequest} [patchedNPCGenericSpawnerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcPartialUpdate: async (id: string, patchedNPCGenericSpawnerRequest?: PatchedNPCGenericSpawnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/npc/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNPCGenericSpawnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/spawners/npc/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {NPCGenericSpawnerRequest} nPCGenericSpawnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcUpdate: async (id: string, nPCGenericSpawnerRequest: NPCGenericSpawnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcUpdate', 'id', id)
            // verify required parameter 'nPCGenericSpawnerRequest' is not null or undefined
            assertParamExists('gamemasterSpawnersNpcUpdate', 'nPCGenericSpawnerRequest', nPCGenericSpawnerRequest)
            const localVarPath = `/api/gamemaster/spawners/npc/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nPCGenericSpawnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GMWorldEditorNPCSpawnersApi - functional programming interface
 * @export
 */
export const GMWorldEditorNPCSpawnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GMWorldEditorNPCSpawnersApiAxiosParamCreator(configuration)
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {NPCSpawnerCreateRequest} nPCSpawnerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest: NPCSpawnerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCSpawnerCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {string} [characterTemplate] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcList(campaign?: string, characterTemplate?: string, dimension?: number, isActive?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NPCSpawnerList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcList(campaign, characterTemplate, dimension, isActive, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {PatchedNPCGenericSpawnerRequest} [patchedNPCGenericSpawnerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcPartialUpdate(id: string, patchedNPCGenericSpawnerRequest?: PatchedNPCGenericSpawnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCGenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcPartialUpdate(id, patchedNPCGenericSpawnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCGenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {NPCGenericSpawnerRequest} nPCGenericSpawnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSpawnersNpcUpdate(id: string, nPCGenericSpawnerRequest: NPCGenericSpawnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NPCGenericSpawner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSpawnersNpcUpdate(id, nPCGenericSpawnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorNPCSpawnersApi.gamemasterSpawnersNpcUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GMWorldEditorNPCSpawnersApi - factory interface
 * @export
 */
export const GMWorldEditorNPCSpawnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GMWorldEditorNPCSpawnersApiFp(configuration)
    return {
        /**
         * API for managing spawners in DX world editor.
         * @param {NPCSpawnerCreateRequest} nPCSpawnerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest: NPCSpawnerCreateRequest, options?: any): AxiosPromise<NPCSpawnerCreate> {
            return localVarFp.gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterSpawnersNpcDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} [campaign] 
         * @param {string} [characterTemplate] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcList(campaign?: string, characterTemplate?: string, dimension?: number, isActive?: boolean, position?: string, options?: any): AxiosPromise<Array<NPCSpawnerList>> {
            return localVarFp.gamemasterSpawnersNpcList(campaign, characterTemplate, dimension, isActive, position, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {PatchedNPCGenericSpawnerRequest} [patchedNPCGenericSpawnerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcPartialUpdate(id: string, patchedNPCGenericSpawnerRequest?: PatchedNPCGenericSpawnerRequest, options?: any): AxiosPromise<NPCGenericSpawner> {
            return localVarFp.gamemasterSpawnersNpcPartialUpdate(id, patchedNPCGenericSpawnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcRetrieve(id: string, options?: any): AxiosPromise<NPCGenericSpawner> {
            return localVarFp.gamemasterSpawnersNpcRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing spawners in DX world editor.
         * @param {string} id A UUID string identifying this npc spawner.
         * @param {NPCGenericSpawnerRequest} nPCGenericSpawnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSpawnersNpcUpdate(id: string, nPCGenericSpawnerRequest: NPCGenericSpawnerRequest, options?: any): AxiosPromise<NPCGenericSpawner> {
            return localVarFp.gamemasterSpawnersNpcUpdate(id, nPCGenericSpawnerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GMWorldEditorNPCSpawnersApi - object-oriented interface
 * @export
 * @class GMWorldEditorNPCSpawnersApi
 * @extends {BaseAPI}
 */
export class GMWorldEditorNPCSpawnersApi extends BaseAPI {
    /**
     * API for managing spawners in DX world editor.
     * @param {NPCSpawnerCreateRequest} nPCSpawnerCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest: NPCSpawnerCreateRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcCreate(nPCSpawnerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} [campaign] 
     * @param {string} [characterTemplate] 
     * @param {number} [dimension] 
     * @param {boolean} [isActive] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcList(campaign?: string, characterTemplate?: string, dimension?: number, isActive?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcList(campaign, characterTemplate, dimension, isActive, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {PatchedNPCGenericSpawnerRequest} [patchedNPCGenericSpawnerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcPartialUpdate(id: string, patchedNPCGenericSpawnerRequest?: PatchedNPCGenericSpawnerRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcPartialUpdate(id, patchedNPCGenericSpawnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing spawners in DX world editor.
     * @param {string} id A UUID string identifying this npc spawner.
     * @param {NPCGenericSpawnerRequest} nPCGenericSpawnerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorNPCSpawnersApi
     */
    public gamemasterSpawnersNpcUpdate(id: string, nPCGenericSpawnerRequest: NPCGenericSpawnerRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorNPCSpawnersApiFp(this.configuration).gamemasterSpawnersNpcUpdate(id, nPCGenericSpawnerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GMWorldEditorSubLocationsApi - axios parameter creator
 * @export
 */
export const GMWorldEditorSubLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsActivateCreate: async (id: string, subLocationRequest: SubLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsActivateCreate', 'id', id)
            // verify required parameter 'subLocationRequest' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsActivateCreate', 'subLocationRequest', subLocationRequest)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/activate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsCreate: async (subLocationRequest: SubLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subLocationRequest' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsCreate', 'subLocationRequest', subLocationRequest)
            const localVarPath = `/api/gamemaster/world-sub-locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsDeactivateCreate: async (id: string, subLocationRequest: SubLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsDeactivateCreate', 'id', id)
            // verify required parameter 'subLocationRequest' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsDeactivateCreate', 'subLocationRequest', subLocationRequest)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/deactivate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsList: async (isActive?: boolean, location?: string, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-sub-locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {PatchedSubLocationRequest} [patchedSubLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsPartialUpdate: async (id: string, patchedSubLocationRequest?: PatchedSubLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSubLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all positions within this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsPositionsList: async (id: string, isActive?: boolean, location?: string, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsPositionsList', 'id', id)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/positions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistics about this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsStatsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsStatsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/stats/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsUpdate: async (id: string, subLocationRequest: SubLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsUpdate', 'id', id)
            // verify required parameter 'subLocationRequest' is not null or undefined
            assertParamExists('gamemasterWorldSubLocationsUpdate', 'subLocationRequest', subLocationRequest)
            const localVarPath = `/api/gamemaster/world-sub-locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GMWorldEditorSubLocationsApi - functional programming interface
 * @export
 */
export const GMWorldEditorSubLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GMWorldEditorSubLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsActivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsActivateCreate(id, subLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsActivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsCreate(subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsCreate(subLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsDeactivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsDeactivateCreate(id, subLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsDeactivateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsList(isActive?: boolean, location?: string, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsList(isActive, location, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {PatchedSubLocationRequest} [patchedSubLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsPartialUpdate(id: string, patchedSubLocationRequest?: PatchedSubLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsPartialUpdate(id, patchedSubLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all positions within this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsPositionsList(id: string, isActive?: boolean, location?: string, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsPositionsList(id, isActive, location, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsPositionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get statistics about this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsStatsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldSubLocationsUpdate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldSubLocationsUpdate(id, subLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GMWorldEditorSubLocationsApi.gamemasterWorldSubLocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GMWorldEditorSubLocationsApi - factory interface
 * @export
 */
export const GMWorldEditorSubLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GMWorldEditorSubLocationsApiFp(configuration)
    return {
        /**
         * Activate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsActivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsActivateCreate(id, subLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsCreate(subLocationRequest: SubLocationRequest, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsCreate(subLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsDeactivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsDeactivateCreate(id, subLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldSubLocationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsList(isActive?: boolean, location?: string, ordering?: string, search?: string, options?: any): AxiosPromise<Array<SubLocation>> {
            return localVarFp.gamemasterWorldSubLocationsList(isActive, location, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {PatchedSubLocationRequest} [patchedSubLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsPartialUpdate(id: string, patchedSubLocationRequest?: PatchedSubLocationRequest, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsPartialUpdate(id, patchedSubLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all positions within this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {boolean} [isActive] 
         * @param {string} [location] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsPositionsList(id: string, isActive?: boolean, location?: string, ordering?: string, search?: string, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.gamemasterWorldSubLocationsPositionsList(id, isActive, location, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsRetrieve(id: string, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistics about this sub-location
         * @param {string} id A UUID string identifying this sub location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsStatsRetrieve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldSubLocationsStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API for managing sub-locations in the world
         * @param {string} id A UUID string identifying this sub location.
         * @param {SubLocationRequest} subLocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldSubLocationsUpdate(id: string, subLocationRequest: SubLocationRequest, options?: any): AxiosPromise<SubLocation> {
            return localVarFp.gamemasterWorldSubLocationsUpdate(id, subLocationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GMWorldEditorSubLocationsApi - object-oriented interface
 * @export
 * @class GMWorldEditorSubLocationsApi
 * @extends {BaseAPI}
 */
export class GMWorldEditorSubLocationsApi extends BaseAPI {
    /**
     * Activate a sub-location
     * @param {string} id A UUID string identifying this sub location.
     * @param {SubLocationRequest} subLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsActivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsActivateCreate(id, subLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {SubLocationRequest} subLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsCreate(subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsCreate(subLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a sub-location
     * @param {string} id A UUID string identifying this sub location.
     * @param {SubLocationRequest} subLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsDeactivateCreate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsDeactivateCreate(id, subLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {string} id A UUID string identifying this sub location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {boolean} [isActive] 
     * @param {string} [location] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsList(isActive?: boolean, location?: string, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsList(isActive, location, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {string} id A UUID string identifying this sub location.
     * @param {PatchedSubLocationRequest} [patchedSubLocationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsPartialUpdate(id: string, patchedSubLocationRequest?: PatchedSubLocationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsPartialUpdate(id, patchedSubLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all positions within this sub-location
     * @param {string} id A UUID string identifying this sub location.
     * @param {boolean} [isActive] 
     * @param {string} [location] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsPositionsList(id: string, isActive?: boolean, location?: string, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsPositionsList(id, isActive, location, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {string} id A UUID string identifying this sub location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistics about this sub-location
     * @param {string} id A UUID string identifying this sub location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsStatsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for managing sub-locations in the world
     * @param {string} id A UUID string identifying this sub location.
     * @param {SubLocationRequest} subLocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GMWorldEditorSubLocationsApi
     */
    public gamemasterWorldSubLocationsUpdate(id: string, subLocationRequest: SubLocationRequest, options?: RawAxiosRequestConfig) {
        return GMWorldEditorSubLocationsApiFp(this.configuration).gamemasterWorldSubLocationsUpdate(id, subLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GalleryApi - axios parameter creator
 * @export
 */
export const GalleryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gallery/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('galleryWorldRetrieve', 'id', id)
            const localVarPath = `/api/gallery/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GalleryApi - functional programming interface
 * @export
 */
export const GalleryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GalleryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Art>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Art>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GalleryApi - factory interface
 * @export
 */
export const GalleryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GalleryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList(options?: any): AxiosPromise<Array<Art>> {
            return localVarFp.galleryWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve(id: string, options?: any): AxiosPromise<Art> {
            return localVarFp.galleryWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GalleryApi - object-oriented interface
 * @export
 * @class GalleryApi
 * @extends {BaseAPI}
 */
export class GalleryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldList(options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this art.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GamemasterApi - axios parameter creator
 * @export
 */
export const GamemasterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new challenge for a character
         * @summary Create Challenge
         * @param {GameMasterCreateChallengeRequest} gameMasterCreateChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesCreateCreate: async (gameMasterCreateChallengeRequest: GameMasterCreateChallengeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMasterCreateChallengeRequest' is not null or undefined
            assertParamExists('gamemasterChallengesCreateCreate', 'gameMasterCreateChallengeRequest', gameMasterCreateChallengeRequest)
            const localVarPath = `/api/gamemaster/challenges/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCreateChallengeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/challenges/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterChallengesRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/challenges/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an NPC from a template.  This action creates a new NPC based on the specified template and position. It requires template_id and position_id parameters.
         * @param {CreateNPCFromTemplateRequest} createNPCFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesCreateNpcCreate: async (createNPCFromTemplateRequest: CreateNPCFromTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNPCFromTemplateRequest' is not null or undefined
            assertParamExists('gamemasterCharacterTemplatesCreateNpcCreate', 'createNPCFromTemplateRequest', createNPCFromTemplateRequest)
            const localVarPath = `/api/gamemaster/character-templates/create_npc/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNPCFromTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export a character template as JSON. Game Master access only.
         * @summary Export Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesExportTemplateRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterTemplatesExportTemplateRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/character-templates/{id}/export_template/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {GamemasterCharacterTemplatesListBehaviorEnum} [behavior] * &#x60;Passive&#x60; - Passive * &#x60;Aggressive&#x60; - Aggressive * &#x60;Friendly&#x60; - Friendly
         * @param {number} [dimension] 
         * @param {string} [name] 
         * @param {string} [organization] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [path] 
         * @param {string} [rank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesList: async (behavior?: GamemasterCharacterTemplatesListBehaviorEnum, dimension?: number, name?: string, organization?: string, page?: number, pageSize?: number, path?: string, rank?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/character-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (rank !== undefined) {
                localVarQueryParameter['rank'] = rank;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allow to se what NPC will be created from the template.
         * @summary Preview Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesPreviewRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterTemplatesPreviewRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/character-templates/{id}/preview/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterTemplatesRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/character-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get character information for the GameMasterCharacterCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterCardRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterCardRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_card/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterInfoRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get character stats for the GameMasterCharacterStatsCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsCardRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterStatsCardRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_stats_card/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterStatsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_stats/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a god intervention on a character.  This action allows game masters to apply a god intervention effect to a character, which can include stat modifications, effects, or other game mechanics.  The request should contain the necessary parameters for the intervention.
         * @param {string} id A UUID string identifying this character.
         * @param {GodInterventionRequest} godInterventionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersGodInterventionCreate: async (id: string, godInterventionRequest: GodInterventionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersGodInterventionCreate', 'id', id)
            // verify required parameter 'godInterventionRequest' is not null or undefined
            assertParamExists('gamemasterCharactersGodInterventionCreate', 'godInterventionRequest', godInterventionRequest)
            const localVarPath = `/api/gamemaster/characters/{id}/god_intervention/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(godInterventionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/characters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCloneCreate: async (id: string, gameObjectRequest: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsCloneCreate', 'id', id)
            // verify required parameter 'gameObjectRequest' is not null or undefined
            assertParamExists('gamemasterGameObjectsCloneCreate', 'gameObjectRequest', gameObjectRequest)
            const localVarPath = `/api/gamemaster/game-objects/{id}/clone/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCreate: async (gameObjectRequest: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameObjectRequest' is not null or undefined
            assertParamExists('gamemasterGameObjectsCreate', 'gameObjectRequest', gameObjectRequest)
            const localVarPath = `/api/gamemaster/game-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsList: async (campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/game-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (positionGridZ !== undefined) {
                localVarQueryParameter['position_grid_z'] = positionGridZ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsMoveCreate: async (id: string, gameObjectRequest: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsMoveCreate', 'id', id)
            // verify required parameter 'gameObjectRequest' is not null or undefined
            assertParamExists('gamemasterGameObjectsMoveCreate', 'gameObjectRequest', gameObjectRequest)
            const localVarPath = `/api/gamemaster/game-objects/{id}/move/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsPartialUpdate: async (id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsToggleActiveCreate: async (id: string, gameObjectRequest: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsToggleActiveCreate', 'id', id)
            // verify required parameter 'gameObjectRequest' is not null or undefined
            assertParamExists('gamemasterGameObjectsToggleActiveCreate', 'gameObjectRequest', gameObjectRequest)
            const localVarPath = `/api/gamemaster/game-objects/{id}/toggle_active/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsUpdate: async (id: string, gameObjectRequest: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsUpdate', 'id', id)
            // verify required parameter 'gameObjectRequest' is not null or undefined
            assertParamExists('gamemasterGameObjectsUpdate', 'gameObjectRequest', gameObjectRequest)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a login token for a user based on a character ID
         * @param {ImpersonationRequestRequest} impersonationRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterImpersonationImpersonateCreate: async (impersonationRequestRequest: ImpersonationRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'impersonationRequestRequest' is not null or undefined
            assertParamExists('gamemasterImpersonationImpersonateCreate', 'impersonationRequestRequest', impersonationRequestRequest)
            const localVarPath = `/api/gamemaster/impersonation/impersonate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(impersonationRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterItemsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the behavior of an NPC.  This action changes the behavior of the specified NPC. It requires the behavior parameter.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedNPCBehaviorRequest} [patchedNPCBehaviorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterNpcsChangeBehaviorPartialUpdate: async (id: string, patchedNPCBehaviorRequest?: PatchedNPCBehaviorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterNpcsChangeBehaviorPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/npcs/{id}/change_behavior/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNPCBehaviorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/skill/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows game masters to create a new skill using the skill factory service. The skill will be created with the provided data and returned in the response.
         * @summary Create a new skill
         * @param {SkillCreateRequest} skillCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillNewSkillCreate: async (skillCreateRequest: SkillCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skillCreateRequest' is not null or undefined
            assertParamExists('gamemasterSkillNewSkillCreate', 'skillCreateRequest', skillCreateRequest)
            const localVarPath = `/api/gamemaster/skill/new_skill/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skillCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSkillRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/skill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all position connections, optionally filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapConnectionsRetrieve: async (gridZ?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-map/connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gridZ !== undefined) {
                localVarQueryParameter['grid_z'] = gridZ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreate: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldMapCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new connection between two positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreateConnectionCreate: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldMapCreateConnectionCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-map/create_connection/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new position and automatically connect it to nearby positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreatePositionWithConnectionsCreate: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldMapCreatePositionWithConnectionsCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-map/create_position_with_connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapDeleteConnectionDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapDeleteConnectionDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-map/{id}/delete_connection/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-map/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapList: async (gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gridZ !== undefined) {
                localVarQueryParameter['grid_z'] = gridZ;
            }

            if (isSafe !== undefined) {
                localVarQueryParameter['is_safe'] = isSafe;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (subLocation !== undefined) {
                localVarQueryParameter['sub_location'] = subLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a complete map structure with positions and connections filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapMapRetrieve: async (gridZ?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-map/map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gridZ !== undefined) {
                localVarQueryParameter['grid_z'] = gridZ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapPartialUpdate: async (id: string, patchedPositionRequest?: PatchedPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/world-map/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-map/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock or unlock a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapToggleConnectionLockCreate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapToggleConnectionLockCreate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldMapToggleConnectionLockCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-map/{id}/toggle_connection_lock/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapUpdate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldMapUpdate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterWorldMapUpdate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/world-map/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spawnItem: async (id: string, spawnItemRequest?: SpawnItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spawnItem', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/spawn_item/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spawnItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GamemasterApi - functional programming interface
 * @export
 */
export const GamemasterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GamemasterApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new challenge for a character
         * @summary Create Challenge
         * @param {GameMasterCreateChallengeRequest} gameMasterCreateChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest: GameMasterCreateChallengeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterChallengeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterChallengesCreateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterChallengesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameMasterChallengeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterChallengesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterChallengesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterChallengesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterChallengeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterChallengesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterChallengesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an NPC from a template.  This action creates a new NPC based on the specified template and position. It requires template_id and position_id parameters.
         * @param {CreateNPCFromTemplateRequest} createNPCFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest: CreateNPCFromTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNPCFromTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterTemplatesCreateNpcCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export a character template as JSON. Game Master access only.
         * @summary Export Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterTemplatesExportTemplateRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterTemplateFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterTemplatesExportTemplateRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterTemplatesExportTemplateRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {GamemasterCharacterTemplatesListBehaviorEnum} [behavior] * &#x60;Passive&#x60; - Passive * &#x60;Aggressive&#x60; - Aggressive * &#x60;Friendly&#x60; - Friendly
         * @param {number} [dimension] 
         * @param {string} [name] 
         * @param {string} [organization] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [path] 
         * @param {string} [rank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterTemplatesList(behavior?: GamemasterCharacterTemplatesListBehaviorEnum, dimension?: number, name?: string, organization?: string, page?: number, pageSize?: number, path?: string, rank?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCharacterTemplateGameMasterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterTemplatesList(behavior, dimension, name, organization, page, pageSize, path, rank, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterTemplatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allow to se what NPC will be created from the template.
         * @summary Preview Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterTemplatesPreviewRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterTemplatesPreviewRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterTemplatesPreviewRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterTemplatesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterTemplateGameMaster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterTemplatesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterTemplatesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get character information for the GameMasterCharacterCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterCardRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterCardRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterCardRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get character stats for the GameMasterCharacterStatsCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterStatsCardRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterStatsCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterStatsCardRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterStatsCardRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterStatsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a god intervention on a character.  This action allows game masters to apply a god intervention effect to a character, which can include stat modifications, effects, or other game mechanics.  The request should contain the necessary parameters for the intervention.
         * @param {string} id A UUID string identifying this character.
         * @param {GodInterventionRequest} godInterventionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersGodInterventionCreate(id: string, godInterventionRequest: GodInterventionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GodIntervention>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersGodInterventionCreate(id, godInterventionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersGodInterventionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsCloneCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsCreate(gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsCreate(gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsMoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsToggleActiveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsUpdate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsUpdate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a login token for a user based on a character ID
         * @param {ImpersonationRequestRequest} impersonationRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterImpersonationImpersonateCreate(impersonationRequestRequest: ImpersonationRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImpersonationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterImpersonationImpersonateCreate(impersonationRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterImpersonationImpersonateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameMasterItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the behavior of an NPC.  This action changes the behavior of the specified NPC. It requires the behavior parameter.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedNPCBehaviorRequest} [patchedNPCBehaviorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterNpcsChangeBehaviorPartialUpdate(id: string, patchedNPCBehaviorRequest?: PatchedNPCBehaviorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterNpcsChangeBehaviorPartialUpdate(id, patchedNPCBehaviorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterNpcsChangeBehaviorPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Skill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows game masters to create a new skill using the skill factory service. The skill will be created with the provided data and returned in the response.
         * @summary Create a new skill
         * @param {SkillCreateRequest} skillCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillNewSkillCreate(skillCreateRequest: SkillCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillNewSkillCreate(skillCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillNewSkillCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all position connections, optionally filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapConnectionsRetrieve(gridZ?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapConnectionsRetrieve(gridZ, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapConnectionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapCreate(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new connection between two positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapCreateConnectionCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapCreateConnectionCreate(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapCreateConnectionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new position and automatically connect it to nearby positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapCreatePositionWithConnectionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapDeleteConnectionDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapDeleteConnectionDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapDeleteConnectionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapList(gridZ, isSafe, ordering, subLocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a complete map structure with positions and connections filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapMapRetrieve(gridZ?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapMapRetrieve(gridZ, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapPartialUpdate(id, patchedPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lock or unlock a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapToggleConnectionLockCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapToggleConnectionLockCreate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapToggleConnectionLockCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldMapUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldMapUpdate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldMapUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spawnItem(id, spawnItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.spawnItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GamemasterApi - factory interface
 * @export
 */
export const GamemasterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GamemasterApiFp(configuration)
    return {
        /**
         * Create a new challenge for a character
         * @summary Create Challenge
         * @param {GameMasterCreateChallengeRequest} gameMasterCreateChallengeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest: GameMasterCreateChallengeRequest, options?: any): AxiosPromise<GameMasterChallengeResponse> {
            return localVarFp.gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesList(options?: any): AxiosPromise<Array<GameMasterChallengeResponse>> {
            return localVarFp.gamemasterChallengesList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
         * @param {string} id A UUID string identifying this challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterChallengesRetrieve(id: string, options?: any): AxiosPromise<GameMasterChallengeResponse> {
            return localVarFp.gamemasterChallengesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an NPC from a template.  This action creates a new NPC based on the specified template and position. It requires template_id and position_id parameters.
         * @param {CreateNPCFromTemplateRequest} createNPCFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest: CreateNPCFromTemplateRequest, options?: any): AxiosPromise<CreateNPCFromTemplate> {
            return localVarFp.gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a character template as JSON. Game Master access only.
         * @summary Export Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesExportTemplateRetrieve(id: string, options?: any): AxiosPromise<CharacterTemplateFull> {
            return localVarFp.gamemasterCharacterTemplatesExportTemplateRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {GamemasterCharacterTemplatesListBehaviorEnum} [behavior] * &#x60;Passive&#x60; - Passive * &#x60;Aggressive&#x60; - Aggressive * &#x60;Friendly&#x60; - Friendly
         * @param {number} [dimension] 
         * @param {string} [name] 
         * @param {string} [organization] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [path] 
         * @param {string} [rank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesList(behavior?: GamemasterCharacterTemplatesListBehaviorEnum, dimension?: number, name?: string, organization?: string, page?: number, pageSize?: number, path?: string, rank?: string, options?: any): AxiosPromise<PaginatedCharacterTemplateGameMasterList> {
            return localVarFp.gamemasterCharacterTemplatesList(behavior, dimension, name, organization, page, pageSize, path, rank, options).then((request) => request(axios, basePath));
        },
        /**
         * Allow to se what NPC will be created from the template.
         * @summary Preview Character Template
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesPreviewRetrieve(id: string, options?: any): AxiosPromise<GameMasterCharacterInfo> {
            return localVarFp.gamemasterCharacterTemplatesPreviewRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
         * @param {string} id A UUID string identifying this Character Template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterTemplatesRetrieve(id: string, options?: any): AxiosPromise<CharacterTemplateGameMaster> {
            return localVarFp.gamemasterCharacterTemplatesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get character information for the GameMasterCharacterCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterCardRetrieve(id: string, options?: any): AxiosPromise<GameMasterCharacterInfo> {
            return localVarFp.gamemasterCharactersCharacterCardRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterInfoRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersCharacterInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get character stats for the GameMasterCharacterStatsCard component
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsCardRetrieve(id: string, options?: any): AxiosPromise<GameMasterCharacterStatsCard> {
            return localVarFp.gamemasterCharactersCharacterStatsCardRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsRetrieve(id: string, options?: any): AxiosPromise<CharacterStats> {
            return localVarFp.gamemasterCharactersCharacterStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a god intervention on a character.  This action allows game masters to apply a god intervention effect to a character, which can include stat modifications, effects, or other game mechanics.  The request should contain the necessary parameters for the intervention.
         * @param {string} id A UUID string identifying this character.
         * @param {GodInterventionRequest} godInterventionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersGodInterventionCreate(id: string, godInterventionRequest: GodInterventionRequest, options?: any): AxiosPromise<GodIntervention> {
            return localVarFp.gamemasterCharactersGodInterventionCreate(id, godInterventionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<CharacterInfo>> {
            return localVarFp.gamemasterCharactersList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCreate(gameObjectRequest: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsCreate(gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterGameObjectsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: any): AxiosPromise<Array<GameObject>> {
            return localVarFp.gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options).then((request) => request(axios, basePath));
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsRetrieve(id: string, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} gameObjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsUpdate(id: string, gameObjectRequest: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsUpdate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a login token for a user based on a character ID
         * @param {ImpersonationRequestRequest} impersonationRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterImpersonationImpersonateCreate(impersonationRequestRequest: ImpersonationRequestRequest, options?: any): AxiosPromise<ImpersonationResponse> {
            return localVarFp.gamemasterImpersonationImpersonateCreate(impersonationRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsList(options?: any): AxiosPromise<Array<GameMasterItem>> {
            return localVarFp.gamemasterItemsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsRetrieve(id: string, options?: any): AxiosPromise<GameMasterItem> {
            return localVarFp.gamemasterItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the behavior of an NPC.  This action changes the behavior of the specified NPC. It requires the behavior parameter.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedNPCBehaviorRequest} [patchedNPCBehaviorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterNpcsChangeBehaviorPartialUpdate(id: string, patchedNPCBehaviorRequest?: PatchedNPCBehaviorRequest, options?: any): AxiosPromise<GameMasterCharacterInfo> {
            return localVarFp.gamemasterNpcsChangeBehaviorPartialUpdate(id, patchedNPCBehaviorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillList(options?: any): AxiosPromise<Array<Skill>> {
            return localVarFp.gamemasterSkillList(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows game masters to create a new skill using the skill factory service. The skill will be created with the provided data and returned in the response.
         * @summary Create a new skill
         * @param {SkillCreateRequest} skillCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillNewSkillCreate(skillCreateRequest: SkillCreateRequest, options?: any): AxiosPromise<Skill> {
            return localVarFp.gamemasterSkillNewSkillCreate(skillCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillRetrieve(id: string, options?: any): AxiosPromise<Skill> {
            return localVarFp.gamemasterSkillRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all position connections, optionally filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapConnectionsRetrieve(gridZ?: number, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapConnectionsRetrieve(gridZ, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreate(positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapCreate(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new connection between two positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreateConnectionCreate(positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapCreateConnectionCreate(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new position and automatically connect it to nearby positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapDeleteConnectionDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldMapDeleteConnectionDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldMapDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {number} [gridZ] 
         * @param {boolean} [isSafe] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [subLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.gamemasterWorldMapList(gridZ, isSafe, ordering, subLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a complete map structure with positions and connections filtered by grid_z.
         * @param {number} [gridZ] Filter by grid_z coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapMapRetrieve(gridZ?: number, options?: any): AxiosPromise<MapResponse> {
            return localVarFp.gamemasterWorldMapMapRetrieve(gridZ, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapPartialUpdate(id, patchedPositionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapRetrieve(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lock or unlock a connection between this position and another position.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapToggleConnectionLockCreate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapToggleConnectionLockCreate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldMapUpdate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterWorldMapUpdate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.spawnItem(id, spawnItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GamemasterApi - object-oriented interface
 * @export
 * @class GamemasterApi
 * @extends {BaseAPI}
 */
export class GamemasterApi extends BaseAPI {
    /**
     * Create a new challenge for a character
     * @summary Create Challenge
     * @param {GameMasterCreateChallengeRequest} gameMasterCreateChallengeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest: GameMasterCreateChallengeRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterChallengesCreateCreate(gameMasterCreateChallengeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterChallengesList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterChallengesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for GameMasters to create and manage challenges for characters.  This viewset provides functionality for GameMasters to: - Create new challenges for characters - View existing challenges - Configure challenge parameters including difficulty, dice, modifiers, and advantage/disadvantage  The challenge creation process includes business logic that automatically adds modifiers based on character state, stats, effects, skills, and items.
     * @param {string} id A UUID string identifying this challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterChallengesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterChallengesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an NPC from a template.  This action creates a new NPC based on the specified template and position. It requires template_id and position_id parameters.
     * @param {CreateNPCFromTemplateRequest} createNPCFromTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest: CreateNPCFromTemplateRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterTemplatesCreateNpcCreate(createNPCFromTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export a character template as JSON. Game Master access only.
     * @summary Export Character Template
     * @param {string} id A UUID string identifying this Character Template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterTemplatesExportTemplateRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterTemplatesExportTemplateRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
     * @param {GamemasterCharacterTemplatesListBehaviorEnum} [behavior] * &#x60;Passive&#x60; - Passive * &#x60;Aggressive&#x60; - Aggressive * &#x60;Friendly&#x60; - Friendly
     * @param {number} [dimension] 
     * @param {string} [name] 
     * @param {string} [organization] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [path] 
     * @param {string} [rank] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterTemplatesList(behavior?: GamemasterCharacterTemplatesListBehaviorEnum, dimension?: number, name?: string, organization?: string, page?: number, pageSize?: number, path?: string, rank?: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterTemplatesList(behavior, dimension, name, organization, page, pageSize, path, rank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allow to se what NPC will be created from the template.
     * @summary Preview Character Template
     * @param {string} id A UUID string identifying this Character Template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterTemplatesPreviewRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterTemplatesPreviewRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to view character templates and create NPCs from them.  This viewset provides read-only operations for character templates and an action to create NPCs from templates.
     * @param {string} id A UUID string identifying this Character Template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterTemplatesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterTemplatesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get character information for the GameMasterCharacterCard component
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterCardRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterCardRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a character.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get character stats for the GameMasterCharacterStatsCard component
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterStatsCardRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterStatsCardRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get character stats.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterStatsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a god intervention on a character.  This action allows game masters to apply a god intervention effect to a character, which can include stat modifications, effects, or other game mechanics.  The request should contain the necessary parameters for the intervention.
     * @param {string} id A UUID string identifying this character.
     * @param {GodInterventionRequest} godInterventionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersGodInterventionCreate(id: string, godInterventionRequest: GodInterventionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersGodInterventionCreate(id, godInterventionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clone a game object.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} gameObjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {GameObjectRequest} gameObjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsCreate(gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsCreate(gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} [campaign] 
     * @param {number} [dimension] 
     * @param {boolean} [isActive] 
     * @param {string} [objectType] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [positionGridZ] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move a game object to a new position.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} gameObjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle the active status of a game object.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} gameObjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} gameObjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsUpdate(id: string, gameObjectRequest: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsUpdate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a login token for a user based on a character ID
     * @param {ImpersonationRequestRequest} impersonationRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterImpersonationImpersonateCreate(impersonationRequestRequest: ImpersonationRequestRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterImpersonationImpersonateCreate(impersonationRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {string} id A UUID string identifying this item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the behavior of an NPC.  This action changes the behavior of the specified NPC. It requires the behavior parameter.
     * @param {string} id A UUID string identifying this character.
     * @param {PatchedNPCBehaviorRequest} [patchedNPCBehaviorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterNpcsChangeBehaviorPartialUpdate(id: string, patchedNPCBehaviorRequest?: PatchedNPCBehaviorRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterNpcsChangeBehaviorPartialUpdate(id, patchedNPCBehaviorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows game masters to create a new skill using the skill factory service. The skill will be created with the provided data and returned in the response.
     * @summary Create a new skill
     * @param {SkillCreateRequest} skillCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillNewSkillCreate(skillCreateRequest: SkillCreateRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillNewSkillCreate(skillCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to create skills dynamically during gameplay. Provides skill factory functionality with comprehensive validation and documentation.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all position connections, optionally filtered by grid_z.
     * @param {number} [gridZ] Filter by grid_z coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapConnectionsRetrieve(gridZ?: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapConnectionsRetrieve(gridZ, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapCreate(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new connection between two positions.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapCreateConnectionCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapCreateConnectionCreate(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new position and automatically connect it to nearby positions.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapCreatePositionWithConnectionsCreate(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a connection between this position and another position.
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapDeleteConnectionDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapDeleteConnectionDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {number} [gridZ] 
     * @param {boolean} [isSafe] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [subLocation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapList(gridZ?: number, isSafe?: boolean, ordering?: string, subLocation?: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapList(gridZ, isSafe, ordering, subLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a complete map structure with positions and connections filtered by grid_z.
     * @param {number} [gridZ] Filter by grid_z coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapMapRetrieve(gridZ?: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapMapRetrieve(gridZ, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {string} id A UUID string identifying this position.
     * @param {PatchedPositionRequest} [patchedPositionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapPartialUpdate(id, patchedPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lock or unlock a connection between this position and another position.
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapToggleConnectionLockCreate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapToggleConnectionLockCreate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage the world map.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting positions - Filtering positions by grid_z - Managing position connections - Creating positions with automatic connections to nearby positions - Locking/unlocking connections
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldMapUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldMapUpdate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
     * @param {string} id A UUID string identifying this item.
     * @param {SpawnItemRequest} [spawnItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).spawnItem(id, spawnItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GamemasterCharacterTemplatesListBehaviorEnum = {
    Aggressive: 'Aggressive',
    Friendly: 'Friendly',
    Passive: 'Passive'
} as const;
export type GamemasterCharacterTemplatesListBehaviorEnum = typeof GamemasterCharacterTemplatesListBehaviorEnum[keyof typeof GamemasterCharacterTemplatesListBehaviorEnum];


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/items/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate: async (worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('itemsWorldCreate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldDestroy', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate: async (id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldRetrieve', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate: async (id: string, worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'id', id)
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spawnItem: async (id: string, spawnItemRequest?: SpawnItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spawnItem', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/spawn_item/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spawnItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldCreate(worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorldItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldPartialUpdate(id, patchedWorldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldUpdate(id, worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spawnItem(id, spawnItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.spawnItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList(options?: any): AxiosPromise<Array<CharacterItem>> {
            return localVarFp.itemsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.itemsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldCreate(worldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList(options?: any): AxiosPromise<Array<WorldItem>> {
            return localVarFp.itemsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve(id: string, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldUpdate(id, worldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
         * @param {string} id A UUID string identifying this item.
         * @param {SpawnItemRequest} [spawnItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.spawnItem(id, spawnItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldCreate(worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldUpdate(id, worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Spawn an item in the game world. Creates a WorldItem instance from the Item and optionally assigns it to a character.
     * @param {string} id A UUID string identifying this item.
     * @param {SpawnItemRequest} [spawnItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public spawnItem(id: string, spawnItemRequest?: SpawnItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).spawnItem(id, spawnItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KnowledgeBaseDocumentsApi - axios parameter creator
 * @export
 */
export const KnowledgeBaseDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new knowledge base document. Requires admin privileges. You can optionally assign categories to the document.
         * @summary Create a new document
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsCreate: async (documentRequest: DocumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentRequest' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsCreate', 'documentRequest', documentRequest)
            const localVarPath = `/api/knowledge-base/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a knowledge base document. Requires admin privileges. This will also delete all associated timeline events.
         * @summary Delete a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsDestroy', 'id', id)
            const localVarPath = `/api/knowledge-base/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of all knowledge base documents. Supports filtering by title, content, and categories. Supports searching across title and content fields. Supports ordering by id, title, created_at, and updated_at.
         * @summary List all documents
         * @param {string} [categories] Filter by category name (exact match)
         * @param {string} [content] Filter by content (case-insensitive partial match)
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across title and content fields
         * @param {string} [title] Filter by title (case-insensitive partial match)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsList: async (categories?: string, content?: string, ordering?: string, page?: number, pageSize?: number, search?: string, title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/knowledge-base/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update specific fields of an existing knowledge base document. Requires admin privileges.
         * @summary Partially update a document
         * @param {string} id A UUID string identifying this document.
         * @param {PatchedDocumentRequest} [patchedDocumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsPartialUpdate: async (id: string, patchedDocumentRequest?: PatchedDocumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsPartialUpdate', 'id', id)
            const localVarPath = `/api/knowledge-base/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDocumentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific knowledge base document by its ID.
         * @summary Retrieve a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsRetrieve', 'id', id)
            const localVarPath = `/api/knowledge-base/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all fields of an existing knowledge base document. Requires admin privileges.
         * @summary Update a document
         * @param {string} id A UUID string identifying this document.
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsUpdate: async (id: string, documentRequest: DocumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsUpdate', 'id', id)
            // verify required parameter 'documentRequest' is not null or undefined
            assertParamExists('knowledgeBaseDocumentsUpdate', 'documentRequest', documentRequest)
            const localVarPath = `/api/knowledge-base/documents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgeBaseDocumentsApi - functional programming interface
 * @export
 */
export const KnowledgeBaseDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgeBaseDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new knowledge base document. Requires admin privileges. You can optionally assign categories to the document.
         * @summary Create a new document
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsCreate(documentRequest: DocumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsCreate(documentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a knowledge base document. Requires admin privileges. This will also delete all associated timeline events.
         * @summary Delete a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of all knowledge base documents. Supports filtering by title, content, and categories. Supports searching across title and content fields. Supports ordering by id, title, created_at, and updated_at.
         * @summary List all documents
         * @param {string} [categories] Filter by category name (exact match)
         * @param {string} [content] Filter by content (case-insensitive partial match)
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across title and content fields
         * @param {string} [title] Filter by title (case-insensitive partial match)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsList(categories?: string, content?: string, ordering?: string, page?: number, pageSize?: number, search?: string, title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDocumentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsList(categories, content, ordering, page, pageSize, search, title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update specific fields of an existing knowledge base document. Requires admin privileges.
         * @summary Partially update a document
         * @param {string} id A UUID string identifying this document.
         * @param {PatchedDocumentRequest} [patchedDocumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsPartialUpdate(id: string, patchedDocumentRequest?: PatchedDocumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsPartialUpdate(id, patchedDocumentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific knowledge base document by its ID.
         * @summary Retrieve a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update all fields of an existing knowledge base document. Requires admin privileges.
         * @summary Update a document
         * @param {string} id A UUID string identifying this document.
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDocumentsUpdate(id: string, documentRequest: DocumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDocumentsUpdate(id, documentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseDocumentsApi.knowledgeBaseDocumentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KnowledgeBaseDocumentsApi - factory interface
 * @export
 */
export const KnowledgeBaseDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgeBaseDocumentsApiFp(configuration)
    return {
        /**
         * Create a new knowledge base document. Requires admin privileges. You can optionally assign categories to the document.
         * @summary Create a new document
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsCreate(documentRequest: DocumentRequest, options?: any): AxiosPromise<Document> {
            return localVarFp.knowledgeBaseDocumentsCreate(documentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a knowledge base document. Requires admin privileges. This will also delete all associated timeline events.
         * @summary Delete a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.knowledgeBaseDocumentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of all knowledge base documents. Supports filtering by title, content, and categories. Supports searching across title and content fields. Supports ordering by id, title, created_at, and updated_at.
         * @summary List all documents
         * @param {string} [categories] Filter by category name (exact match)
         * @param {string} [content] Filter by content (case-insensitive partial match)
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across title and content fields
         * @param {string} [title] Filter by title (case-insensitive partial match)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsList(categories?: string, content?: string, ordering?: string, page?: number, pageSize?: number, search?: string, title?: string, options?: any): AxiosPromise<PaginatedDocumentList> {
            return localVarFp.knowledgeBaseDocumentsList(categories, content, ordering, page, pageSize, search, title, options).then((request) => request(axios, basePath));
        },
        /**
         * Update specific fields of an existing knowledge base document. Requires admin privileges.
         * @summary Partially update a document
         * @param {string} id A UUID string identifying this document.
         * @param {PatchedDocumentRequest} [patchedDocumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsPartialUpdate(id: string, patchedDocumentRequest?: PatchedDocumentRequest, options?: any): AxiosPromise<Document> {
            return localVarFp.knowledgeBaseDocumentsPartialUpdate(id, patchedDocumentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific knowledge base document by its ID.
         * @summary Retrieve a document
         * @param {string} id A UUID string identifying this document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsRetrieve(id: string, options?: any): AxiosPromise<Document> {
            return localVarFp.knowledgeBaseDocumentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all fields of an existing knowledge base document. Requires admin privileges.
         * @summary Update a document
         * @param {string} id A UUID string identifying this document.
         * @param {DocumentRequest} documentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDocumentsUpdate(id: string, documentRequest: DocumentRequest, options?: any): AxiosPromise<Document> {
            return localVarFp.knowledgeBaseDocumentsUpdate(id, documentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgeBaseDocumentsApi - object-oriented interface
 * @export
 * @class KnowledgeBaseDocumentsApi
 * @extends {BaseAPI}
 */
export class KnowledgeBaseDocumentsApi extends BaseAPI {
    /**
     * Create a new knowledge base document. Requires admin privileges. You can optionally assign categories to the document.
     * @summary Create a new document
     * @param {DocumentRequest} documentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsCreate(documentRequest: DocumentRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsCreate(documentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a knowledge base document. Requires admin privileges. This will also delete all associated timeline events.
     * @summary Delete a document
     * @param {string} id A UUID string identifying this document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of all knowledge base documents. Supports filtering by title, content, and categories. Supports searching across title and content fields. Supports ordering by id, title, created_at, and updated_at.
     * @summary List all documents
     * @param {string} [categories] Filter by category name (exact match)
     * @param {string} [content] Filter by content (case-insensitive partial match)
     * @param {string} [ordering] Order results by field (prefix with - for descending)
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] Search across title and content fields
     * @param {string} [title] Filter by title (case-insensitive partial match)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsList(categories?: string, content?: string, ordering?: string, page?: number, pageSize?: number, search?: string, title?: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsList(categories, content, ordering, page, pageSize, search, title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update specific fields of an existing knowledge base document. Requires admin privileges.
     * @summary Partially update a document
     * @param {string} id A UUID string identifying this document.
     * @param {PatchedDocumentRequest} [patchedDocumentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsPartialUpdate(id: string, patchedDocumentRequest?: PatchedDocumentRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsPartialUpdate(id, patchedDocumentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific knowledge base document by its ID.
     * @summary Retrieve a document
     * @param {string} id A UUID string identifying this document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all fields of an existing knowledge base document. Requires admin privileges.
     * @summary Update a document
     * @param {string} id A UUID string identifying this document.
     * @param {DocumentRequest} documentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseDocumentsApi
     */
    public knowledgeBaseDocumentsUpdate(id: string, documentRequest: DocumentRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseDocumentsApiFp(this.configuration).knowledgeBaseDocumentsUpdate(id, documentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KnowledgeBaseTimelineEventsApi - axios parameter creator
 * @export
 */
export const KnowledgeBaseTimelineEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new timeline event. Requires admin privileges. You must provide existing document_id and date_time_id.
         * @summary Create a new timeline event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/knowledge-base/timeline-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a timeline event. Requires admin privileges. Note: This does not delete the associated document or date_time records.
         * @summary Delete a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseTimelineEventsDestroy', 'id', id)
            const localVarPath = `/api/knowledge-base/timeline-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a timeline event with nested Document and DateTimeInfo data. This action will get_or_create Document and DateTimeInfo based on the provided data, then create the TimeLineEvent linking them together. This is useful for bulk imports or migrations. Note: Image loading is not supported in this action.
         * @summary Import timeline event with nested data
         * @param {TimeLineEventImportRequest} timeLineEventImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsImportEventCreate: async (timeLineEventImportRequest: TimeLineEventImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeLineEventImportRequest' is not null or undefined
            assertParamExists('knowledgeBaseTimelineEventsImportEventCreate', 'timeLineEventImportRequest', timeLineEventImportRequest)
            const localVarPath = `/api/knowledge-base/timeline-events/import_event/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeLineEventImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of all timeline events. Supports filtering by document, active_glow, solar_year, and sol. Supports searching across document title and content. Default ordering is by timeline (solar_year, sol).
         * @summary List all timeline events
         * @param {boolean} [activeGlow] Filter by active_glow (true/false)
         * @param {string} [dateTime] Filter by date_time ID
         * @param {string} [document] Filter by document ID
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across document title and content
         * @param {number} [sol] 
         * @param {number} [solGte] Filter by sol greater than or equal to value
         * @param {number} [solLte] 
         * @param {number} [solarYear] Filter by exact solar year
         * @param {number} [solarYearGte] 
         * @param {number} [solarYearLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsList: async (activeGlow?: boolean, dateTime?: string, document?: string, ordering?: string, page?: number, pageSize?: number, search?: string, sol?: number, solGte?: number, solLte?: number, solarYear?: number, solarYearGte?: number, solarYearLte?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/knowledge-base/timeline-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (activeGlow !== undefined) {
                localVarQueryParameter['active_glow'] = activeGlow;
            }

            if (dateTime !== undefined) {
                localVarQueryParameter['date_time'] = dateTime;
            }

            if (document !== undefined) {
                localVarQueryParameter['document'] = document;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sol !== undefined) {
                localVarQueryParameter['sol'] = sol;
            }

            if (solGte !== undefined) {
                localVarQueryParameter['sol_gte'] = solGte;
            }

            if (solLte !== undefined) {
                localVarQueryParameter['sol_lte'] = solLte;
            }

            if (solarYear !== undefined) {
                localVarQueryParameter['solar_year'] = solarYear;
            }

            if (solarYearGte !== undefined) {
                localVarQueryParameter['solar_year_gte'] = solarYearGte;
            }

            if (solarYearLte !== undefined) {
                localVarQueryParameter['solar_year_lte'] = solarYearLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update specific fields of an existing timeline event. Requires admin privileges.
         * @summary Partially update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsPartialUpdate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseTimelineEventsPartialUpdate', 'id', id)
            const localVarPath = `/api/knowledge-base/timeline-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific timeline event by its ID. Includes related document and date_time information.
         * @summary Retrieve a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseTimelineEventsRetrieve', 'id', id)
            const localVarPath = `/api/knowledge-base/timeline-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all fields of an existing timeline event. Requires admin privileges.
         * @summary Update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsUpdate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseTimelineEventsUpdate', 'id', id)
            const localVarPath = `/api/knowledge-base/timeline-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgeBaseTimelineEventsApi - functional programming interface
 * @export
 */
export const KnowledgeBaseTimelineEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgeBaseTimelineEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new timeline event. Requires admin privileges. You must provide existing document_id and date_time_id.
         * @summary Create a new timeline event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeLineEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a timeline event. Requires admin privileges. Note: This does not delete the associated document or date_time records.
         * @summary Delete a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import a timeline event with nested Document and DateTimeInfo data. This action will get_or_create Document and DateTimeInfo based on the provided data, then create the TimeLineEvent linking them together. This is useful for bulk imports or migrations. Note: Image loading is not supported in this action.
         * @summary Import timeline event with nested data
         * @param {TimeLineEventImportRequest} timeLineEventImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest: TimeLineEventImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeLineEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsImportEventCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of all timeline events. Supports filtering by document, active_glow, solar_year, and sol. Supports searching across document title and content. Default ordering is by timeline (solar_year, sol).
         * @summary List all timeline events
         * @param {boolean} [activeGlow] Filter by active_glow (true/false)
         * @param {string} [dateTime] Filter by date_time ID
         * @param {string} [document] Filter by document ID
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across document title and content
         * @param {number} [sol] 
         * @param {number} [solGte] Filter by sol greater than or equal to value
         * @param {number} [solLte] 
         * @param {number} [solarYear] Filter by exact solar year
         * @param {number} [solarYearGte] 
         * @param {number} [solarYearLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsList(activeGlow?: boolean, dateTime?: string, document?: string, ordering?: string, page?: number, pageSize?: number, search?: string, sol?: number, solGte?: number, solLte?: number, solarYear?: number, solarYearGte?: number, solarYearLte?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTimeLineEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsList(activeGlow, dateTime, document, ordering, page, pageSize, search, sol, solGte, solLte, solarYear, solarYearGte, solarYearLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update specific fields of an existing timeline event. Requires admin privileges.
         * @summary Partially update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsPartialUpdate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeLineEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsPartialUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific timeline event by its ID. Includes related document and date_time information.
         * @summary Retrieve a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeLineEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update all fields of an existing timeline event. Requires admin privileges.
         * @summary Update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseTimelineEventsUpdate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeLineEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseTimelineEventsUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseTimelineEventsApi.knowledgeBaseTimelineEventsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KnowledgeBaseTimelineEventsApi - factory interface
 * @export
 */
export const KnowledgeBaseTimelineEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgeBaseTimelineEventsApiFp(configuration)
    return {
        /**
         * Create a new timeline event. Requires admin privileges. You must provide existing document_id and date_time_id.
         * @summary Create a new timeline event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsCreate(options?: any): AxiosPromise<TimeLineEvent> {
            return localVarFp.knowledgeBaseTimelineEventsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a timeline event. Requires admin privileges. Note: This does not delete the associated document or date_time records.
         * @summary Delete a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.knowledgeBaseTimelineEventsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a timeline event with nested Document and DateTimeInfo data. This action will get_or_create Document and DateTimeInfo based on the provided data, then create the TimeLineEvent linking them together. This is useful for bulk imports or migrations. Note: Image loading is not supported in this action.
         * @summary Import timeline event with nested data
         * @param {TimeLineEventImportRequest} timeLineEventImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest: TimeLineEventImportRequest, options?: any): AxiosPromise<TimeLineEvent> {
            return localVarFp.knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of all timeline events. Supports filtering by document, active_glow, solar_year, and sol. Supports searching across document title and content. Default ordering is by timeline (solar_year, sol).
         * @summary List all timeline events
         * @param {boolean} [activeGlow] Filter by active_glow (true/false)
         * @param {string} [dateTime] Filter by date_time ID
         * @param {string} [document] Filter by document ID
         * @param {string} [ordering] Order results by field (prefix with - for descending)
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] Search across document title and content
         * @param {number} [sol] 
         * @param {number} [solGte] Filter by sol greater than or equal to value
         * @param {number} [solLte] 
         * @param {number} [solarYear] Filter by exact solar year
         * @param {number} [solarYearGte] 
         * @param {number} [solarYearLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsList(activeGlow?: boolean, dateTime?: string, document?: string, ordering?: string, page?: number, pageSize?: number, search?: string, sol?: number, solGte?: number, solLte?: number, solarYear?: number, solarYearGte?: number, solarYearLte?: number, options?: any): AxiosPromise<PaginatedTimeLineEventList> {
            return localVarFp.knowledgeBaseTimelineEventsList(activeGlow, dateTime, document, ordering, page, pageSize, search, sol, solGte, solLte, solarYear, solarYearGte, solarYearLte, options).then((request) => request(axios, basePath));
        },
        /**
         * Update specific fields of an existing timeline event. Requires admin privileges.
         * @summary Partially update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsPartialUpdate(id: string, options?: any): AxiosPromise<TimeLineEvent> {
            return localVarFp.knowledgeBaseTimelineEventsPartialUpdate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific timeline event by its ID. Includes related document and date_time information.
         * @summary Retrieve a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsRetrieve(id: string, options?: any): AxiosPromise<TimeLineEvent> {
            return localVarFp.knowledgeBaseTimelineEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all fields of an existing timeline event. Requires admin privileges.
         * @summary Update a timeline event
         * @param {string} id A UUID string identifying this Timeline Event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseTimelineEventsUpdate(id: string, options?: any): AxiosPromise<TimeLineEvent> {
            return localVarFp.knowledgeBaseTimelineEventsUpdate(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgeBaseTimelineEventsApi - object-oriented interface
 * @export
 * @class KnowledgeBaseTimelineEventsApi
 * @extends {BaseAPI}
 */
export class KnowledgeBaseTimelineEventsApi extends BaseAPI {
    /**
     * Create a new timeline event. Requires admin privileges. You must provide existing document_id and date_time_id.
     * @summary Create a new timeline event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsCreate(options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a timeline event. Requires admin privileges. Note: This does not delete the associated document or date_time records.
     * @summary Delete a timeline event
     * @param {string} id A UUID string identifying this Timeline Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a timeline event with nested Document and DateTimeInfo data. This action will get_or_create Document and DateTimeInfo based on the provided data, then create the TimeLineEvent linking them together. This is useful for bulk imports or migrations. Note: Image loading is not supported in this action.
     * @summary Import timeline event with nested data
     * @param {TimeLineEventImportRequest} timeLineEventImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest: TimeLineEventImportRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsImportEventCreate(timeLineEventImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of all timeline events. Supports filtering by document, active_glow, solar_year, and sol. Supports searching across document title and content. Default ordering is by timeline (solar_year, sol).
     * @summary List all timeline events
     * @param {boolean} [activeGlow] Filter by active_glow (true/false)
     * @param {string} [dateTime] Filter by date_time ID
     * @param {string} [document] Filter by document ID
     * @param {string} [ordering] Order results by field (prefix with - for descending)
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] Search across document title and content
     * @param {number} [sol] 
     * @param {number} [solGte] Filter by sol greater than or equal to value
     * @param {number} [solLte] 
     * @param {number} [solarYear] Filter by exact solar year
     * @param {number} [solarYearGte] 
     * @param {number} [solarYearLte] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsList(activeGlow?: boolean, dateTime?: string, document?: string, ordering?: string, page?: number, pageSize?: number, search?: string, sol?: number, solGte?: number, solLte?: number, solarYear?: number, solarYearGte?: number, solarYearLte?: number, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsList(activeGlow, dateTime, document, ordering, page, pageSize, search, sol, solGte, solLte, solarYear, solarYearGte, solarYearLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update specific fields of an existing timeline event. Requires admin privileges.
     * @summary Partially update a timeline event
     * @param {string} id A UUID string identifying this Timeline Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsPartialUpdate(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsPartialUpdate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific timeline event by its ID. Includes related document and date_time information.
     * @summary Retrieve a timeline event
     * @param {string} id A UUID string identifying this Timeline Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all fields of an existing timeline event. Requires admin privileges.
     * @summary Update a timeline event
     * @param {string} id A UUID string identifying this Timeline Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseTimelineEventsApi
     */
    public knowledgeBaseTimelineEventsUpdate(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseTimelineEventsApiFp(this.configuration).knowledgeBaseTimelineEventsUpdate(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModificatorsApi - axios parameter creator
 * @export
 */
export const ModificatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/modificators/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate: async (modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldCreate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldDestroy', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/get_all_modificators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate: async (id: string, patchedModificatorRequest?: PatchedModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedModificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldRetrieve', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate: async (id: string, modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'id', id)
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModificatorsApi - functional programming interface
 * @export
 */
export const ModificatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModificatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterModificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterModificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldCreate(modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldGetAllModificatorsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldGetAllModificatorsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Modificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldUpdate(id, modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModificatorsApi - factory interface
 * @export
 */
export const ModificatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModificatorsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList(options?: any): AxiosPromise<Array<CharacterModificator>> {
            return localVarFp.modificatorsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterModificator> {
            return localVarFp.modificatorsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldCreate(modificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.modificatorsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve(options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList(options?: any): AxiosPromise<Array<Modificator>> {
            return localVarFp.modificatorsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve(id: string, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModificatorsApi - object-oriented interface
 * @export
 * @class ModificatorsApi
 * @extends {BaseAPI}
 */
export class ModificatorsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldCreate(modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/get_all_paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolPathsRetrieve', 'id', id)
            const localVarPath = `/api/school/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate: async (id: string, openaiSkillRequest: OpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'id', id)
            // verify required parameter 'openaiSkillRequest' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'openaiSkillRequest', openaiSkillRequest)
            const localVarPath = `/api/school/schools/{id}/create_skill/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/school/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsGetAllSchoolSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/get_all_school_skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsList', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve: async (id: string, schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'id', id)
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsGetAllPathsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsGetAllPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPathWithSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsCreateSkillCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSchoolsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSkillsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsList(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsRetrieve(id, schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve(options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.schoolPathsGetAllPathsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList(options?: any): AxiosPromise<Array<OpenaiPath>> {
            return localVarFp.schoolPathsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPathWithSchools> {
            return localVarFp.schoolPathsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList(options?: any): AxiosPromise<Array<OpenaiSchool>> {
            return localVarFp.schoolSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList(schoolPk: string, options?: any): AxiosPromise<Array<OpenaiSkill>> {
            return localVarFp.schoolSchoolsSkillsList(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsGetAllPathsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {OpenaiSkillRequest} openaiSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsList(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShieldsApi - axios parameter creator
 * @export
 */
export const ShieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shields/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shieldsActiveRetrieve', 'id', id)
            const localVarPath = `/api/shields/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsGmActiveList: async (target?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shields/gm/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShieldsApi - functional programming interface
 * @export
 */
export const ShieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveShield>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveShield>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsGmActiveList(target?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveShield>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsGmActiveList(target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsGmActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShieldsApi - factory interface
 * @export
 */
export const ShieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShieldsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList(options?: any): AxiosPromise<Array<ActiveShield>> {
            return localVarFp.shieldsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveShield> {
            return localVarFp.shieldsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsGmActiveList(target?: string, options?: any): AxiosPromise<Array<ActiveShield>> {
            return localVarFp.shieldsGmActiveList(target, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShieldsApi - object-oriented interface
 * @export
 * @class ShieldsApi
 * @extends {BaseAPI}
 */
export class ShieldsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveList(options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active shield.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [target] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsGmActiveList(target?: string, options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsGmActiveList(target, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList: async (character?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/gm/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (character !== undefined) {
                localVarQueryParameter['character'] = character;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsGmSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/gm/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate: async (learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('skillsShoolsCreate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsDestroy', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsRetrieve', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate: async (learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('skillsSkillsCreate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsDestroy', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLearnedSkillList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsList(character, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsCreate(learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsCreate(learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedLearnedSkillList> {
            return localVarFp.skillsGmSkillsList(character, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsGmSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsShoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList(options?: any): AxiosPromise<Array<LearnedSchool>> {
            return localVarFp.skillsShoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve(id: string, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList(options?: any): AxiosPromise<Array<LearnedSkill>> {
            return localVarFp.skillsSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * 
     * @param {string} [character] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsList(character, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoryApi - axios parameter creator
 * @export
 */
export const StoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersCreate: async (chapterRequest: ChapterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chapterRequest' is not null or undefined
            assertParamExists('storyChaptersCreate', 'chapterRequest', chapterRequest)
            const localVarPath = `/api/story/chapters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chapterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyChaptersDestroy', 'id', id)
            const localVarPath = `/api/story/chapters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [story] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersList: async (ordering?: string, story?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/chapters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (story !== undefined) {
                localVarQueryParameter['story'] = story;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {PatchedChapterRequest} [patchedChapterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersPartialUpdate: async (id: string, patchedChapterRequest?: PatchedChapterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyChaptersPartialUpdate', 'id', id)
            const localVarPath = `/api/story/chapters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChapterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyChaptersRetrieve', 'id', id)
            const localVarPath = `/api/story/chapters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersUpdate: async (id: string, chapterRequest: ChapterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyChaptersUpdate', 'id', id)
            // verify required parameter 'chapterRequest' is not null or undefined
            assertParamExists('storyChaptersUpdate', 'chapterRequest', chapterRequest)
            const localVarPath = `/api/story/chapters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chapterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsCreate: async (conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyConditionsDestroy', 'id', id)
            const localVarPath = `/api/story/conditions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {StoryConditionsListTypeEnum} [type] * &#x60;all&#x60; - All * &#x60;any&#x60; - Any * &#x60;none&#x60; - None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsList: async (type?: StoryConditionsListTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {PatchedConditionRequest} [patchedConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsPartialUpdate: async (id: string, patchedConditionRequest?: PatchedConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyConditionsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/conditions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyConditionsRetrieve', 'id', id)
            const localVarPath = `/api/story/conditions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsUpdate: async (id: string, conditionRequest?: ConditionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyConditionsUpdate', 'id', id)
            const localVarPath = `/api/story/conditions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsCreate: async (effectRewardRequest: EffectRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectRewardRequest' is not null or undefined
            assertParamExists('storyEffectRewardsCreate', 'effectRewardRequest', effectRewardRequest)
            const localVarPath = `/api/story/effect-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effectRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyEffectRewardsDestroy', 'id', id)
            const localVarPath = `/api/story/effect-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {StoryEffectRewardsListEffectEnum} [effect] * &#x60;Knocked out&#x60; - Knocked out * &#x60;Coma&#x60; - Coma * &#x60;None&#x60; - None * &#x60;Burning&#x60; - Burning * &#x60;Poisoned&#x60; - Poisoned * &#x60;Sleeping&#x60; - Sleeping * &#x60;Confused&#x60; - Confused * &#x60;Paralyzed&#x60; - Paralyzed * &#x60;Fear&#x60; - Fear * &#x60;Slowness&#x60; - Slowness * &#x60;Cold&#x60; - Cold * &#x60;Cursed&#x60; - Cursed * &#x60;Blindness&#x60; - Blindness * &#x60;Haste&#x60; - Haste * &#x60;Regeneration&#x60; - Regeneration * &#x60;Blessed&#x60; - Blessed * &#x60;Arcane Surge&#x60; - Arcane Surge * &#x60;Marked&#x60; - Marked
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsList: async (effect?: StoryEffectRewardsListEffectEnum, ordering?: string, reward?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/effect-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (effect !== undefined) {
                localVarQueryParameter['effect'] = effect;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (reward !== undefined) {
                localVarQueryParameter['reward'] = reward;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {PatchedEffectRewardRequest} [patchedEffectRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsPartialUpdate: async (id: string, patchedEffectRewardRequest?: PatchedEffectRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyEffectRewardsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/effect-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEffectRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyEffectRewardsRetrieve', 'id', id)
            const localVarPath = `/api/story/effect-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsUpdate: async (id: string, effectRewardRequest: EffectRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyEffectRewardsUpdate', 'id', id)
            // verify required parameter 'effectRewardRequest' is not null or undefined
            assertParamExists('storyEffectRewardsUpdate', 'effectRewardRequest', effectRewardRequest)
            const localVarPath = `/api/story/effect-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effectRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsCreate: async (itemRewardRequest: ItemRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemRewardRequest' is not null or undefined
            assertParamExists('storyItemRewardsCreate', 'itemRewardRequest', itemRewardRequest)
            const localVarPath = `/api/story/item-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyItemRewardsDestroy', 'id', id)
            const localVarPath = `/api/story/item-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} [item] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsList: async (item?: string, ordering?: string, reward?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/item-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (item !== undefined) {
                localVarQueryParameter['item'] = item;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (reward !== undefined) {
                localVarQueryParameter['reward'] = reward;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {PatchedItemRewardRequest} [patchedItemRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsPartialUpdate: async (id: string, patchedItemRewardRequest?: PatchedItemRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyItemRewardsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/item-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedItemRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyItemRewardsRetrieve', 'id', id)
            const localVarPath = `/api/story/item-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsUpdate: async (id: string, itemRewardRequest: ItemRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyItemRewardsUpdate', 'id', id)
            // verify required parameter 'itemRewardRequest' is not null or undefined
            assertParamExists('storyItemRewardsUpdate', 'itemRewardRequest', itemRewardRequest)
            const localVarPath = `/api/story/item-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesCreate: async (noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('storyNotesCreate', 'noteRequest', noteRequest)
            const localVarPath = `/api/story/notes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyNotesDestroy', 'id', id)
            const localVarPath = `/api/story/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [quest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesList: async (ordering?: string, quest?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/notes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (quest !== undefined) {
                localVarQueryParameter['quest'] = quest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {PatchedNoteRequest} [patchedNoteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesPartialUpdate: async (id: string, patchedNoteRequest?: PatchedNoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyNotesPartialUpdate', 'id', id)
            const localVarPath = `/api/story/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyNotesRetrieve', 'id', id)
            const localVarPath = `/api/story/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesUpdate: async (id: string, noteRequest: NoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyNotesUpdate', 'id', id)
            // verify required parameter 'noteRequest' is not null or undefined
            assertParamExists('storyNotesUpdate', 'noteRequest', noteRequest)
            const localVarPath = `/api/story/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(noteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsCreate: async (questRequest: QuestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questRequest' is not null or undefined
            assertParamExists('storyQuestsCreate', 'questRequest', questRequest)
            const localVarPath = `/api/story/quests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyQuestsDestroy', 'id', id)
            const localVarPath = `/api/story/quests/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} [chapter] 
         * @param {string} [chapterStory] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsList: async (chapter?: string, chapterStory?: string, ordering?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/quests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chapter !== undefined) {
                localVarQueryParameter['chapter'] = chapter;
            }

            if (chapterStory !== undefined) {
                localVarQueryParameter['chapter__story'] = chapterStory;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {PatchedQuestRequest} [patchedQuestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsPartialUpdate: async (id: string, patchedQuestRequest?: PatchedQuestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyQuestsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/quests/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedQuestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyQuestsRetrieve', 'id', id)
            const localVarPath = `/api/story/quests/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsUpdate: async (id: string, questRequest: QuestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyQuestsUpdate', 'id', id)
            // verify required parameter 'questRequest' is not null or undefined
            assertParamExists('storyQuestsUpdate', 'questRequest', questRequest)
            const localVarPath = `/api/story/quests/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsCreate: async (rewardRequest: RewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewardRequest' is not null or undefined
            assertParamExists('storyRewardsCreate', 'rewardRequest', rewardRequest)
            const localVarPath = `/api/story/rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyRewardsDestroy', 'id', id)
            const localVarPath = `/api/story/rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsList: async (ordering?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {PatchedRewardRequest} [patchedRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsPartialUpdate: async (id: string, patchedRewardRequest?: PatchedRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyRewardsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyRewardsRetrieve', 'id', id)
            const localVarPath = `/api/story/rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsUpdate: async (id: string, rewardRequest: RewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyRewardsUpdate', 'id', id)
            // verify required parameter 'rewardRequest' is not null or undefined
            assertParamExists('storyRewardsUpdate', 'rewardRequest', rewardRequest)
            const localVarPath = `/api/story/rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesCreate: async (storyRequest: StoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storyRequest' is not null or undefined
            assertParamExists('storyStoriesCreate', 'storyRequest', storyRequest)
            const localVarPath = `/api/story/stories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesDestroy', 'id', id)
            const localVarPath = `/api/story/stories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {boolean} [canonical] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesList: async (canonical?: boolean, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/stories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {PatchedStoryRequest} [patchedStoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesPartialUpdate: async (id: string, patchedStoryRequest?: PatchedStoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesPartialUpdate', 'id', id)
            const localVarPath = `/api/story/stories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesRetrieve', 'id', id)
            const localVarPath = `/api/story/stories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a story as canonical (requires owner review).
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesSetCanonicalCreate: async (id: string, storyRequest: StoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesSetCanonicalCreate', 'id', id)
            // verify required parameter 'storyRequest' is not null or undefined
            assertParamExists('storyStoriesSetCanonicalCreate', 'storyRequest', storyRequest)
            const localVarPath = `/api/story/stories/{id}/set_canonical/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove canonical status from a story.
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesUnsetCanonicalCreate: async (id: string, storyRequest: StoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesUnsetCanonicalCreate', 'id', id)
            // verify required parameter 'storyRequest' is not null or undefined
            assertParamExists('storyStoriesUnsetCanonicalCreate', 'storyRequest', storyRequest)
            const localVarPath = `/api/story/stories/{id}/unset_canonical/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesUpdate: async (id: string, storyRequest: StoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyStoriesUpdate', 'id', id)
            // verify required parameter 'storyRequest' is not null or undefined
            assertParamExists('storyStoriesUpdate', 'storyRequest', storyRequest)
            const localVarPath = `/api/story/stories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsCreate: async (tokenRewardRequest: TokenRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRewardRequest' is not null or undefined
            assertParamExists('storyTokenRewardsCreate', 'tokenRewardRequest', tokenRewardRequest)
            const localVarPath = `/api/story/token-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTokenRewardsDestroy', 'id', id)
            const localVarPath = `/api/story/token-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsList: async (ordering?: string, reward?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/token-rewards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (reward !== undefined) {
                localVarQueryParameter['reward'] = reward;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {PatchedTokenRewardRequest} [patchedTokenRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsPartialUpdate: async (id: string, patchedTokenRewardRequest?: PatchedTokenRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTokenRewardsPartialUpdate', 'id', id)
            const localVarPath = `/api/story/token-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTokenRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTokenRewardsRetrieve', 'id', id)
            const localVarPath = `/api/story/token-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsUpdate: async (id: string, tokenRewardRequest: TokenRewardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTokenRewardsUpdate', 'id', id)
            // verify required parameter 'tokenRewardRequest' is not null or undefined
            assertParamExists('storyTokenRewardsUpdate', 'tokenRewardRequest', tokenRewardRequest)
            const localVarPath = `/api/story/token-rewards/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRewardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersCreate: async (triggerRequest: TriggerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerRequest' is not null or undefined
            assertParamExists('storyTriggersCreate', 'triggerRequest', triggerRequest)
            const localVarPath = `/api/story/triggers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(triggerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTriggersDestroy', 'id', id)
            const localVarPath = `/api/story/triggers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} [gameObject] 
         * @param {string} [location] 
         * @param {string} [npc] 
         * @param {string} [position] 
         * @param {string} [search] A search term.
         * @param {StoryTriggersListTypeEnum} [type] * &#x60;search&#x60; - search * &#x60;kill&#x60; - kill * &#x60;interaction&#x60; - interaction * &#x60;position&#x60; - position * &#x60;useItem&#x60; - useItem * &#x60;useSkill&#x60; - useSkill * &#x60;custom&#x60; - custom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersList: async (gameObject?: string, location?: string, npc?: string, position?: string, search?: string, type?: StoryTriggersListTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/story/triggers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gameObject !== undefined) {
                localVarQueryParameter['game_object'] = gameObject;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {PatchedTriggerRequest} [patchedTriggerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersPartialUpdate: async (id: string, patchedTriggerRequest?: PatchedTriggerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTriggersPartialUpdate', 'id', id)
            const localVarPath = `/api/story/triggers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTriggerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTriggersRetrieve', 'id', id)
            const localVarPath = `/api/story/triggers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersUpdate: async (id: string, triggerRequest: TriggerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storyTriggersUpdate', 'id', id)
            // verify required parameter 'triggerRequest' is not null or undefined
            assertParamExists('storyTriggersUpdate', 'triggerRequest', triggerRequest)
            const localVarPath = `/api/story/triggers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(triggerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoryApi - functional programming interface
 * @export
 */
export const StoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoryApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersCreate(chapterRequest: ChapterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chapter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersCreate(chapterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [story] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersList(ordering?: string, story?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chapter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersList(ordering, story, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {PatchedChapterRequest} [patchedChapterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersPartialUpdate(id: string, patchedChapterRequest?: PatchedChapterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chapter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersPartialUpdate(id, patchedChapterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chapter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyChaptersUpdate(id: string, chapterRequest: ChapterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chapter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyChaptersUpdate(id, chapterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyChaptersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsCreate(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsCreate(conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {StoryConditionsListTypeEnum} [type] * &#x60;all&#x60; - All * &#x60;any&#x60; - Any * &#x60;none&#x60; - None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsList(type?: StoryConditionsListTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Condition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsList(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {PatchedConditionRequest} [patchedConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsPartialUpdate(id: string, patchedConditionRequest?: PatchedConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsPartialUpdate(id, patchedConditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyConditionsUpdate(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyConditionsUpdate(id, conditionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyConditionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsCreate(effectRewardRequest: EffectRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EffectReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsCreate(effectRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {StoryEffectRewardsListEffectEnum} [effect] * &#x60;Knocked out&#x60; - Knocked out * &#x60;Coma&#x60; - Coma * &#x60;None&#x60; - None * &#x60;Burning&#x60; - Burning * &#x60;Poisoned&#x60; - Poisoned * &#x60;Sleeping&#x60; - Sleeping * &#x60;Confused&#x60; - Confused * &#x60;Paralyzed&#x60; - Paralyzed * &#x60;Fear&#x60; - Fear * &#x60;Slowness&#x60; - Slowness * &#x60;Cold&#x60; - Cold * &#x60;Cursed&#x60; - Cursed * &#x60;Blindness&#x60; - Blindness * &#x60;Haste&#x60; - Haste * &#x60;Regeneration&#x60; - Regeneration * &#x60;Blessed&#x60; - Blessed * &#x60;Arcane Surge&#x60; - Arcane Surge * &#x60;Marked&#x60; - Marked
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsList(effect?: StoryEffectRewardsListEffectEnum, ordering?: string, reward?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EffectReward>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsList(effect, ordering, reward, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {PatchedEffectRewardRequest} [patchedEffectRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsPartialUpdate(id: string, patchedEffectRewardRequest?: PatchedEffectRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EffectReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsPartialUpdate(id, patchedEffectRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EffectReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyEffectRewardsUpdate(id: string, effectRewardRequest: EffectRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EffectReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyEffectRewardsUpdate(id, effectRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyEffectRewardsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsCreate(itemRewardRequest: ItemRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsCreate(itemRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} [item] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsList(item?: string, ordering?: string, reward?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemReward>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsList(item, ordering, reward, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {PatchedItemRewardRequest} [patchedItemRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsPartialUpdate(id: string, patchedItemRewardRequest?: PatchedItemRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsPartialUpdate(id, patchedItemRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyItemRewardsUpdate(id: string, itemRewardRequest: ItemRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyItemRewardsUpdate(id, itemRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyItemRewardsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesCreate(noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesCreate(noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [quest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesList(ordering?: string, quest?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Note>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesList(ordering, quest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {PatchedNoteRequest} [patchedNoteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesPartialUpdate(id: string, patchedNoteRequest?: PatchedNoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesPartialUpdate(id, patchedNoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyNotesUpdate(id: string, noteRequest: NoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyNotesUpdate(id, noteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyNotesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsCreate(questRequest: QuestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsCreate(questRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} [chapter] 
         * @param {string} [chapterStory] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsList(chapter?: string, chapterStory?: string, ordering?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsList(chapter, chapterStory, ordering, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {PatchedQuestRequest} [patchedQuestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsPartialUpdate(id: string, patchedQuestRequest?: PatchedQuestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsPartialUpdate(id, patchedQuestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyQuestsUpdate(id: string, questRequest: QuestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyQuestsUpdate(id, questRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyQuestsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsCreate(rewardRequest: RewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsCreate(rewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsList(ordering?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reward>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsList(ordering, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {PatchedRewardRequest} [patchedRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsPartialUpdate(id: string, patchedRewardRequest?: PatchedRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsPartialUpdate(id, patchedRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyRewardsUpdate(id: string, rewardRequest: RewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyRewardsUpdate(id, rewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyRewardsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesCreate(storyRequest: StoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Story>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesCreate(storyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {boolean} [canonical] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesList(canonical?: boolean, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Story>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesList(canonical, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {PatchedStoryRequest} [patchedStoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesPartialUpdate(id: string, patchedStoryRequest?: PatchedStoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Story>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesPartialUpdate(id, patchedStoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoryDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a story as canonical (requires owner review).
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesSetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Story>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesSetCanonicalCreate(id, storyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesSetCanonicalCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove canonical status from a story.
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesUnsetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Story>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesUnsetCanonicalCreate(id, storyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesUnsetCanonicalCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyStoriesUpdate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Story>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyStoriesUpdate(id, storyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyStoriesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsCreate(tokenRewardRequest: TokenRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsCreate(tokenRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsList(ordering?: string, reward?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenReward>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsList(ordering, reward, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {PatchedTokenRewardRequest} [patchedTokenRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsPartialUpdate(id: string, patchedTokenRewardRequest?: PatchedTokenRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsPartialUpdate(id, patchedTokenRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTokenRewardsUpdate(id: string, tokenRewardRequest: TokenRewardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTokenRewardsUpdate(id, tokenRewardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTokenRewardsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersCreate(triggerRequest: TriggerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trigger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersCreate(triggerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} [gameObject] 
         * @param {string} [location] 
         * @param {string} [npc] 
         * @param {string} [position] 
         * @param {string} [search] A search term.
         * @param {StoryTriggersListTypeEnum} [type] * &#x60;search&#x60; - search * &#x60;kill&#x60; - kill * &#x60;interaction&#x60; - interaction * &#x60;position&#x60; - position * &#x60;useItem&#x60; - useItem * &#x60;useSkill&#x60; - useSkill * &#x60;custom&#x60; - custom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersList(gameObject?: string, location?: string, npc?: string, position?: string, search?: string, type?: StoryTriggersListTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trigger>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersList(gameObject, location, npc, position, search, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {PatchedTriggerRequest} [patchedTriggerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersPartialUpdate(id: string, patchedTriggerRequest?: PatchedTriggerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trigger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersPartialUpdate(id, patchedTriggerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trigger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyTriggersUpdate(id: string, triggerRequest: TriggerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trigger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyTriggersUpdate(id, triggerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyTriggersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoryApi - factory interface
 * @export
 */
export const StoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoryApiFp(configuration)
    return {
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersCreate(chapterRequest: ChapterRequest, options?: any): AxiosPromise<Chapter> {
            return localVarFp.storyChaptersCreate(chapterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyChaptersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [story] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersList(ordering?: string, story?: string, options?: any): AxiosPromise<Array<Chapter>> {
            return localVarFp.storyChaptersList(ordering, story, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {PatchedChapterRequest} [patchedChapterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersPartialUpdate(id: string, patchedChapterRequest?: PatchedChapterRequest, options?: any): AxiosPromise<Chapter> {
            return localVarFp.storyChaptersPartialUpdate(id, patchedChapterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersRetrieve(id: string, options?: any): AxiosPromise<Chapter> {
            return localVarFp.storyChaptersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage chapters within stories.
         * @param {string} id A UUID string identifying this chapter.
         * @param {ChapterRequest} chapterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyChaptersUpdate(id: string, chapterRequest: ChapterRequest, options?: any): AxiosPromise<Chapter> {
            return localVarFp.storyChaptersUpdate(id, chapterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsCreate(conditionRequest?: ConditionRequest, options?: any): AxiosPromise<Condition> {
            return localVarFp.storyConditionsCreate(conditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyConditionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {StoryConditionsListTypeEnum} [type] * &#x60;all&#x60; - All * &#x60;any&#x60; - Any * &#x60;none&#x60; - None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsList(type?: StoryConditionsListTypeEnum, options?: any): AxiosPromise<Array<Condition>> {
            return localVarFp.storyConditionsList(type, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {PatchedConditionRequest} [patchedConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsPartialUpdate(id: string, patchedConditionRequest?: PatchedConditionRequest, options?: any): AxiosPromise<Condition> {
            return localVarFp.storyConditionsPartialUpdate(id, patchedConditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsRetrieve(id: string, options?: any): AxiosPromise<Condition> {
            return localVarFp.storyConditionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage conditions for quest starters and objectives.
         * @param {string} id A UUID string identifying this condition.
         * @param {ConditionRequest} [conditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyConditionsUpdate(id: string, conditionRequest?: ConditionRequest, options?: any): AxiosPromise<Condition> {
            return localVarFp.storyConditionsUpdate(id, conditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsCreate(effectRewardRequest: EffectRewardRequest, options?: any): AxiosPromise<EffectReward> {
            return localVarFp.storyEffectRewardsCreate(effectRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyEffectRewardsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {StoryEffectRewardsListEffectEnum} [effect] * &#x60;Knocked out&#x60; - Knocked out * &#x60;Coma&#x60; - Coma * &#x60;None&#x60; - None * &#x60;Burning&#x60; - Burning * &#x60;Poisoned&#x60; - Poisoned * &#x60;Sleeping&#x60; - Sleeping * &#x60;Confused&#x60; - Confused * &#x60;Paralyzed&#x60; - Paralyzed * &#x60;Fear&#x60; - Fear * &#x60;Slowness&#x60; - Slowness * &#x60;Cold&#x60; - Cold * &#x60;Cursed&#x60; - Cursed * &#x60;Blindness&#x60; - Blindness * &#x60;Haste&#x60; - Haste * &#x60;Regeneration&#x60; - Regeneration * &#x60;Blessed&#x60; - Blessed * &#x60;Arcane Surge&#x60; - Arcane Surge * &#x60;Marked&#x60; - Marked
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsList(effect?: StoryEffectRewardsListEffectEnum, ordering?: string, reward?: string, options?: any): AxiosPromise<Array<EffectReward>> {
            return localVarFp.storyEffectRewardsList(effect, ordering, reward, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {PatchedEffectRewardRequest} [patchedEffectRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsPartialUpdate(id: string, patchedEffectRewardRequest?: PatchedEffectRewardRequest, options?: any): AxiosPromise<EffectReward> {
            return localVarFp.storyEffectRewardsPartialUpdate(id, patchedEffectRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsRetrieve(id: string, options?: any): AxiosPromise<EffectReward> {
            return localVarFp.storyEffectRewardsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effect rewards.
         * @param {string} id A UUID string identifying this effect reward.
         * @param {EffectRewardRequest} effectRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyEffectRewardsUpdate(id: string, effectRewardRequest: EffectRewardRequest, options?: any): AxiosPromise<EffectReward> {
            return localVarFp.storyEffectRewardsUpdate(id, effectRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsCreate(itemRewardRequest: ItemRewardRequest, options?: any): AxiosPromise<ItemReward> {
            return localVarFp.storyItemRewardsCreate(itemRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyItemRewardsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} [item] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsList(item?: string, ordering?: string, reward?: string, options?: any): AxiosPromise<Array<ItemReward>> {
            return localVarFp.storyItemRewardsList(item, ordering, reward, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {PatchedItemRewardRequest} [patchedItemRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsPartialUpdate(id: string, patchedItemRewardRequest?: PatchedItemRewardRequest, options?: any): AxiosPromise<ItemReward> {
            return localVarFp.storyItemRewardsPartialUpdate(id, patchedItemRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsRetrieve(id: string, options?: any): AxiosPromise<ItemReward> {
            return localVarFp.storyItemRewardsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage item rewards.
         * @param {string} id A UUID string identifying this item reward.
         * @param {ItemRewardRequest} itemRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyItemRewardsUpdate(id: string, itemRewardRequest: ItemRewardRequest, options?: any): AxiosPromise<ItemReward> {
            return localVarFp.storyItemRewardsUpdate(id, itemRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesCreate(noteRequest: NoteRequest, options?: any): AxiosPromise<Note> {
            return localVarFp.storyNotesCreate(noteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyNotesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [quest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesList(ordering?: string, quest?: string, options?: any): AxiosPromise<Array<Note>> {
            return localVarFp.storyNotesList(ordering, quest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {PatchedNoteRequest} [patchedNoteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesPartialUpdate(id: string, patchedNoteRequest?: PatchedNoteRequest, options?: any): AxiosPromise<Note> {
            return localVarFp.storyNotesPartialUpdate(id, patchedNoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesRetrieve(id: string, options?: any): AxiosPromise<Note> {
            return localVarFp.storyNotesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quest notes.
         * @param {string} id A UUID string identifying this note.
         * @param {NoteRequest} noteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyNotesUpdate(id: string, noteRequest: NoteRequest, options?: any): AxiosPromise<Note> {
            return localVarFp.storyNotesUpdate(id, noteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsCreate(questRequest: QuestRequest, options?: any): AxiosPromise<Quest> {
            return localVarFp.storyQuestsCreate(questRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyQuestsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} [chapter] 
         * @param {string} [chapterStory] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsList(chapter?: string, chapterStory?: string, ordering?: string, options?: any): AxiosPromise<Array<Quest>> {
            return localVarFp.storyQuestsList(chapter, chapterStory, ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {PatchedQuestRequest} [patchedQuestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsPartialUpdate(id: string, patchedQuestRequest?: PatchedQuestRequest, options?: any): AxiosPromise<Quest> {
            return localVarFp.storyQuestsPartialUpdate(id, patchedQuestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsRetrieve(id: string, options?: any): AxiosPromise<Quest> {
            return localVarFp.storyQuestsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage quests within chapters.
         * @param {string} id A UUID string identifying this quest.
         * @param {QuestRequest} questRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyQuestsUpdate(id: string, questRequest: QuestRequest, options?: any): AxiosPromise<Quest> {
            return localVarFp.storyQuestsUpdate(id, questRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsCreate(rewardRequest: RewardRequest, options?: any): AxiosPromise<Reward> {
            return localVarFp.storyRewardsCreate(rewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyRewardsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsList(ordering?: string, options?: any): AxiosPromise<Array<Reward>> {
            return localVarFp.storyRewardsList(ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {PatchedRewardRequest} [patchedRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsPartialUpdate(id: string, patchedRewardRequest?: PatchedRewardRequest, options?: any): AxiosPromise<Reward> {
            return localVarFp.storyRewardsPartialUpdate(id, patchedRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsRetrieve(id: string, options?: any): AxiosPromise<Reward> {
            return localVarFp.storyRewardsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage rewards for quest success/failure.
         * @param {string} id A UUID string identifying this reward.
         * @param {RewardRequest} rewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyRewardsUpdate(id: string, rewardRequest: RewardRequest, options?: any): AxiosPromise<Reward> {
            return localVarFp.storyRewardsUpdate(id, rewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesCreate(storyRequest: StoryRequest, options?: any): AxiosPromise<Story> {
            return localVarFp.storyStoriesCreate(storyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyStoriesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {boolean} [canonical] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesList(canonical?: boolean, ordering?: string, search?: string, options?: any): AxiosPromise<Array<Story>> {
            return localVarFp.storyStoriesList(canonical, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {PatchedStoryRequest} [patchedStoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesPartialUpdate(id: string, patchedStoryRequest?: PatchedStoryRequest, options?: any): AxiosPromise<Story> {
            return localVarFp.storyStoriesPartialUpdate(id, patchedStoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesRetrieve(id: string, options?: any): AxiosPromise<StoryDetail> {
            return localVarFp.storyStoriesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a story as canonical (requires owner review).
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesSetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: any): AxiosPromise<Story> {
            return localVarFp.storyStoriesSetCanonicalCreate(id, storyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove canonical status from a story.
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesUnsetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: any): AxiosPromise<Story> {
            return localVarFp.storyStoriesUnsetCanonicalCreate(id, storyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
         * @param {string} id A UUID string identifying this story.
         * @param {StoryRequest} storyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyStoriesUpdate(id: string, storyRequest: StoryRequest, options?: any): AxiosPromise<Story> {
            return localVarFp.storyStoriesUpdate(id, storyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsCreate(tokenRewardRequest: TokenRewardRequest, options?: any): AxiosPromise<TokenReward> {
            return localVarFp.storyTokenRewardsCreate(tokenRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyTokenRewardsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [reward] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsList(ordering?: string, reward?: string, token?: string, options?: any): AxiosPromise<Array<TokenReward>> {
            return localVarFp.storyTokenRewardsList(ordering, reward, token, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {PatchedTokenRewardRequest} [patchedTokenRewardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsPartialUpdate(id: string, patchedTokenRewardRequest?: PatchedTokenRewardRequest, options?: any): AxiosPromise<TokenReward> {
            return localVarFp.storyTokenRewardsPartialUpdate(id, patchedTokenRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsRetrieve(id: string, options?: any): AxiosPromise<TokenReward> {
            return localVarFp.storyTokenRewardsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage token rewards.
         * @param {string} id A UUID string identifying this token reward.
         * @param {TokenRewardRequest} tokenRewardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTokenRewardsUpdate(id: string, tokenRewardRequest: TokenRewardRequest, options?: any): AxiosPromise<TokenReward> {
            return localVarFp.storyTokenRewardsUpdate(id, tokenRewardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersCreate(triggerRequest: TriggerRequest, options?: any): AxiosPromise<Trigger> {
            return localVarFp.storyTriggersCreate(triggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.storyTriggersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} [gameObject] 
         * @param {string} [location] 
         * @param {string} [npc] 
         * @param {string} [position] 
         * @param {string} [search] A search term.
         * @param {StoryTriggersListTypeEnum} [type] * &#x60;search&#x60; - search * &#x60;kill&#x60; - kill * &#x60;interaction&#x60; - interaction * &#x60;position&#x60; - position * &#x60;useItem&#x60; - useItem * &#x60;useSkill&#x60; - useSkill * &#x60;custom&#x60; - custom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersList(gameObject?: string, location?: string, npc?: string, position?: string, search?: string, type?: StoryTriggersListTypeEnum, options?: any): AxiosPromise<Array<Trigger>> {
            return localVarFp.storyTriggersList(gameObject, location, npc, position, search, type, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {PatchedTriggerRequest} [patchedTriggerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersPartialUpdate(id: string, patchedTriggerRequest?: PatchedTriggerRequest, options?: any): AxiosPromise<Trigger> {
            return localVarFp.storyTriggersPartialUpdate(id, patchedTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersRetrieve(id: string, options?: any): AxiosPromise<Trigger> {
            return localVarFp.storyTriggersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage triggers for quest conditions.
         * @param {string} id A UUID string identifying this trigger.
         * @param {TriggerRequest} triggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyTriggersUpdate(id: string, triggerRequest: TriggerRequest, options?: any): AxiosPromise<Trigger> {
            return localVarFp.storyTriggersUpdate(id, triggerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoryApi - object-oriented interface
 * @export
 * @class StoryApi
 * @extends {BaseAPI}
 */
export class StoryApi extends BaseAPI {
    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {ChapterRequest} chapterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersCreate(chapterRequest: ChapterRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersCreate(chapterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {string} id A UUID string identifying this chapter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [story] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersList(ordering?: string, story?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersList(ordering, story, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {string} id A UUID string identifying this chapter.
     * @param {PatchedChapterRequest} [patchedChapterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersPartialUpdate(id: string, patchedChapterRequest?: PatchedChapterRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersPartialUpdate(id, patchedChapterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {string} id A UUID string identifying this chapter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage chapters within stories.
     * @param {string} id A UUID string identifying this chapter.
     * @param {ChapterRequest} chapterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyChaptersUpdate(id: string, chapterRequest: ChapterRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyChaptersUpdate(id, chapterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsCreate(conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsCreate(conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {string} id A UUID string identifying this condition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {StoryConditionsListTypeEnum} [type] * &#x60;all&#x60; - All * &#x60;any&#x60; - Any * &#x60;none&#x60; - None
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsList(type?: StoryConditionsListTypeEnum, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsList(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {string} id A UUID string identifying this condition.
     * @param {PatchedConditionRequest} [patchedConditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsPartialUpdate(id: string, patchedConditionRequest?: PatchedConditionRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsPartialUpdate(id, patchedConditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {string} id A UUID string identifying this condition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage conditions for quest starters and objectives.
     * @param {string} id A UUID string identifying this condition.
     * @param {ConditionRequest} [conditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyConditionsUpdate(id: string, conditionRequest?: ConditionRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyConditionsUpdate(id, conditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {EffectRewardRequest} effectRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsCreate(effectRewardRequest: EffectRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsCreate(effectRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {string} id A UUID string identifying this effect reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {StoryEffectRewardsListEffectEnum} [effect] * &#x60;Knocked out&#x60; - Knocked out * &#x60;Coma&#x60; - Coma * &#x60;None&#x60; - None * &#x60;Burning&#x60; - Burning * &#x60;Poisoned&#x60; - Poisoned * &#x60;Sleeping&#x60; - Sleeping * &#x60;Confused&#x60; - Confused * &#x60;Paralyzed&#x60; - Paralyzed * &#x60;Fear&#x60; - Fear * &#x60;Slowness&#x60; - Slowness * &#x60;Cold&#x60; - Cold * &#x60;Cursed&#x60; - Cursed * &#x60;Blindness&#x60; - Blindness * &#x60;Haste&#x60; - Haste * &#x60;Regeneration&#x60; - Regeneration * &#x60;Blessed&#x60; - Blessed * &#x60;Arcane Surge&#x60; - Arcane Surge * &#x60;Marked&#x60; - Marked
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [reward] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsList(effect?: StoryEffectRewardsListEffectEnum, ordering?: string, reward?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsList(effect, ordering, reward, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {string} id A UUID string identifying this effect reward.
     * @param {PatchedEffectRewardRequest} [patchedEffectRewardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsPartialUpdate(id: string, patchedEffectRewardRequest?: PatchedEffectRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsPartialUpdate(id, patchedEffectRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {string} id A UUID string identifying this effect reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effect rewards.
     * @param {string} id A UUID string identifying this effect reward.
     * @param {EffectRewardRequest} effectRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyEffectRewardsUpdate(id: string, effectRewardRequest: EffectRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyEffectRewardsUpdate(id, effectRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {ItemRewardRequest} itemRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsCreate(itemRewardRequest: ItemRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsCreate(itemRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {string} id A UUID string identifying this item reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {string} [item] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [reward] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsList(item?: string, ordering?: string, reward?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsList(item, ordering, reward, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {string} id A UUID string identifying this item reward.
     * @param {PatchedItemRewardRequest} [patchedItemRewardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsPartialUpdate(id: string, patchedItemRewardRequest?: PatchedItemRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsPartialUpdate(id, patchedItemRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {string} id A UUID string identifying this item reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage item rewards.
     * @param {string} id A UUID string identifying this item reward.
     * @param {ItemRewardRequest} itemRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyItemRewardsUpdate(id: string, itemRewardRequest: ItemRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyItemRewardsUpdate(id, itemRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesCreate(noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesCreate(noteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {string} id A UUID string identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [quest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesList(ordering?: string, quest?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesList(ordering, quest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {string} id A UUID string identifying this note.
     * @param {PatchedNoteRequest} [patchedNoteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesPartialUpdate(id: string, patchedNoteRequest?: PatchedNoteRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesPartialUpdate(id, patchedNoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {string} id A UUID string identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quest notes.
     * @param {string} id A UUID string identifying this note.
     * @param {NoteRequest} noteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyNotesUpdate(id: string, noteRequest: NoteRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyNotesUpdate(id, noteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {QuestRequest} questRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsCreate(questRequest: QuestRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsCreate(questRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {string} id A UUID string identifying this quest.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {string} [chapter] 
     * @param {string} [chapterStory] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsList(chapter?: string, chapterStory?: string, ordering?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsList(chapter, chapterStory, ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {string} id A UUID string identifying this quest.
     * @param {PatchedQuestRequest} [patchedQuestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsPartialUpdate(id: string, patchedQuestRequest?: PatchedQuestRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsPartialUpdate(id, patchedQuestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {string} id A UUID string identifying this quest.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage quests within chapters.
     * @param {string} id A UUID string identifying this quest.
     * @param {QuestRequest} questRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyQuestsUpdate(id: string, questRequest: QuestRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyQuestsUpdate(id, questRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {RewardRequest} rewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsCreate(rewardRequest: RewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsCreate(rewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {string} id A UUID string identifying this reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsList(ordering?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsList(ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {string} id A UUID string identifying this reward.
     * @param {PatchedRewardRequest} [patchedRewardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsPartialUpdate(id: string, patchedRewardRequest?: PatchedRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsPartialUpdate(id, patchedRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {string} id A UUID string identifying this reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage rewards for quest success/failure.
     * @param {string} id A UUID string identifying this reward.
     * @param {RewardRequest} rewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyRewardsUpdate(id: string, rewardRequest: RewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyRewardsUpdate(id, rewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {StoryRequest} storyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesCreate(storyRequest: StoryRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesCreate(storyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {string} id A UUID string identifying this story.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {boolean} [canonical] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesList(canonical?: boolean, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesList(canonical, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {string} id A UUID string identifying this story.
     * @param {PatchedStoryRequest} [patchedStoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesPartialUpdate(id: string, patchedStoryRequest?: PatchedStoryRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesPartialUpdate(id, patchedStoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {string} id A UUID string identifying this story.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a story as canonical (requires owner review).
     * @param {string} id A UUID string identifying this story.
     * @param {StoryRequest} storyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesSetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesSetCanonicalCreate(id, storyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove canonical status from a story.
     * @param {string} id A UUID string identifying this story.
     * @param {StoryRequest} storyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesUnsetCanonicalCreate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesUnsetCanonicalCreate(id, storyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage stories.  This viewset provides operations for: - Listing, retrieving, creating, updating, and deleting stories - Managing story canonical status - Filtering stories by tags and canonical status
     * @param {string} id A UUID string identifying this story.
     * @param {StoryRequest} storyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyStoriesUpdate(id: string, storyRequest: StoryRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyStoriesUpdate(id, storyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {TokenRewardRequest} tokenRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsCreate(tokenRewardRequest: TokenRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsCreate(tokenRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {string} id A UUID string identifying this token reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [reward] 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsList(ordering?: string, reward?: string, token?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsList(ordering, reward, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {string} id A UUID string identifying this token reward.
     * @param {PatchedTokenRewardRequest} [patchedTokenRewardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsPartialUpdate(id: string, patchedTokenRewardRequest?: PatchedTokenRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsPartialUpdate(id, patchedTokenRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {string} id A UUID string identifying this token reward.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage token rewards.
     * @param {string} id A UUID string identifying this token reward.
     * @param {TokenRewardRequest} tokenRewardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTokenRewardsUpdate(id: string, tokenRewardRequest: TokenRewardRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTokenRewardsUpdate(id, tokenRewardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {TriggerRequest} triggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersCreate(triggerRequest: TriggerRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersCreate(triggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {string} id A UUID string identifying this trigger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {string} [gameObject] 
     * @param {string} [location] 
     * @param {string} [npc] 
     * @param {string} [position] 
     * @param {string} [search] A search term.
     * @param {StoryTriggersListTypeEnum} [type] * &#x60;search&#x60; - search * &#x60;kill&#x60; - kill * &#x60;interaction&#x60; - interaction * &#x60;position&#x60; - position * &#x60;useItem&#x60; - useItem * &#x60;useSkill&#x60; - useSkill * &#x60;custom&#x60; - custom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersList(gameObject?: string, location?: string, npc?: string, position?: string, search?: string, type?: StoryTriggersListTypeEnum, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersList(gameObject, location, npc, position, search, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {string} id A UUID string identifying this trigger.
     * @param {PatchedTriggerRequest} [patchedTriggerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersPartialUpdate(id: string, patchedTriggerRequest?: PatchedTriggerRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersPartialUpdate(id, patchedTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {string} id A UUID string identifying this trigger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage triggers for quest conditions.
     * @param {string} id A UUID string identifying this trigger.
     * @param {TriggerRequest} triggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyTriggersUpdate(id: string, triggerRequest: TriggerRequest, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyTriggersUpdate(id, triggerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StoryConditionsListTypeEnum = {
    All: 'all',
    Any: 'any',
    None: 'none'
} as const;
export type StoryConditionsListTypeEnum = typeof StoryConditionsListTypeEnum[keyof typeof StoryConditionsListTypeEnum];
/**
 * @export
 */
export const StoryEffectRewardsListEffectEnum = {
    ArcaneSurge: 'Arcane Surge',
    Blessed: 'Blessed',
    Blindness: 'Blindness',
    Burning: 'Burning',
    Cold: 'Cold',
    Coma: 'Coma',
    Confused: 'Confused',
    Cursed: 'Cursed',
    Fear: 'Fear',
    Haste: 'Haste',
    KnockedOut: 'Knocked out',
    Marked: 'Marked',
    None: 'None',
    Paralyzed: 'Paralyzed',
    Poisoned: 'Poisoned',
    Regeneration: 'Regeneration',
    Sleeping: 'Sleeping',
    Slowness: 'Slowness'
} as const;
export type StoryEffectRewardsListEffectEnum = typeof StoryEffectRewardsListEffectEnum[keyof typeof StoryEffectRewardsListEffectEnum];
/**
 * @export
 */
export const StoryTriggersListTypeEnum = {
    Custom: 'custom',
    Interaction: 'interaction',
    Kill: 'kill',
    Position: 'position',
    Search: 'search',
    UseItem: 'useItem',
    UseSkill: 'useSkill'
} as const;
export type StoryTriggersListTypeEnum = typeof StoryTriggersListTypeEnum[keyof typeof StoryTriggersListTypeEnum];


/**
 * WorldApi - axios parameter creator
 * @export
 */
export const WorldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldAreasRetrieve', 'id', id)
            const localVarPath = `/api/world/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldCitiesRetrieve', 'id', id)
            const localVarPath = `/api/world/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldDimensionsRetrieve', 'id', id)
            const localVarPath = `/api/world/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsChangeCreate', 'id', id)
            const localVarPath = `/api/world/locations/{id}/change/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsRetrieve', 'id', id)
            const localVarPath = `/api/world/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/mapped-position/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionMapPositionCreate: async (newCoordinatesRequest: NewCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCoordinatesRequest' is not null or undefined
            assertParamExists('worldMappedPositionMapPositionCreate', 'newCoordinatesRequest', newCoordinatesRequest)
            const localVarPath = `/api/world/mapped-position/map_position/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldMappedPositionRetrieve', 'id', id)
            const localVarPath = `/api/world/mapped-position/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsMiniMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/maps/mini_map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionAddCreate: async (newCoordinatesRequest: NewCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCoordinatesRequest' is not null or undefined
            assertParamExists('worldMapsPositionAddCreate', 'newCoordinatesRequest', newCoordinatesRequest)
            const localVarPath = `/api/world/maps/position_add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionRemoveCreate: async (genericPositionIdRequest: GenericPositionIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genericPositionIdRequest' is not null or undefined
            assertParamExists('worldMapsPositionRemoveCreate', 'genericPositionIdRequest', genericPositionIdRequest)
            const localVarPath = `/api/world/maps/position_remove/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(genericPositionIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionUpdateCreate: async (mapPositionMutableRequest: MapPositionMutableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mapPositionMutableRequest' is not null or undefined
            assertParamExists('worldMapsPositionUpdateCreate', 'mapPositionMutableRequest', mapPositionMutableRequest)
            const localVarPath = `/api/world/maps/position_update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mapPositionMutableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsWorldMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/maps/world_map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionInfoRetrieve', 'id', id)
            const localVarPath = `/api/world/position/{id}/info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionMoveToPositionCreate', 'id', id)
            const localVarPath = `/api/world/position/{id}/move_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate: async (id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'id', id)
            // verify required parameter 'teleportCoordinatesRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'teleportCoordinatesRequest', teleportCoordinatesRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_coordinates/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate: async (id: string, teleportPositionRequest: TeleportPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'id', id)
            // verify required parameter 'teleportPositionRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'teleportPositionRequest', teleportPositionRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldApi - functional programming interface
 * @export
 */
export const WorldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dimension>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsChangeCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsChangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MapPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionMapPositionCreate(newCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionMapPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsMiniMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniMap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsMiniMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsMiniMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionAddCreate(newCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericPositionId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionRemoveCreate(genericPositionIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionRemoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionUpdateCreate(mapPositionMutableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionUpdateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsWorldMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsWorldMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsWorldMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMoveToPositionCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMoveToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportCoordinates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToCoordinatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorldApi - factory interface
 * @export
 */
export const WorldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorldApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve(options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList(options?: any): AxiosPromise<Array<Area>> {
            return localVarFp.worldAreasList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve(id: string, options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve(options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList(options?: any): AxiosPromise<Array<City>> {
            return localVarFp.worldCitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve(id: string, options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve(options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList(options?: any): AxiosPromise<Array<Dimension>> {
            return localVarFp.worldDimensionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve(id: number, options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldLocationsChangeCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve(options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList(options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.worldLocationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve(id: string, options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionList(options?: any): AxiosPromise<Array<MapPosition>> {
            return localVarFp.worldMappedPositionList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMappedPositionMapPositionCreate(newCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionRetrieve(id: string, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMappedPositionRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsMiniMapRetrieve(options?: any): AxiosPromise<MiniMap> {
            return localVarFp.worldMapsMiniMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMapsPositionAddCreate(newCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: any): AxiosPromise<GenericPositionId> {
            return localVarFp.worldMapsPositionRemoveCreate(genericPositionIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: any): AxiosPromise<any> {
            return localVarFp.worldMapsPositionUpdateCreate(mapPositionMutableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsWorldMapRetrieve(options?: any): AxiosPromise<any> {
            return localVarFp.worldMapsWorldMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve(options?: any): AxiosPromise<WorldPosition> {
            return localVarFp.worldPositionCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve(id: string, options?: any): AxiosPromise<WorldPosition> {
            return localVarFp.worldPositionInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve(options?: any): AxiosPromise<WorldPosition> {
            return localVarFp.worldPositionMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldPositionMoveToPositionCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: any): AxiosPromise<TeleportCoordinates> {
            return localVarFp.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: any): AxiosPromise<TeleportPosition> {
            return localVarFp.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorldApi - object-oriented interface
 * @export
 * @class WorldApi
 * @extends {BaseAPI}
 */
export class WorldApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsChangeCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewCoordinatesRequest} newCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionMapPositionCreate(newCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this map position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the mini map of the current organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsMiniMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsMiniMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewCoordinatesRequest} newCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionAddCreate(newCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenericPositionIdRequest} genericPositionIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionRemoveCreate(genericPositionIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MapPositionMutableRequest} mapPositionMutableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionUpdateCreate(mapPositionMutableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the world map of the current organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsWorldMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsWorldMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current position of the character and possible movements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the map of the current location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMoveToPositionCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportPositionRequest} teleportPositionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



