/* tslint:disable */
/* eslint-disable */
/**
 * DigitalX Game API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionImpactModel
 */
export interface ActionImpactModel {
    /**
     * 
     * @type {ImpactType}
     * @memberof ActionImpactModel
     */
    'type': ImpactType;
    /**
     * 
     * @type {ImpactViolationType}
     * @memberof ActionImpactModel
     */
    'violation': ImpactViolationType;
    /**
     * 
     * @type {number}
     * @memberof ActionImpactModel
     */
    'size': number;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof ActionImpactModel
     */
    'dice_roll_result': DiceRollResult;
}


/**
 * 
 * @export
 * @interface ActionModel
 */
export interface ActionModel {
    /**
     * 
     * @type {CharacterActionType}
     * @memberof ActionModel
     */
    'action_type': CharacterActionType;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'initiator_id': string;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'skill_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_dimension_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_location_id': string | null;
}


/**
 * * `USE_SKILL` - USE_SKILL * `USE_ITEM` - USE_ITEM * `DIMENSION_SHIFT` - DIMENSION_SHIFT * `CHANGE_POSITION` - CHANGE_POSITION * `START_DIALOGUE` - START_DIALOGUE * `MAKE_DUEL_INVITATION` - MAKE_DUEL_INVITATION * `ACCEPT_DUEL_INVITATION` - ACCEPT_DUEL_INVITATION * `REJECT_DUEL_INVITATION` - REJECT_DUEL_INVITATION * `START_FIGHT` - START_FIGHT * `MOVE` - MOVE * `BACK_TO_SAFE_ZONE` - BACK_TO_SAFE_ZONE * `DICE_ROLL` - DICE_ROLL
 * @export
 * @enum {string}
 */

export const ActionTypeEnum = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    DiceRoll: 'DICE_ROLL'
} as const;

export type ActionTypeEnum = typeof ActionTypeEnum[keyof typeof ActionTypeEnum];


/**
 * 
 * @export
 * @interface ActiveEffect
 */
export interface ActiveEffect {
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'id': string;
    /**
     * 
     * @type {Effect}
     * @memberof ActiveEffect
     */
    'effect': Effect;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'duration'?: number;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    'impact'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveEffect
     */
    'active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    '_data'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ActiveShield
 */
export interface ActiveShield {
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'id': string;
    /**
     * 
     * @type {Shield}
     * @memberof ActiveShield
     */
    'shield': Shield;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'cycles_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'health'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'efficiency'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'id': string;
    /**
     * 
     * @type {Array<SubLocation>}
     * @memberof Area
     */
    'sub_locations': Array<SubLocation>;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Area
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'city': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Area
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Art
 */
export interface Art {
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {NameEnum}
     * @memberof Attribute
     */
    'name': NameEnum;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface AttributeHolder
 */
export interface AttributeHolder {
    /**
     * 
     * @type {AttributeType}
     * @memberof AttributeHolder
     */
    'name': AttributeType;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'max': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AttributeType = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributeType = typeof AttributeType[keyof typeof AttributeType];


/**
 * 
 * @export
 * @interface Bio
 */
export interface Bio {
    /**
     * 
     * @type {number}
     * @memberof Bio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof Bio
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterAction
 */
export interface CharacterAction {
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof CharacterAction
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface CharacterActionLog
 */
export interface CharacterActionLog {
    /**
     * 
     * @type {string}
     * @memberof CharacterActionLog
     */
    'id': string;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterActionLog
     */
    'initiator': Nested;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof CharacterActionLog
     */
    'targets': Array<Nested>;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof CharacterActionLog
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterActionLog
     */
    'skill': Nested;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionLog
     */
    'data'?: any;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterActionLog
     */
    'position': Nested;
    /**
     * 
     * @type {Array<CharacterLogActionImpact>}
     * @memberof CharacterActionLog
     */
    'impacts': Array<CharacterLogActionImpact>;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterActionLog
     */
    'cycle': Nested;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLog
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLog
     */
    'performed'?: boolean;
}


/**
 * 
 * @export
 * @interface CharacterActionLogRequest
 */
export interface CharacterActionLogRequest {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof CharacterActionLogRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CharacterActionLogRequest
     */
    'performed'?: boolean;
}


/**
 * 
 * @export
 * @interface CharacterActionRequest
 */
export interface CharacterActionRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof CharacterActionRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CharacterActionType = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    DiceRoll: 'DICE_ROLL'
} as const;

export type CharacterActionType = typeof CharacterActionType[keyof typeof CharacterActionType];


/**
 * 
 * @export
 * @interface CharacterAttribute
 */
export interface CharacterAttribute {
    /**
     * 
     * @type {NameEnum}
     * @memberof CharacterAttribute
     */
    'name': NameEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterAttribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterAttribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface CharacterBioDraft
 */
export interface CharacterBioDraft {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraft
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraft
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterBioDraftRequest
 */
export interface CharacterBioDraftRequest {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraftRequest
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraftRequest
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterCurrency
 */
export interface CharacterCurrency {
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'character': string;
    /**
     * 
     * @type {CurrencyToken}
     * @memberof CharacterCurrency
     */
    'currency': CurrencyToken;
    /**
     * 
     * @type {number}
     * @memberof CharacterCurrency
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CharacterExample1GameEvent
 */
export interface CharacterExample1GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample1GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample1GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample1GameEventData}
     * @memberof CharacterExample1GameEvent
     */
    'data': CharacterExample1GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample1GameEventData
 */
export interface CharacterExample1GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEventData
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface CharacterExample2GameEvent
 */
export interface CharacterExample2GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample2GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample2GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample2GameEventData}
     * @memberof CharacterExample2GameEvent
     */
    'data': CharacterExample2GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample2GameEventData
 */
export interface CharacterExample2GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEventData
     */
    'field2': string;
}
/**
 * 
 * @export
 * @interface CharacterGenericData
 */
export interface CharacterGenericData {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraft}
     * @memberof CharacterGenericData
     */
    'bio': CharacterBioDraft;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericData
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStat>}
     * @memberof CharacterGenericData
     */
    'stats': Array<CharacterStat>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericData
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterGenericDataRequest
 */
export interface CharacterGenericDataRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraftRequest}
     * @memberof CharacterGenericDataRequest
     */
    'bio': CharacterBioDraftRequest;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericDataRequest
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStatRequest>}
     * @memberof CharacterGenericDataRequest
     */
    'stats': Array<CharacterStatRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericDataRequest
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterInfo
 */
export interface CharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof CharacterInfo
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'fight': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterInfo
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface CharacterItem
 */
export interface CharacterItem {
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'id': string;
    /**
     * 
     * @type {WorldItem}
     * @memberof CharacterItem
     */
    'world_item': WorldItem;
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'character': string;
}
/**
 * 
 * @export
 * @interface CharacterLogActionImpact
 */
export interface CharacterLogActionImpact {
    /**
     * 
     * @type {string}
     * @memberof CharacterLogActionImpact
     */
    'id': string;
    /**
     * 
     * @type {TypeBf3Enum}
     * @memberof CharacterLogActionImpact
     */
    'type': TypeBf3Enum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof CharacterLogActionImpact
     */
    'violation': ImpactViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterLogActionImpact
     */
    'size': number;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterLogActionImpact
     */
    'target': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof CharacterLogActionImpact
     */
    'dice_roll_result': Nested;
}


/**
 * 
 * @export
 * @interface CharacterLogActionImpactRequest
 */
export interface CharacterLogActionImpactRequest {
    /**
     * 
     * @type {TypeBf3Enum}
     * @memberof CharacterLogActionImpactRequest
     */
    'type': TypeBf3Enum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof CharacterLogActionImpactRequest
     */
    'violation': ImpactViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterLogActionImpactRequest
     */
    'size': number;
}


/**
 * 
 * @export
 * @interface CharacterModificator
 */
export interface CharacterModificator {
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'character': string;
    /**
     * 
     * @type {Modificator}
     * @memberof CharacterModificator
     */
    'modificator': Modificator;
}
/**
 * 
 * @export
 * @interface CharacterNewTurnGameEvent
 */
export interface CharacterNewTurnGameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterNewTurnGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterNewTurnGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterNewTurnGameEventData}
     * @memberof CharacterNewTurnGameEvent
     */
    'data': CharacterNewTurnGameEventData;
}


/**
 * 
 * @export
 * @interface CharacterNewTurnGameEventData
 */
export interface CharacterNewTurnGameEventData {
    /**
     * 
     * @type {CurrentTurn}
     * @memberof CharacterNewTurnGameEventData
     */
    'current_turn': CurrentTurn;
    /**
     * 
     * @type {FullCharacterInfo}
     * @memberof CharacterNewTurnGameEventData
     */
    'character_info': FullCharacterInfo;
}
/**
 * 
 * @export
 * @interface CharacterPath
 */
export interface CharacterPath {
    /**
     * 
     * @type {string}
     * @memberof CharacterPath
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterPathRequest
 */
export interface CharacterPathRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterPathRequest
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterStat
 */
export interface CharacterStat {
    /**
     * 
     * @type {string}
     * @memberof CharacterStat
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStat
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterStatRequest
 */
export interface CharacterStatRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterStatRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStatRequest
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterTemplate
 */
export interface CharacterTemplate {
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Bio}
     * @memberof CharacterTemplate
     */
    'bio': Bio;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplate
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'path': string | null;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof CharacterTemplate
     */
    'stats'?: Array<Stat>;
    /**
     * 
     * @type {Array<Modificator>}
     * @memberof CharacterTemplate
     */
    'modificators'?: Array<Modificator>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof CharacterTemplate
     */
    'items'?: Array<Item>;
    /**
     * 
     * @type {Array<School>}
     * @memberof CharacterTemplate
     */
    'schools'?: Array<School>;
    /**
     * 
     * @type {Array<Spell>}
     * @memberof CharacterTemplate
     */
    'spells'?: Array<Spell>;
}
/**
 * 
 * @export
 * @interface CharacterTemplateFull
 */
export interface CharacterTemplateFull {
    /**
     * 
     * @type {CharacterTemplate}
     * @memberof CharacterTemplateFull
     */
    'data': CharacterTemplate;
    /**
     * 
     * @type {CharacterTemplateValidation}
     * @memberof CharacterTemplateFull
     */
    'validation': CharacterTemplateValidation;
}
/**
 * 
 * @export
 * @interface CharacterTemplateValidation
 */
export interface CharacterTemplateValidation {
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_stats_points_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_modificators_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_items_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_spells_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_rank_grade': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_schools_count': number;
}
/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof City
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof City
     */
    'border_with'?: Array<string>;
}
/**
 * \"client\": \"435f309f-32f4-485d-9b88-6c2daca71555\", \"transport\": \"websocket\", \"protocol\": \"json\", \"encoding\": \"json\", \"name\": \"js\"
 * @export
 * @interface ConnectRequest
 */
export interface ConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'transport': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Coordinate
 */
export interface Coordinate {
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface CurrencyToken
 */
export interface CurrencyToken {
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface CurrencyTokenRequest
 */
export interface CurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof CurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface CurrentFight
 */
export interface CurrentFight {
    /**
     * 
     * @type {FightMini}
     * @memberof CurrentFight
     */
    'fight': FightMini;
    /**
     * 
     * @type {Array<FightParticipant>}
     * @memberof CurrentFight
     */
    'allies': Array<FightParticipant>;
    /**
     * 
     * @type {Array<FightParticipant>}
     * @memberof CurrentFight
     */
    'enemies': Array<FightParticipant>;
}
/**
 * 
 * @export
 * @interface CurrentTurn
 */
export interface CurrentTurn {
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'started_at': string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTurn
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field1': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field2': string;
}
/**
 * 
 * @export
 * @interface DiceRollResult
 */
export interface DiceRollResult {
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'dice_side': number;
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'multiplier': number | null;
    /**
     * 
     * @type {RollOutcome}
     * @memberof DiceRollResult
     */
    'outcome': RollOutcome;
}


/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'energy': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Dimension
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface DuelInvitation
 */
export interface DuelInvitation {
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof DuelInvitation
     */
    'is_accepted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DuelInvitation
     */
    'is_rejected': boolean;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof DuelInvitation
     */
    'fight': string | null;
}
/**
 * 
 * @export
 * @interface DuelInvitationRequest
 */
export interface DuelInvitationRequest {
    /**
     * 
     * @type {string}
     * @memberof DuelInvitationRequest
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * 
     * @type {EffectIdEnum}
     * @memberof Effect
     */
    'id'?: EffectIdEnum;
    /**
     * 
     * @type {string}
     * @memberof Effect
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Effect
     */
    'permanent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Effect
     */
    'ends_in'?: number | null;
}


/**
 * * `Knocked out` - Knocked out * `Coma` - Coma * `None` - None * `Burning` - Burning * `Poisoned` - Poisoned * `Sleeping` - Sleeping * `Confused` - Confused * `Paralyzed` - Paralyzed * `Fear` - Fear * `Slowness` - Slowness * `Cold` - Cold
 * @export
 * @enum {string}
 */

export const EffectIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold'
} as const;

export type EffectIdEnum = typeof EffectIdEnum[keyof typeof EffectIdEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const EventCategory = {
    Character: 'character',
    Location: 'location',
    Fight: 'fight',
    Game: 'game'
} as const;

export type EventCategory = typeof EventCategory[keyof typeof EventCategory];


/**
 * 
 * @export
 * @interface Fight
 */
export interface Fight {
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Fight
     */
    'is_open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Fight
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof Fight
     */
    'current_turn'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fight
     */
    'side_a_participants'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fight
     */
    'side_b_participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FightMini
 */
export interface FightMini {
    /**
     * 
     * @type {string}
     * @memberof FightMini
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof FightMini
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FightMini
     */
    'current_turn'?: string | null;
}
/**
 * 
 * @export
 * @interface FightParticipant
 */
export interface FightParticipant {
    /**
     * 
     * @type {string}
     * @memberof FightParticipant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FightParticipant
     */
    'name': string;
    /**
     * 
     * @type {Array<CharacterAttribute>}
     * @memberof FightParticipant
     */
    'attributes': Array<CharacterAttribute>;
    /**
     * 
     * @type {number}
     * @memberof FightParticipant
     */
    'dimension': number;
    /**
     * 
     * @type {number}
     * @memberof FightParticipant
     */
    'rank_grade': number;
}
/**
 * 
 * @export
 * @interface FightRequest
 */
export interface FightRequest {
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FightRequest
     */
    'is_open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FightRequest
     */
    'is_ended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof FightRequest
     */
    'current_turn'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightRequest
     */
    'side_a_participants'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightRequest
     */
    'side_b_participants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FightTurnAction
 */
export interface FightTurnAction {
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnAction
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnAction
     */
    'performed'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof FightTurnAction
     */
    'data'?: any;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof FightTurnAction
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'order': number;
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnAction
     */
    'is_finished': boolean;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'cycle': number;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'initiator': string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'item'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnAction
     */
    'turn': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightTurnAction
     */
    'targets'?: Array<string>;
}


/**
 * 
 * @export
 * @interface FightTurnActionRequest
 */
export interface FightTurnActionRequest {
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnActionRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FightTurnActionRequest
     */
    'performed'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof FightTurnActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof FightTurnActionRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionRequest
     */
    'cycle': number;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionRequest
     */
    'item'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FightTurnActionRequest
     */
    'targets'?: Array<string>;
}


/**
 * 
 * @export
 * @interface FightTurnActionResultGameEvent
 */
export interface FightTurnActionResultGameEvent {
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionResultGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightTurnActionResultGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {TurnActionResultGameEventData}
     * @memberof FightTurnActionResultGameEvent
     */
    'data': TurnActionResultGameEventData;
}


/**
 * 
 * @export
 * @interface FullCharacterInfo
 */
export interface FullCharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<AttributeHolder>}
     * @memberof FullCharacterInfo
     */
    'attributes': Array<AttributeHolder>;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'position': string;
    /**
     * 
     * @type {Coordinate}
     * @memberof FullCharacterInfo
     */
    'coordinates': Coordinate | null;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'fight': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FullCharacterInfo
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface GameEventRequest
 */
export interface GameEventRequest {
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GameEventRequest
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof GameEventRequest
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {Data}
     * @memberof GameEventRequest
     */
    'data': Data;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterAction
 */
export interface GameMasterCharacterAction {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof GameMasterCharacterAction
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionRequest
 */
export interface GameMasterCharacterActionRequest {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof GameMasterCharacterActionRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * * `Male` - Male * `Female` - Female * `Other` - Other
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Other: 'Other'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactType = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactType = typeof ImpactType[keyof typeof ImpactType];


/**
 * * `None` - None * `Knock out` - Knock out * `Damage` - Damage * `Heal` - Heal * `Shield` - Shield * `Buff` - Buff * `Debuff` - Debuff * `Stun` - Stun * `Sleep` - Sleep * `Confusion` - Confusion * `Paralysis` - Paralysis * `Fear` - Fear * `Freeze` - Freeze * `Burn` - Burn * `Poison` - Poison * `Slow` - Slow * `Haste` - Haste * `Blind` - Blind * `Silence` - Silence * `Bleed` - Bleed * `Disarm` - Disarm * `Root` - Root * `Energy Decrease` - Energy Decrease * `Reflect` - Reflect * `Absorb` - Absorb * `Dodge` - Dodge * `Resist` - Resist * `Immunity` - Immunity * `Regeneration` - Regeneration * `Lifesteal` - Lifesteal
 * @export
 * @enum {string}
 */

export const ImpactTypeEnum = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactTypeEnum = typeof ImpactTypeEnum[keyof typeof ImpactTypeEnum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const ImpactViolationEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationEnum = typeof ImpactViolationEnum[keyof typeof ImpactViolationEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactViolationType = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationType = typeof ImpactViolationType[keyof typeof ImpactViolationType];


/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ItemRequest
 */
export interface ItemRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof ItemRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {ItemTypeEnum}
     * @memberof ItemRequest
     */
    'type'?: ItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'base_price'?: number;
}


/**
 * * `weapon` - weapon * `armor` - armor * `artifact` - artifact * `amulet` - amulet * `material` - material * `quest` - quest * `misc` - misc * `food` - food * `rune` - rune
 * @export
 * @enum {string}
 */

export const ItemTypeEnum = {
    Weapon: 'weapon',
    Armor: 'armor',
    Artifact: 'artifact',
    Amulet: 'amulet',
    Material: 'material',
    Quest: 'quest',
    Misc: 'misc',
    Food: 'food',
    Rune: 'rune'
} as const;

export type ItemTypeEnum = typeof ItemTypeEnum[keyof typeof ItemTypeEnum];


/**
 * 
 * @export
 * @interface LearnedSchool
 */
export interface LearnedSchool {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'character': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSchoolRequest
 */
export interface LearnedSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchoolRequest
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSkill
 */
export interface LearnedSkill {
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'character': string;
    /**
     * 
     * @type {OpenaiSkill}
     * @memberof LearnedSkill
     */
    'skill': OpenaiSkill;
}
/**
 * 
 * @export
 * @interface LearnedSkillRequest
 */
export interface LearnedSkillRequest {
    /**
     * 
     * @type {OpenaiSkillRequest}
     * @memberof LearnedSkillRequest
     */
    'skill': OpenaiSkillRequest;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Location
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Modificator
 */
export interface Modificator {
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ModificatorRequest
 */
export interface ModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof ModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof ModificatorRequest
     */
    'stat_modificators': Array<StatModificatorRequest>;
}
/**
 * * `Health` - Health * `Energy` - Energy * `Action Points` - Action Points
 * @export
 * @enum {string}
 */

export const NameEnum = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type NameEnum = typeof NameEnum[keyof typeof NameEnum];


/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof Nested
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'npc'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'polymorphic_ctype': number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'last_safe_position'?: string | null;
}
/**
 * 
 * @export
 * @interface NestedRequest
 */
export interface NestedRequest {
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof NestedRequest
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'npc'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'fight'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'last_safe_position'?: string | null;
}
/**
 * 
 * @export
 * @interface OpenAIClientManagement
 */
export interface OpenAIClientManagement {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'updated_at': string;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OpenAIClientManagement
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_staff': boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'user_permissions'?: Array<number>;
}


/**
 * 
 * @export
 * @interface OpenAIClientManagementRequest
 */
export interface OpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface OpenaiCharacter
 */
export interface OpenaiCharacter {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'name': string;
    /**
     * 
     * @type {OpenaiCharacterBio}
     * @memberof OpenaiCharacter
     */
    'biography': OpenaiCharacterBio;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'npc'?: boolean;
}
/**
 * 
 * @export
 * @interface OpenaiCharacterBio
 */
export interface OpenaiCharacterBio {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterBio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacterBio
     */
    'gender'?: GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'background'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'appearance'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface OpenaiPath
 */
export interface OpenaiPath {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface OpenaiSchool
 */
export interface OpenaiSchool {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSchool
     */
    'is_base'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof OpenaiSchool
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OpenaiSkill
 */
export interface OpenaiSkill {
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {OpenaiSkillTypeEnum}
     * @memberof OpenaiSkill
     */
    'type'?: OpenaiSkillTypeEnum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'effect'?: any;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'school': string | null;
}


/**
 * 
 * @export
 * @interface OpenaiSkillRequest
 */
export interface OpenaiSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'multi_target': boolean;
    /**
     * 
     * @type {OpenaiSkillTypeEnum}
     * @memberof OpenaiSkillRequest
     */
    'type'?: OpenaiSkillTypeEnum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'effect'?: any;
    /**
     * 
     * @type {File}
     * @memberof OpenaiSkillRequest
     */
    'icon'?: File | null;
}


/**
 * * `attack` - attack * `defense` - defense * `heal` - heal * `buff` - buff * `debuff` - debuff * `utility` - utility * `special` - special
 * @export
 * @enum {string}
 */

export const OpenaiSkillTypeEnum = {
    Attack: 'attack',
    Defense: 'defense',
    Heal: 'heal',
    Buff: 'buff',
    Debuff: 'debuff',
    Utility: 'utility',
    Special: 'special'
} as const;

export type OpenaiSkillTypeEnum = typeof OpenaiSkillTypeEnum[keyof typeof OpenaiSkillTypeEnum];


/**
 * 
 * @export
 * @interface PaginatedCharacterActionLogList
 */
export interface PaginatedCharacterActionLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCharacterActionLogList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CharacterActionLog>}
     * @memberof PaginatedCharacterActionLogList
     */
    'results': Array<CharacterActionLog>;
}
/**
 * 
 * @export
 * @interface PaginatedLearnedSkillList
 */
export interface PaginatedLearnedSkillList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLearnedSkillList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LearnedSkill>}
     * @memberof PaginatedLearnedSkillList
     */
    'results': Array<LearnedSkill>;
}
/**
 * 
 * @export
 * @interface PatchedCharacterActionLogRequest
 */
export interface PatchedCharacterActionLogRequest {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof PatchedCharacterActionLogRequest
     */
    'action_type'?: ActionTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PatchedCharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCharacterActionLogRequest
     */
    'performed'?: boolean;
}


/**
 * 
 * @export
 * @interface PatchedCurrencyTokenRequest
 */
export interface PatchedCurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedCurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface PatchedItemRequest
 */
export interface PatchedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedItemRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {ItemTypeEnum}
     * @memberof PatchedItemRequest
     */
    'type'?: ItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'base_price'?: number;
}


/**
 * 
 * @export
 * @interface PatchedModificatorRequest
 */
export interface PatchedModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof PatchedModificatorRequest
     */
    'stat_modificators'?: Array<StatModificatorRequest>;
}
/**
 * 
 * @export
 * @interface PatchedOpenAIClientManagementRequest
 */
export interface PatchedOpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'sub_location': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'location': string;
    /**
     * 
     * @type {any}
     * @memberof Position
     */
    'labels'?: any;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'characters': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'image': string;
}
/**
 * * `openai` - OpenAI * `google` - Google * `local` - Local
 * @export
 * @enum {string}
 */

export const ProviderEnum = {
    Openai: 'openai',
    Google: 'google',
    Local: 'local'
} as const;

export type ProviderEnum = typeof ProviderEnum[keyof typeof ProviderEnum];


/**
 * 
 * @export
 * @interface RegisterImpactAction
 */
export interface RegisterImpactAction {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactAction
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactAction
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegisterImpactActionRequest
 */
export interface RegisterImpactActionRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegistrationForm
 */
export interface RegistrationForm {
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationFormRequest
 */
export interface RegistrationFormRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RollOutcome = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type RollOutcome = typeof RollOutcome[keyof typeof RollOutcome];


/**
 * 
 * @export
 * @interface School
 */
export interface School {
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof School
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface Shield
 */
export interface Shield {
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof Shield
     */
    'id'?: ImpactViolationEnum;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_health'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_efficiency'?: number;
}


/**
 * 
 * @export
 * @interface Spell
 */
export interface Spell {
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'school': string;
    /**
     * 
     * @type {number}
     * @memberof Spell
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface Stat
 */
export interface Stat {
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'value': number;
}
/**
 * * `Physical Strength` - Physical Strength * `Mental Strength` - Mental Strength * `Flow Resonance` - Flow Resonance * `Concentration` - Concentration * `Flow Manipulation` - Flow Manipulation * `Flow Connection` - Flow Connection * `Knowledge` - Knowledge * `Speed` - Speed * `Luck` - Luck * `Charisma` - Charisma
 * @export
 * @enum {string}
 */

export const StatEnum = {
    PhysicalStrength: 'Physical Strength',
    MentalStrength: 'Mental Strength',
    FlowResonance: 'Flow Resonance',
    Concentration: 'Concentration',
    FlowManipulation: 'Flow Manipulation',
    FlowConnection: 'Flow Connection',
    Knowledge: 'Knowledge',
    Speed: 'Speed',
    Luck: 'Luck',
    Charisma: 'Charisma'
} as const;

export type StatEnum = typeof StatEnum[keyof typeof StatEnum];


/**
 * 
 * @export
 * @interface StatModificatorRequest
 */
export interface StatModificatorRequest {
    /**
     * 
     * @type {StatEnum}
     * @memberof StatModificatorRequest
     */
    'stat'?: StatEnum;
    /**
     * 
     * @type {number}
     * @memberof StatModificatorRequest
     */
    'value'?: number;
}


/**
 * 
 * @export
 * @interface SubLocation
 */
export interface SubLocation {
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocation
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'location': string;
}
/**
 * 
 * @export
 * @interface SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeRequest
     */
    'channel': string;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinates
 */
export interface TeleportCoordinates {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_z': number;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinatesRequest
 */
export interface TeleportCoordinatesRequest {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_z': number;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPosition
 */
export interface TeleportPosition {
    /**
     * 
     * @type {string}
     * @memberof TeleportPosition
     */
    'id': string;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPositionRequest
 */
export interface TeleportPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof TeleportPositionRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPairRequest
 */
export interface TokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyRequest
 */
export interface TokenVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TurnActionResultGameEventData
 */
export interface TurnActionResultGameEventData {
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'turn_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'initiator_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'target_id': string;
    /**
     * 
     * @type {ActionModel}
     * @memberof TurnActionResultGameEventData
     */
    'action': ActionModel;
    /**
     * 
     * @type {ActionImpactModel}
     * @memberof TurnActionResultGameEventData
     */
    'impact': ActionImpactModel;
}
/**
 * * `None` - None * `Knock out` - Knock out * `Damage` - Damage * `Heal` - Heal * `Shield` - Shield * `Buff` - Buff * `Debuff` - Debuff * `Stun` - Stun * `Sleep` - Sleep * `Confusion` - Confusion * `Paralysis` - Paralysis * `Fear` - Fear * `Freeze` - Freeze * `Burn` - Burn * `Poison` - Poison * `Slow` - Slow * `Haste` - Haste * `Blind` - Blind * `Silence` - Silence * `Bleed` - Bleed * `Disarm` - Disarm * `Root` - Root * `Energy Decrease` - Energy Decrease * `Reflect` - Reflect * `Absorb` - Absorb * `Dodge` - Dodge * `Resist` - Resist * `Immunity` - Immunity * `Regeneration` - Regeneration * `Lifesteal` - Lifesteal
 * @export
 * @enum {string}
 */

export const TypeBf3Enum = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type TypeBf3Enum = typeof TypeBf3Enum[keyof typeof TypeBf3Enum];


/**
 * 
 * @export
 * @interface WorldItem
 */
export interface WorldItem {
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'id': string;
    /**
     * 
     * @type {Item}
     * @memberof WorldItem
     */
    'item': Item;
    /**
     * 
     * @type {boolean}
     * @memberof WorldItem
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'charges_left'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'campaign'?: string | null;
}

/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate: async (characterActionRequest?: CharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/current_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate: async (characterActionLogRequest?: CharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmDestroy', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedCharacterActionLogRequest} [patchedCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate: async (id: string, patchedCharacterActionLogRequest?: PatchedCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmPartialUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate: async (gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMasterCharacterActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterCharacterActionCreate', 'gameMasterCharacterActionRequest', gameMasterCharacterActionRequest)
            const localVarPath = `/api/action/gm/register_character_action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate: async (registerImpactActionRequest: RegisterImpactActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerImpactActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterImpactCreate', 'registerImpactActionRequest', registerImpactActionRequest)
            const localVarPath = `/api/action/gm/register_impact/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerImpactActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmRetrieve', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate: async (id: string, characterActionLogRequest?: CharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/next_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/scheduled_actions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCreate(characterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCurrentCycleRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCurrentCycleRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmCreate(characterActionLogRequest?: CharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmCreate(characterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedCharacterActionLogRequest} [patchedCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmPartialUpdate(id: string, patchedCharacterActionLogRequest?: PatchedCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmPartialUpdate(id, patchedCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterCharacterActionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterImpactAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterImpactCreate(registerImpactActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterImpactCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmUpdate(id: string, characterActionLogRequest?: CharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmUpdate(id, characterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionLogList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionLogList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionNextCycleCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionNextCycleCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionNextCycleCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionScheduledActionsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionScheduledActionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionApiFp(configuration)
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate(characterActionRequest?: CharacterActionRequest, options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionCreate(characterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve(options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionCurrentCycleRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate(characterActionLogRequest?: CharacterActionLogRequest, options?: any): AxiosPromise<CharacterActionLog> {
            return localVarFp.actionGmCreate(characterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.actionGmDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedCharacterActionLogList> {
            return localVarFp.actionGmList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedCharacterActionLogRequest} [patchedCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate(id: string, patchedCharacterActionLogRequest?: PatchedCharacterActionLogRequest, options?: any): AxiosPromise<CharacterActionLog> {
            return localVarFp.actionGmPartialUpdate(id, patchedCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: any): AxiosPromise<GameMasterCharacterAction> {
            return localVarFp.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: any): AxiosPromise<RegisterImpactAction> {
            return localVarFp.actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve(id: string, options?: any): AxiosPromise<CharacterActionLog> {
            return localVarFp.actionGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {CharacterActionLogRequest} [characterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate(id: string, characterActionLogRequest?: CharacterActionLogRequest, options?: any): AxiosPromise<CharacterActionLog> {
            return localVarFp.actionGmUpdate(id, characterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedCharacterActionLogList> {
            return localVarFp.actionLogList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate(options?: any): AxiosPromise<void> {
            return localVarFp.actionNextCycleCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve(options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionScheduledActionsRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * 
     * @param {CharacterActionRequest} [characterActionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCreate(characterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCurrentCycleRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CharacterActionLogRequest} [characterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmCreate(characterActionLogRequest?: CharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmCreate(characterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {PatchedCharacterActionLogRequest} [patchedCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmPartialUpdate(id: string, patchedCharacterActionLogRequest?: PatchedCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmPartialUpdate(id, patchedCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterImpactActionRequest} registerImpactActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {CharacterActionLogRequest} [characterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmUpdate(id: string, characterActionLogRequest?: CharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmUpdate(id, characterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionLogList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionNextCycleCreate(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionNextCycleCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionScheduledActionsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdaptersApi - axios parameter creator
 * @export
 */
export const AdaptersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate: async (connectRequest: ConnectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoConnectCreate', 'connectRequest', connectRequest)
            const localVarPath = `/api/adapters/centrifugo/connect/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate: async (gameEventRequest: GameEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameEventRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoPublishCreate', 'gameEventRequest', gameEventRequest)
            const localVarPath = `/api/adapters/centrifugo/publish/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoSubscribeCreate', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/api/adapters/centrifugo/subscribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdaptersApi - functional programming interface
 * @export
 */
export const AdaptersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdaptersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoConnectCreate(connectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoConnectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoPublishCreate(gameEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoPublishCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoSubscribeCreate(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoSubscribeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdaptersApi - factory interface
 * @export
 */
export const AdaptersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdaptersApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdaptersApi - object-oriented interface
 * @export
 * @class AdaptersApi
 * @extends {BaseAPI}
 */
export class AdaptersApi extends BaseAPI {
    /**
     * 
     * @param {ConnectRequest} connectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameEventRequest} gameEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate: async (tokenObtainPairRequest: TokenObtainPairRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPairRequest' is not null or undefined
            assertParamExists('authJwtTokenCreate', 'tokenObtainPairRequest', tokenObtainPairRequest)
            const localVarPath = `/auth/jwt/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('authJwtTokenRefreshCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/jwt/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate: async (tokenVerifyRequest: TokenVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyRequest' is not null or undefined
            assertParamExists('authJwtTokenVerifyCreate', 'tokenVerifyRequest', tokenVerifyRequest)
            const localVarPath = `/auth/jwt/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenCreate(tokenObtainPairRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenRefreshCreate(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenVerifyCreate(tokenVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPairRequest} tokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerifyRequest} tokenVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CharacterApi - axios parameter creator
 * @export
 */
export const CharacterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmCharacterInfoRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/character_info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_template/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate: async (characterPathRequest?: CharacterPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/chose_path/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate: async (characterGenericDataRequest: CharacterGenericDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterGenericDataRequest' is not null or undefined
            assertParamExists('characterPlayerImportCharacterCreate', 'characterGenericDataRequest', characterGenericDataRequest)
            const localVarPath = `/api/character/player/import_character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterGenericDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList: async (npc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterPlayerRetrieve', 'id', id)
            const localVarPath = `/api/character/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterApi - functional programming interface
 * @export
 */
export const CharacterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmCharacterInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterInfoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterTemplateFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterTemplateRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterTemplateRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerChosePathCreate(characterPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerChosePathCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterGenericData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerImportCharacterCreate(characterGenericDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerImportCharacterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerList(npc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CharacterApi - factory interface
 * @export
 */
export const CharacterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterGmCharacterInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterGmList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve(options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterPlayerCharacterInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve(options?: any): AxiosPromise<CharacterTemplateFull> {
            return localVarFp.characterPlayerCharacterTemplateRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: any): AxiosPromise<CharacterPath> {
            return localVarFp.characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: any): AxiosPromise<CharacterGenericData> {
            return localVarFp.characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList(npc?: boolean, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterPlayerList(npc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterApi - object-oriented interface
 * @export
 * @class CharacterApi
 * @extends {BaseAPI}
 */
export class CharacterApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmCharacterInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterTemplateRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CharacterPathRequest} [characterPathRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new character for the user.
     * @param {CharacterGenericDataRequest} characterGenericDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerList(npc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate: async (openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientCreate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientDestroy', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate: async (id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientPartialUpdate', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate: async (registrationFormRequest: RegistrationFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationFormRequest' is not null or undefined
            assertParamExists('clientRegisterLocalClientCreate', 'registrationFormRequest', registrationFormRequest)
            const localVarPath = `/api/client/register_local_client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientRetrieve', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate: async (id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientUpdate', 'id', id)
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientUpdate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCreate(openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenAIClientManagement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRegisterLocalClientCreate(registrationFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRegisterLocalClientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientUpdate(id, openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientCreate(openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList(options?: any): AxiosPromise<Array<OpenAIClientManagement>> {
            return localVarFp.clientList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: any): AxiosPromise<RegistrationForm> {
            return localVarFp.clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve(id: string, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCreate(openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientList(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegistrationFormRequest} registrationFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 * @export
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/character/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreCharacterStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreCharacterStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreCharacterStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList(options?: any): AxiosPromise<Array<CharacterStat>> {
            return localVarFp.coreCharacterStatsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreCharacterStatsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreCharacterStatsList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyCharacterRetrieve', 'id', id)
            const localVarPath = `/api/currency/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate: async (currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldCreate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldDestroy', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate: async (id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCurrencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldRetrieve', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate: async (id: string, currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'id', id)
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldCreate(currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencyToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldUpdate(id, currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList(options?: any): AxiosPromise<Array<CharacterCurrency>> {
            return localVarFp.currencyCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.currencyCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldCreate(currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.currencyWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList(options?: any): AxiosPromise<Array<CurrencyToken>> {
            return localVarFp.currencyWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve(id: string, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldCreate(currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/effects/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('effectsActiveRetrieve', 'id', id)
            const localVarPath = `/api/effects/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveEffect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList(options?: any): AxiosPromise<Array<ActiveEffect>> {
            return localVarFp.effectsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.effectsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveList(options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FightApi - axios parameter creator
 * @export
 */
export const FightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightActionCreate: async (fightTurnActionRequest: FightTurnActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fightTurnActionRequest' is not null or undefined
            assertParamExists('fightActionCreate', 'fightTurnActionRequest', fightTurnActionRequest)
            const localVarPath = `/api/fight/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightTurnActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/fight/fight/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightHistoryRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/fight/fight/history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToAttackerSideCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightJoinToAttackerSideCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightJoinToAttackerSideCreate', 'fightRequest', fightRequest)
            const localVarPath = `/api/fight/fight/{id}/join_to_attacker_side/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToDefenderSideCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightJoinToDefenderSideCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightJoinToDefenderSideCreate', 'fightRequest', fightRequest)
            const localVarPath = `/api/fight/fight/{id}/join_to_defender_side/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightLeaveCreate: async (id: string, fightRequest: FightRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightLeaveCreate', 'id', id)
            // verify required parameter 'fightRequest' is not null or undefined
            assertParamExists('fightFightLeaveCreate', 'fightRequest', fightRequest)
            const localVarPath = `/api/fight/fight/{id}/leave/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fightRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightFightRetrieve', 'id', id)
            const localVarPath = `/api/fight/fight/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationAcceptCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationAcceptCreate', 'id', id)
            const localVarPath = `/api/fight/invitation/{id}/accept/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationCreate: async (duelInvitationRequest: DuelInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duelInvitationRequest' is not null or undefined
            assertParamExists('fightInvitationCreate', 'duelInvitationRequest', duelInvitationRequest)
            const localVarPath = `/api/fight/invitation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duelInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/fight/invitation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRejectCreate: async (id: string, duelInvitationRequest: DuelInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationRejectCreate', 'id', id)
            // verify required parameter 'duelInvitationRequest' is not null or undefined
            assertParamExists('fightInvitationRejectCreate', 'duelInvitationRequest', duelInvitationRequest)
            const localVarPath = `/api/fight/invitation/{id}/reject/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duelInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fightInvitationRetrieve', 'id', id)
            const localVarPath = `/api/fight/invitation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FightApi - functional programming interface
 * @export
 */
export const FightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FightApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FightTurnAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightActionCreate(fightTurnActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightActionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentFight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightHistoryRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightHistoryRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightHistoryRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightJoinToAttackerSideCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightJoinToAttackerSideCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightJoinToDefenderSideCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightJoinToDefenderSideCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightLeaveCreate(id, fightRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightLeaveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightFightRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightFightRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightFightRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationAcceptCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationAcceptCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationAcceptCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationCreate(duelInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DuelInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationRejectCreate(id, duelInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationRejectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fightInvitationRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuelInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fightInvitationRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FightApi.fightInvitationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FightApi - factory interface
 * @export
 */
export const FightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FightApiFp(configuration)
    return {
        /**
         * 
         * @param {FightTurnActionRequest} fightTurnActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: any): AxiosPromise<FightTurnAction> {
            return localVarFp.fightActionCreate(fightTurnActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightCurrentRetrieve(options?: any): AxiosPromise<CurrentFight> {
            return localVarFp.fightFightCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightHistoryRetrieve(options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightHistoryRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightJoinToAttackerSideCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightJoinToDefenderSideCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {FightRequest} fightRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightLeaveCreate(id, fightRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this fight.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightFightRetrieve(id: string, options?: any): AxiosPromise<Fight> {
            return localVarFp.fightFightRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationAcceptCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.fightInvitationAcceptCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationCreate(duelInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationList(options?: any): AxiosPromise<Array<DuelInvitation>> {
            return localVarFp.fightInvitationList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {DuelInvitationRequest} duelInvitationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationRejectCreate(id, duelInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this duel invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fightInvitationRetrieve(id: string, options?: any): AxiosPromise<DuelInvitation> {
            return localVarFp.fightInvitationRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FightApi - object-oriented interface
 * @export
 * @class FightApi
 * @extends {BaseAPI}
 */
export class FightApi extends BaseAPI {
    /**
     * 
     * @param {FightTurnActionRequest} fightTurnActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightActionCreate(fightTurnActionRequest: FightTurnActionRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightActionCreate(fightTurnActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightHistoryRetrieve(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightHistoryRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightJoinToAttackerSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightJoinToAttackerSideCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightJoinToDefenderSideCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightJoinToDefenderSideCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {FightRequest} fightRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightLeaveCreate(id: string, fightRequest: FightRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightLeaveCreate(id, fightRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this fight.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightFightRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightFightRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationAcceptCreate(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationAcceptCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DuelInvitationRequest} duelInvitationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationCreate(duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationCreate(duelInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationList(options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {DuelInvitationRequest} duelInvitationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationRejectCreate(id: string, duelInvitationRequest: DuelInvitationRequest, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationRejectCreate(id, duelInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this duel invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FightApi
     */
    public fightInvitationRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return FightApiFp(this.configuration).fightInvitationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GalleryApi - axios parameter creator
 * @export
 */
export const GalleryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gallery/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('galleryWorldRetrieve', 'id', id)
            const localVarPath = `/api/gallery/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GalleryApi - functional programming interface
 * @export
 */
export const GalleryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GalleryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Art>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Art>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GalleryApi - factory interface
 * @export
 */
export const GalleryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GalleryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList(options?: any): AxiosPromise<Array<Art>> {
            return localVarFp.galleryWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve(id: string, options?: any): AxiosPromise<Art> {
            return localVarFp.galleryWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GalleryApi - object-oriented interface
 * @export
 * @class GalleryApi
 * @extends {BaseAPI}
 */
export class GalleryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldList(options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this art.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/items/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate: async (itemRequest: ItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemRequest' is not null or undefined
            assertParamExists('itemsWorldCreate', 'itemRequest', itemRequest)
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldDestroy', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate: async (id: string, patchedItemRequest?: PatchedItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldRetrieve', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate: async (id: string, itemRequest: ItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'id', id)
            // verify required parameter 'itemRequest' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'itemRequest', itemRequest)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldCreate(itemRequest: ItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldCreate(itemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldPartialUpdate(id, patchedItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldUpdate(id: string, itemRequest: ItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldUpdate(id, itemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList(options?: any): AxiosPromise<Array<CharacterItem>> {
            return localVarFp.itemsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.itemsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate(itemRequest: ItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.itemsWorldCreate(itemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList(options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.itemsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.itemsWorldPartialUpdate(id, patchedItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve(id: string, options?: any): AxiosPromise<Item> {
            return localVarFp.itemsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate(id: string, itemRequest: ItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.itemsWorldUpdate(id, itemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemRequest} itemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldCreate(itemRequest: ItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldCreate(itemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this item.
     * @param {PatchedItemRequest} [patchedItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldPartialUpdate(id, patchedItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this item.
     * @param {ItemRequest} itemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldUpdate(id: string, itemRequest: ItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldUpdate(id, itemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModificatorsApi - axios parameter creator
 * @export
 */
export const ModificatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/modificators/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate: async (modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldCreate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldDestroy', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/get_all_modificators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate: async (id: string, patchedModificatorRequest?: PatchedModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedModificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldRetrieve', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate: async (id: string, modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'id', id)
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModificatorsApi - functional programming interface
 * @export
 */
export const ModificatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModificatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterModificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterModificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldCreate(modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldGetAllModificatorsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldGetAllModificatorsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Modificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldUpdate(id, modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModificatorsApi - factory interface
 * @export
 */
export const ModificatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModificatorsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList(options?: any): AxiosPromise<Array<CharacterModificator>> {
            return localVarFp.modificatorsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterModificator> {
            return localVarFp.modificatorsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldCreate(modificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.modificatorsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve(options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList(options?: any): AxiosPromise<Array<Modificator>> {
            return localVarFp.modificatorsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve(id: string, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModificatorsApi - object-oriented interface
 * @export
 * @class ModificatorsApi
 * @extends {BaseAPI}
 */
export class ModificatorsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldCreate(modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/get_all_paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolPathsRetrieve', 'id', id)
            const localVarPath = `/api/school/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate: async (id: string, openaiSkillRequest: OpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'id', id)
            // verify required parameter 'openaiSkillRequest' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'openaiSkillRequest', openaiSkillRequest)
            const localVarPath = `/api/school/schools/{id}/create_skill/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/school/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsGetAllSchoolSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/get_all_school_skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsList', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve: async (id: string, schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'id', id)
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsGetAllPathsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsGetAllPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsCreateSkillCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSchoolsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSkillsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsList(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsRetrieve(id, schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve(options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.schoolPathsGetAllPathsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList(options?: any): AxiosPromise<Array<OpenaiPath>> {
            return localVarFp.schoolPathsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.schoolPathsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList(options?: any): AxiosPromise<Array<OpenaiSchool>> {
            return localVarFp.schoolSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList(schoolPk: string, options?: any): AxiosPromise<Array<OpenaiSkill>> {
            return localVarFp.schoolSchoolsSkillsList(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsGetAllPathsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {OpenaiSkillRequest} openaiSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsList(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShieldsApi - axios parameter creator
 * @export
 */
export const ShieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shields/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shieldsActiveRetrieve', 'id', id)
            const localVarPath = `/api/shields/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShieldsApi - functional programming interface
 * @export
 */
export const ShieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveShield>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveShield>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShieldsApi - factory interface
 * @export
 */
export const ShieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShieldsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList(options?: any): AxiosPromise<Array<ActiveShield>> {
            return localVarFp.shieldsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveShield> {
            return localVarFp.shieldsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShieldsApi - object-oriented interface
 * @export
 * @class ShieldsApi
 * @extends {BaseAPI}
 */
export class ShieldsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveList(options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active shield.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList: async (character?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/gm/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (character !== undefined) {
                localVarQueryParameter['character'] = character;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsGmSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/gm/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate: async (learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('skillsShoolsCreate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsDestroy', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsRetrieve', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate: async (learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('skillsSkillsCreate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsDestroy', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLearnedSkillList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsList(character, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsCreate(learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsCreate(learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedLearnedSkillList> {
            return localVarFp.skillsGmSkillsList(character, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsGmSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsShoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList(options?: any): AxiosPromise<Array<LearnedSchool>> {
            return localVarFp.skillsShoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve(id: string, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList(options?: any): AxiosPromise<Array<LearnedSkill>> {
            return localVarFp.skillsSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * 
     * @param {string} [character] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsList(character, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorldApi - axios parameter creator
 * @export
 */
export const WorldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldAreasRetrieve', 'id', id)
            const localVarPath = `/api/world/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldCitiesRetrieve', 'id', id)
            const localVarPath = `/api/world/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldDimensionsRetrieve', 'id', id)
            const localVarPath = `/api/world/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsChangeCreate', 'id', id)
            const localVarPath = `/api/world/locations/{id}/change/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsRetrieve', 'id', id)
            const localVarPath = `/api/world/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionInfoRetrieve', 'id', id)
            const localVarPath = `/api/world/position/{id}/info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionMoveToPositionCreate', 'id', id)
            const localVarPath = `/api/world/position/{id}/move_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate: async (id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'id', id)
            // verify required parameter 'teleportCoordinatesRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'teleportCoordinatesRequest', teleportCoordinatesRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_coordinates/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate: async (id: string, teleportPositionRequest: TeleportPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'id', id)
            // verify required parameter 'teleportPositionRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'teleportPositionRequest', teleportPositionRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldApi - functional programming interface
 * @export
 */
export const WorldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dimension>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsChangeCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsChangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMoveToPositionCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMoveToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportCoordinates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToCoordinatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorldApi - factory interface
 * @export
 */
export const WorldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorldApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve(options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList(options?: any): AxiosPromise<Array<Area>> {
            return localVarFp.worldAreasList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve(id: string, options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve(options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList(options?: any): AxiosPromise<Array<City>> {
            return localVarFp.worldCitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve(id: string, options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve(options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList(options?: any): AxiosPromise<Array<Dimension>> {
            return localVarFp.worldDimensionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve(id: number, options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldLocationsChangeCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve(options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList(options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.worldLocationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve(id: string, options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve(options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve(options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldPositionMoveToPositionCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: any): AxiosPromise<TeleportCoordinates> {
            return localVarFp.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: any): AxiosPromise<TeleportPosition> {
            return localVarFp.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorldApi - object-oriented interface
 * @export
 * @class WorldApi
 * @extends {BaseAPI}
 */
export class WorldApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsChangeCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current position of the character and possible movements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the map of the current location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMoveToPositionCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportPositionRequest} teleportPositionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



