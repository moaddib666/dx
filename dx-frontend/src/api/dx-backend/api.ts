/* tslint:disable */
/* eslint-disable */
/**
 * DigitalX Game API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionImpactModel
 */
export interface ActionImpactModel {
    /**
     * 
     * @type {ImpactType}
     * @memberof ActionImpactModel
     */
    'type': ImpactType;
    /**
     * 
     * @type {ImpactViolationType}
     * @memberof ActionImpactModel
     */
    'violation': ImpactViolationType;
    /**
     * 
     * @type {number}
     * @memberof ActionImpactModel
     */
    'size': number;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof ActionImpactModel
     */
    'dice_roll_result': DiceRollResult;
}


/**
 * 
 * @export
 * @interface ActionModel
 */
export interface ActionModel {
    /**
     * 
     * @type {CharacterActionType}
     * @memberof ActionModel
     */
    'action_type': CharacterActionType;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'initiator_id': string;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'skill_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_dimension_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'target_location_id': string | null;
}


/**
 * * `USE_SKILL` - USE_SKILL * `USE_ITEM` - USE_ITEM * `DIMENSION_SHIFT` - DIMENSION_SHIFT * `CHANGE_POSITION` - CHANGE_POSITION * `START_DIALOGUE` - START_DIALOGUE * `MAKE_DUEL_INVITATION` - MAKE_DUEL_INVITATION * `ACCEPT_DUEL_INVITATION` - ACCEPT_DUEL_INVITATION * `REJECT_DUEL_INVITATION` - REJECT_DUEL_INVITATION * `START_FIGHT` - START_FIGHT * `MOVE` - MOVE * `DICE_ROLL` - DICE_ROLL * `GIFT` - GIFT * `ANOMALY` - ANOMALY * `LONG_REST` - LONG_REST * `BACK_TO_SAFE_ZONE` - BACK_TO_SAFE_ZONE * `INSPECT` - INSPECT * `SNATCH_ITEM` - SNATCH_ITEM
 * @export
 * @enum {string}
 */

export const ActionType46dEnum = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    DiceRoll: 'DICE_ROLL',
    Gift: 'GIFT',
    Anomaly: 'ANOMALY',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM'
} as const;

export type ActionType46dEnum = typeof ActionType46dEnum[keyof typeof ActionType46dEnum];


/**
 * 
 * @export
 * @interface ActiveEffect
 */
export interface ActiveEffect {
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'id': string;
    /**
     * 
     * @type {Effect}
     * @memberof ActiveEffect
     */
    'effect': Effect;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'cycle_left': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'ends_in'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffect
     */
    'duration'?: number;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    'impact'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveEffect
     */
    'active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffect
     */
    '_data'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ActiveEffect
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ActiveEffectRequest
 */
export interface ActiveEffectRequest {
    /**
     * 
     * @type {EffectRequest}
     * @memberof ActiveEffectRequest
     */
    'effect': EffectRequest;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffectRequest
     */
    'cycle_left': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffectRequest
     */
    'ends_in'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveEffectRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffectRequest
     */
    'impact'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveEffectRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ActiveEffectRequest
     */
    '_data'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof ActiveEffectRequest
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ActiveShield
 */
export interface ActiveShield {
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'id': string;
    /**
     * 
     * @type {Shield}
     * @memberof ActiveShield
     */
    'shield': Shield;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'efficiency': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'cycles_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveShield
     */
    'health'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActiveShield
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'id': string;
    /**
     * 
     * @type {Array<SubLocation>}
     * @memberof Area
     */
    'sub_locations': Array<SubLocation>;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Area
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    'city': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Area
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AreaRequest
 */
export interface AreaRequest {
    /**
     * 
     * @type {string}
     * @memberof AreaRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AreaRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof AreaRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof AreaRequest
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof AreaRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AreaRequest
     */
    'city': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AreaRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Art
 */
export interface Art {
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Art
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {AttributeNameEnum}
     * @memberof Attribute
     */
    'name': AttributeNameEnum;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    'max': number;
}


/**
 * 
 * @export
 * @interface AttributeHolder
 */
export interface AttributeHolder {
    /**
     * 
     * @type {AttributeType}
     * @memberof AttributeHolder
     */
    'name': AttributeType;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'current': number | null;
    /**
     * 
     * @type {number}
     * @memberof AttributeHolder
     */
    'max': number | null;
}


/**
 * * `Health` - Health * `Energy` - Energy * `Action Points` - Action Points
 * @export
 * @enum {string}
 */

export const AttributeNameEnum = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributeNameEnum = typeof AttributeNameEnum[keyof typeof AttributeNameEnum];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * 
     * @type {AttributeNameEnum}
     * @memberof AttributeRequest
     */
    'name': AttributeNameEnum;
    /**
     * 
     * @type {number}
     * @memberof AttributeRequest
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof AttributeRequest
     */
    'max': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AttributeType = {
    Health: 'Health',
    Energy: 'Energy',
    ActionPoints: 'Action Points'
} as const;

export type AttributeType = typeof AttributeType[keyof typeof AttributeType];


/**
 * 
 * @export
 * @interface Bargain
 */
export interface Bargain {
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'id': string;
    /**
     * 
     * @type {Array<OfferedItem>}
     * @memberof Bargain
     */
    'side_a_offered_items': Array<OfferedItem>;
    /**
     * 
     * @type {Array<OfferedItem>}
     * @memberof Bargain
     */
    'side_b_offered_items': Array<OfferedItem>;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'side_a_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'side_b_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bargain
     */
    'completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'side_a'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bargain
     */
    'side_b'?: string | null;
}
/**
 * 
 * @export
 * @interface BargainCreateRequest
 */
export interface BargainCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof BargainCreateRequest
     */
    'target_character_id': string;
}
/**
 * * `Passive` - Passive * `Aggressive` - Aggressive * `Friendly` - Friendly
 * @export
 * @enum {string}
 */

export const BehaviorEnum = {
    Passive: 'Passive',
    Aggressive: 'Aggressive',
    Friendly: 'Friendly'
} as const;

export type BehaviorEnum = typeof BehaviorEnum[keyof typeof BehaviorEnum];


/**
 * 
 * @export
 * @interface Bio
 */
export interface Bio {
    /**
     * 
     * @type {number}
     * @memberof Bio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof Bio
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof Bio
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterAction
 */
export interface CharacterAction {
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof CharacterAction
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface CharacterActionLog
 */
export interface CharacterActionLog {
    /**
     * 
     * @type {string}
     * @memberof CharacterActionLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionLog
     */
    'initiator': string;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof CharacterActionLog
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionLog
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionLog
     */
    'data'?: any;
    /**
     * 
     * @type {Array<CharacterLogActionImpact>}
     * @memberof CharacterActionLog
     */
    'impacts': Array<CharacterLogActionImpact>;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionLog
     */
    'cycle': number;
}


/**
 * 
 * @export
 * @interface CharacterActionRequest
 */
export interface CharacterActionRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof CharacterActionRequest
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof CharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CharacterActionType = {
    UseSkill: 'USE_SKILL',
    UseItem: 'USE_ITEM',
    DimensionShift: 'DIMENSION_SHIFT',
    ChangePosition: 'CHANGE_POSITION',
    StartDialogue: 'START_DIALOGUE',
    MakeDuelInvitation: 'MAKE_DUEL_INVITATION',
    AcceptDuelInvitation: 'ACCEPT_DUEL_INVITATION',
    RejectDuelInvitation: 'REJECT_DUEL_INVITATION',
    StartFight: 'START_FIGHT',
    Move: 'MOVE',
    DiceRoll: 'DICE_ROLL',
    Gift: 'GIFT',
    Anomaly: 'ANOMALY',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE',
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM'
} as const;

export type CharacterActionType = typeof CharacterActionType[keyof typeof CharacterActionType];


/**
 * 
 * @export
 * @interface CharacterBioDraft
 */
export interface CharacterBioDraft {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraft
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraft
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraft
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterBioDraftRequest
 */
export interface CharacterBioDraftRequest {
    /**
     * 
     * @type {number}
     * @memberof CharacterBioDraftRequest
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof CharacterBioDraftRequest
     */
    'gender': GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'appearance': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterBioDraftRequest
     */
    'background': string;
}


/**
 * 
 * @export
 * @interface CharacterCurrency
 */
export interface CharacterCurrency {
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterCurrency
     */
    'character': string;
    /**
     * 
     * @type {CurrencyToken}
     * @memberof CharacterCurrency
     */
    'currency': CurrencyToken;
    /**
     * 
     * @type {number}
     * @memberof CharacterCurrency
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CharacterCurrencyRequest
 */
export interface CharacterCurrencyRequest {
    /**
     * 
     * @type {CurrencyTokenRequest}
     * @memberof CharacterCurrencyRequest
     */
    'currency': CurrencyTokenRequest;
}
/**
 * 
 * @export
 * @interface CharacterExample1GameEvent
 */
export interface CharacterExample1GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample1GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample1GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample1GameEventData}
     * @memberof CharacterExample1GameEvent
     */
    'data': CharacterExample1GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample1GameEventData
 */
export interface CharacterExample1GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample1GameEventData
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface CharacterExample2GameEvent
 */
export interface CharacterExample2GameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterExample2GameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterExample2GameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterExample2GameEventData}
     * @memberof CharacterExample2GameEvent
     */
    'data': CharacterExample2GameEventData;
}


/**
 * 
 * @export
 * @interface CharacterExample2GameEventData
 */
export interface CharacterExample2GameEventData {
    /**
     * 
     * @type {string}
     * @memberof CharacterExample2GameEventData
     */
    'field2': string;
}
/**
 * 
 * @export
 * @interface CharacterGenericData
 */
export interface CharacterGenericData {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraft}
     * @memberof CharacterGenericData
     */
    'bio': CharacterBioDraft;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericData
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericData
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStat>}
     * @memberof CharacterGenericData
     */
    'stats': Array<CharacterStat>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericData
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericData
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterGenericDataRequest
 */
export interface CharacterGenericDataRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'tags': Array<string>;
    /**
     * 
     * @type {CharacterBioDraftRequest}
     * @memberof CharacterGenericDataRequest
     */
    'bio': CharacterBioDraftRequest;
    /**
     * 
     * @type {number}
     * @memberof CharacterGenericDataRequest
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterGenericDataRequest
     */
    'path': string;
    /**
     * 
     * @type {Array<CharacterStatRequest>}
     * @memberof CharacterGenericDataRequest
     */
    'stats': Array<CharacterStatRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'modificators': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'items': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterGenericDataRequest
     */
    'schools': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterGenericDataRequest
     */
    'spells': Array<number>;
}
/**
 * 
 * @export
 * @interface CharacterInfo
 */
export interface CharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof CharacterInfo
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfo
     */
    'fight': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterInfo
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface CharacterInfoRequest
 */
export interface CharacterInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfoRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfoRequest
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof CharacterInfoRequest
     */
    'attributes': Array<AttributeRequest>;
    /**
     * 
     * @type {number}
     * @memberof CharacterInfoRequest
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfoRequest
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterInfoRequest
     */
    'fight': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterInfoRequest
     */
    'duel_invitations': Array<string>;
}
/**
 * 
 * @export
 * @interface CharacterItem
 */
export interface CharacterItem {
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'id': string;
    /**
     * 
     * @type {WorldItem}
     * @memberof CharacterItem
     */
    'world_item': WorldItem;
    /**
     * 
     * @type {string}
     * @memberof CharacterItem
     */
    'character': string;
}
/**
 * 
 * @export
 * @interface CharacterItemRequest
 */
export interface CharacterItemRequest {
    /**
     * 
     * @type {WorldItemRequest}
     * @memberof CharacterItemRequest
     */
    'world_item': WorldItemRequest;
}
/**
 * 
 * @export
 * @interface CharacterLogActionImpact
 */
export interface CharacterLogActionImpact {
    /**
     * 
     * @type {string}
     * @memberof CharacterLogActionImpact
     */
    'id': string;
    /**
     * 
     * @type {DiceRollResult}
     * @memberof CharacterLogActionImpact
     */
    'dice_roll_result': DiceRollResult;
    /**
     * 
     * @type {TypeBf3Enum}
     * @memberof CharacterLogActionImpact
     */
    'type': TypeBf3Enum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof CharacterLogActionImpact
     */
    'violation': ImpactViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof CharacterLogActionImpact
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterLogActionImpact
     */
    'target': string;
}


/**
 * 
 * @export
 * @interface CharacterModificator
 */
export interface CharacterModificator {
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CharacterModificator
     */
    'character': string;
    /**
     * 
     * @type {Modificator}
     * @memberof CharacterModificator
     */
    'modificator': Modificator;
}
/**
 * 
 * @export
 * @interface CharacterNewTurnGameEvent
 */
export interface CharacterNewTurnGameEvent {
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterNewTurnGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterNewTurnGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof CharacterNewTurnGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {CharacterNewTurnGameEventData}
     * @memberof CharacterNewTurnGameEvent
     */
    'data': CharacterNewTurnGameEventData;
}


/**
 * 
 * @export
 * @interface CharacterNewTurnGameEventData
 */
export interface CharacterNewTurnGameEventData {
    /**
     * 
     * @type {CurrentTurn}
     * @memberof CharacterNewTurnGameEventData
     */
    'current_turn': CurrentTurn;
    /**
     * 
     * @type {FullCharacterInfo}
     * @memberof CharacterNewTurnGameEventData
     */
    'character_info': FullCharacterInfo;
}
/**
 * 
 * @export
 * @interface CharacterPath
 */
export interface CharacterPath {
    /**
     * 
     * @type {string}
     * @memberof CharacterPath
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterPathRequest
 */
export interface CharacterPathRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterPathRequest
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface CharacterStat
 */
export interface CharacterStat {
    /**
     * 
     * @type {string}
     * @memberof CharacterStat
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStat
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterStatRequest
 */
export interface CharacterStatRequest {
    /**
     * 
     * @type {string}
     * @memberof CharacterStatRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CharacterStatRequest
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CharacterStats
 */
export interface CharacterStats {
    /**
     * 
     * @type {Array<Stat>}
     * @memberof CharacterStats
     */
    'stats': Array<Stat>;
}
/**
 * 
 * @export
 * @interface CharacterTemplate
 */
export interface CharacterTemplate {
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterTemplate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Bio}
     * @memberof CharacterTemplate
     */
    'bio': Bio;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplate
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof CharacterTemplate
     */
    'path': string | null;
    /**
     * 
     * @type {Array<Stat>}
     * @memberof CharacterTemplate
     */
    'stats'?: Array<Stat>;
    /**
     * 
     * @type {Array<Modificator>}
     * @memberof CharacterTemplate
     */
    'modificators'?: Array<Modificator>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof CharacterTemplate
     */
    'items'?: Array<Item>;
    /**
     * 
     * @type {Array<School>}
     * @memberof CharacterTemplate
     */
    'schools'?: Array<School>;
    /**
     * 
     * @type {Array<Spell>}
     * @memberof CharacterTemplate
     */
    'spells'?: Array<Spell>;
}
/**
 * 
 * @export
 * @interface CharacterTemplateFull
 */
export interface CharacterTemplateFull {
    /**
     * 
     * @type {CharacterTemplate}
     * @memberof CharacterTemplateFull
     */
    'data': CharacterTemplate;
    /**
     * 
     * @type {CharacterTemplateValidation}
     * @memberof CharacterTemplateFull
     */
    'validation': CharacterTemplateValidation;
}
/**
 * 
 * @export
 * @interface CharacterTemplateValidation
 */
export interface CharacterTemplateValidation {
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_stats_points_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_modificators_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_items_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_spells_count': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_rank_grade': number;
    /**
     * 
     * @type {number}
     * @memberof CharacterTemplateValidation
     */
    'max_schools_count': number;
}
/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof City
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof City
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CityRequest
 */
export interface CityRequest {
    /**
     * 
     * @type {string}
     * @memberof CityRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CityRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CityRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof CityRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof CityRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CityRequest
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CityRequest
     */
    'border_with'?: Array<string>;
}
/**
 * \"client\": \"435f309f-32f4-485d-9b88-6c2daca71555\", \"transport\": \"websocket\", \"protocol\": \"json\", \"encoding\": \"json\", \"name\": \"js\"
 * @export
 * @interface ConnectRequest
 */
export interface ConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'transport': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Continent
 */
export interface Continent {
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Continent
     */
    'area': number;
    /**
     * 
     * @type {number}
     * @memberof Continent
     */
    'population': number;
    /**
     * 
     * @type {number}
     * @memberof Continent
     */
    'number_of_countries': number;
    /**
     * 
     * @type {boolean}
     * @memberof Continent
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Continent
     */
    'planet': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Continent
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ContinentRequest
 */
export interface ContinentRequest {
    /**
     * 
     * @type {string}
     * @memberof ContinentRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContinentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContinentRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof ContinentRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof ContinentRequest
     */
    'area': number;
    /**
     * 
     * @type {number}
     * @memberof ContinentRequest
     */
    'population': number;
    /**
     * 
     * @type {number}
     * @memberof ContinentRequest
     */
    'number_of_countries': number;
    /**
     * 
     * @type {boolean}
     * @memberof ContinentRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContinentRequest
     */
    'planet': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContinentRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Coordinate
 */
export interface Coordinate {
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof Country
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'continent': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Country
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CountryRequest
 */
export interface CountryRequest {
    /**
     * 
     * @type {string}
     * @memberof CountryRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof CountryRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof CountryRequest
     */
    'area': number;
    /**
     * 
     * @type {boolean}
     * @memberof CountryRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CountryRequest
     */
    'continent': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CountryRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CurrencyToken
 */
export interface CurrencyToken {
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyToken
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface CurrencyTokenRequest
 */
export interface CurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyTokenRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof CurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface CurrentTurn
 */
export interface CurrentTurn {
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTurn
     */
    'started_at': string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTurn
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field2': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'field1': string;
}
/**
 * 
 * @export
 * @interface DetailStat
 */
export interface DetailStat {
    /**
     * 
     * @type {string}
     * @memberof DetailStat
     */
    'id': string;
    /**
     * 
     * @type {Array<DiceRollResult>}
     * @memberof DetailStat
     */
    'dice_rolls': Array<DiceRollResult>;
    /**
     * 
     * @type {StatEnum}
     * @memberof DetailStat
     */
    'name'?: StatEnum;
    /**
     * 
     * @type {number}
     * @memberof DetailStat
     */
    'additional_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof DetailStat
     */
    'base_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof DetailStat
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface DetailedBargain
 */
export interface DetailedBargain {
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'id': string;
    /**
     * 
     * @type {Array<DetailedOfferedItem>}
     * @memberof DetailedBargain
     */
    'side_a_offered_items': Array<DetailedOfferedItem>;
    /**
     * 
     * @type {Array<DetailedOfferedItem>}
     * @memberof DetailedBargain
     */
    'side_b_offered_items': Array<DetailedOfferedItem>;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'side_a_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'side_b_accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedBargain
     */
    'completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'side_a'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedBargain
     */
    'side_b'?: string | null;
}
/**
 * 
 * @export
 * @interface DetailedOfferedItem
 */
export interface DetailedOfferedItem {
    /**
     * 
     * @type {string}
     * @memberof DetailedOfferedItem
     */
    'id': string;
    /**
     * 
     * @type {Nested}
     * @memberof DetailedOfferedItem
     */
    'item': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof DetailedOfferedItem
     */
    'bargain': Nested;
}
/**
 * 
 * @export
 * @interface DiceRollResult
 */
export interface DiceRollResult {
    /**
     * 
     * @type {number}
     * @memberof DiceRollResult
     */
    'dice_side': number;
    /**
     * 
     * @type {OutcomeEnum}
     * @memberof DiceRollResult
     */
    'outcome': OutcomeEnum;
}


/**
 * 
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dimension
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'energy': number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dimension
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Dimension
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface DimensionRequest
 */
export interface DimensionRequest {
    /**
     * 
     * @type {number}
     * @memberof DimensionRequest
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DimensionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof DimensionRequest
     */
    'speed': number;
    /**
     * 
     * @type {number}
     * @memberof DimensionRequest
     */
    'energy': number;
    /**
     * 
     * @type {number}
     * @memberof DimensionRequest
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DimensionRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface Effect
 */
export interface Effect {
    /**
     * 
     * @type {EffectIdEnum}
     * @memberof Effect
     */
    'id'?: EffectIdEnum;
    /**
     * 
     * @type {string}
     * @memberof Effect
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Effect
     */
    'permanent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Effect
     */
    'ends_in'?: number | null;
}


/**
 * * `Knocked out` - Knocked out * `Coma` - Coma * `None` - None * `Burning` - Burning * `Poisoned` - Poisoned * `Sleeping` - Sleeping * `Confused` - Confused * `Paralyzed` - Paralyzed * `Fear` - Fear * `Slowness` - Slowness * `Cold` - Cold * `Cursed` - Cursed * `Blindness` - Blindness * `Haste` - Haste * `Regeneration` - Regeneration * `Blessed` - Blessed * `Arcane Surge` - Arcane Surge * `Marked` - Marked
 * @export
 * @enum {string}
 */

export const EffectIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;

export type EffectIdEnum = typeof EffectIdEnum[keyof typeof EffectIdEnum];


/**
 * 
 * @export
 * @interface EffectRequest
 */
export interface EffectRequest {
    /**
     * 
     * @type {EffectIdEnum}
     * @memberof EffectRequest
     */
    'id'?: EffectIdEnum;
    /**
     * 
     * @type {File}
     * @memberof EffectRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof EffectRequest
     */
    'permanent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EffectRequest
     */
    'ends_in'?: number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EventCategory = {
    Character: 'character',
    Location: 'location',
    Fight: 'fight',
    Game: 'game',
    World: 'world'
} as const;

export type EventCategory = typeof EventCategory[keyof typeof EventCategory];


/**
 * 
 * @export
 * @interface FightTurnActionResultGameEvent
 */
export interface FightTurnActionResultGameEvent {
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FightTurnActionResultGameEvent
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FightTurnActionResultGameEvent
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof FightTurnActionResultGameEvent
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {TurnActionResultGameEventData}
     * @memberof FightTurnActionResultGameEvent
     */
    'data': TurnActionResultGameEventData;
}


/**
 * 
 * @export
 * @interface FullCharacterInfo
 */
export interface FullCharacterInfo {
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'rank_grade': number;
    /**
     * 
     * @type {Array<AttributeHolder>}
     * @memberof FullCharacterInfo
     */
    'attributes': Array<AttributeHolder>;
    /**
     * 
     * @type {number}
     * @memberof FullCharacterInfo
     */
    'dimension': number;
    /**
     * 
     * @type {string}
     * @memberof FullCharacterInfo
     */
    'position': string;
    /**
     * 
     * @type {Coordinate}
     * @memberof FullCharacterInfo
     */
    'coordinates': Coordinate | null;
}
/**
 * 
 * @export
 * @interface GameEventRequest
 */
export interface GameEventRequest {
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GameEventRequest
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameEventRequest
     */
    'id'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof GameEventRequest
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {Data}
     * @memberof GameEventRequest
     */
    'data': Data;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterAction
 */
export interface GameMasterCharacterAction {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterAction
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof GameMasterCharacterAction
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterAction
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterAction
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterAction
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionLog
 */
export interface GameMasterCharacterActionLog {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionLog
     */
    'id': string;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'initiator': Nested;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof GameMasterCharacterActionLog
     */
    'targets': Array<Nested>;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof GameMasterCharacterActionLog
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'skill': Nested;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionLog
     */
    'data'?: any;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'position': Nested;
    /**
     * 
     * @type {Array<GameMasterCharacterLogActionImpact>}
     * @memberof GameMasterCharacterActionLog
     */
    'impacts': Array<GameMasterCharacterLogActionImpact>;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterActionLog
     */
    'cycle': Nested;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionLog
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLog
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionLogRequest
 */
export interface GameMasterCharacterActionLogRequest {
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GameMasterCharacterActionLogRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterActionRequest
 */
export interface GameMasterCharacterActionRequest {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameMasterCharacterActionRequest
     */
    'targets'?: Array<string>;
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof GameMasterCharacterActionRequest
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterActionRequest
     */
    'skill'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof GameMasterCharacterActionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterActionRequest
     */
    'item'?: string | null;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterLogActionImpact
 */
export interface GameMasterCharacterLogActionImpact {
    /**
     * 
     * @type {string}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'id': string;
    /**
     * 
     * @type {TypeBf3Enum}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'type': TypeBf3Enum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'violation': ImpactViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'size': number;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'target': Nested;
    /**
     * 
     * @type {Nested}
     * @memberof GameMasterCharacterLogActionImpact
     */
    'dice_roll_result': Nested;
}


/**
 * 
 * @export
 * @interface GameMasterCharacterLogActionImpactRequest
 */
export interface GameMasterCharacterLogActionImpactRequest {
    /**
     * 
     * @type {TypeBf3Enum}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'type': TypeBf3Enum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'violation': ImpactViolationEnum;
    /**
     * 
     * @type {number}
     * @memberof GameMasterCharacterLogActionImpactRequest
     */
    'size': number;
}


/**
 * 
 * @export
 * @interface GameObject
 */
export interface GameObject {
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GameObject
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GameObject
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'object_type': string;
    /**
     * 
     * @type {string}
     * @memberof GameObject
     */
    'real_instance': string;
}
/**
 * 
 * @export
 * @interface GameObjectRequest
 */
export interface GameObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof GameObjectRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GameObjectRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GameObjectRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GameObjectRequest
     */
    'campaign'?: string | null;
}
/**
 * * `Male` - Male * `Female` - Female * `Other` - Other
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    Male: 'Male',
    Female: 'Female',
    Other: 'Other'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * 
 * @export
 * @interface GenericPosition
 */
export interface GenericPosition {
    /**
     * 
     * @type {string}
     * @memberof GenericPosition
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenericPosition
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof GenericPosition
     */
    'sub_location': string;
}
/**
 * 
 * @export
 * @interface GenericPositionId
 */
export interface GenericPositionId {
    /**
     * 
     * @type {string}
     * @memberof GenericPositionId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GenericPositionIdRequest
 */
export interface GenericPositionIdRequest {
    /**
     * 
     * @type {string}
     * @memberof GenericPositionIdRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactType = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactType = typeof ImpactType[keyof typeof ImpactType];


/**
 * * `None` - None * `Knock out` - Knock out * `Damage` - Damage * `Heal` - Heal * `Shield` - Shield * `Buff` - Buff * `Debuff` - Debuff * `Stun` - Stun * `Sleep` - Sleep * `Confusion` - Confusion * `Paralysis` - Paralysis * `Fear` - Fear * `Freeze` - Freeze * `Burn` - Burn * `Poison` - Poison * `Slow` - Slow * `Haste` - Haste * `Blind` - Blind * `Silence` - Silence * `Bleed` - Bleed * `Disarm` - Disarm * `Root` - Root * `Energy Decrease` - Energy Decrease * `Reflect` - Reflect * `Absorb` - Absorb * `Dodge` - Dodge * `Resist` - Resist * `Immunity` - Immunity * `Regeneration` - Regeneration * `Lifesteal` - Lifesteal
 * @export
 * @enum {string}
 */

export const ImpactTypeEnum = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type ImpactTypeEnum = typeof ImpactTypeEnum[keyof typeof ImpactTypeEnum];


/**
 * * `Physical` - Physical * `Mental` - Mental * `Energy` - Energy * `Heat` - Heat * `Cold` - Cold * `Light` - Light * `Darkness` - Darkness * `None` - None
 * @export
 * @enum {string}
 */

export const ImpactViolationEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationEnum = typeof ImpactViolationEnum[keyof typeof ImpactViolationEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactViolationType = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;

export type ImpactViolationType = typeof ImpactViolationType[keyof typeof ImpactViolationType];


/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ItemRequest
 */
export interface ItemRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof ItemRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {ItemTypeEnum}
     * @memberof ItemRequest
     */
    'type'?: ItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemRequest
     */
    'base_price'?: number;
}


/**
 * * `weapon` - weapon * `armor` - armor * `artifact` - artifact * `amulet` - amulet * `material` - material * `quest` - quest * `misc` - misc * `food` - food * `rune` - rune
 * @export
 * @enum {string}
 */

export const ItemTypeEnum = {
    Weapon: 'weapon',
    Armor: 'armor',
    Artifact: 'artifact',
    Amulet: 'amulet',
    Material: 'material',
    Quest: 'quest',
    Misc: 'misc',
    Food: 'food',
    Rune: 'rune'
} as const;

export type ItemTypeEnum = typeof ItemTypeEnum[keyof typeof ItemTypeEnum];


/**
 * 
 * @export
 * @interface LearnedSchool
 */
export interface LearnedSchool {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'character': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSchool
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSchoolRequest
 */
export interface LearnedSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof LearnedSchoolRequest
     */
    'school': string;
}
/**
 * 
 * @export
 * @interface LearnedSkill
 */
export interface LearnedSkill {
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LearnedSkill
     */
    'character': string;
    /**
     * 
     * @type {OpenaiSkill}
     * @memberof LearnedSkill
     */
    'skill': OpenaiSkill;
}
/**
 * 
 * @export
 * @interface LearnedSkillRequest
 */
export interface LearnedSkillRequest {
    /**
     * 
     * @type {OpenaiSkillRequest}
     * @memberof LearnedSkillRequest
     */
    'skill': OpenaiSkillRequest;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Location
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LocationRequest
 */
export interface LocationRequest {
    /**
     * 
     * @type {string}
     * @memberof LocationRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof LocationRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof LocationRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LocationRequest
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LocationRequest
     */
    'area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LocationRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MapPosition
 */
export interface MapPosition {
    /**
     * 
     * @type {GenericPosition}
     * @memberof MapPosition
     */
    'position': GenericPosition;
    /**
     * 
     * @type {boolean}
     * @memberof MapPosition
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof MapPosition
     */
    'labels'?: any | null;
}
/**
 * 
 * @export
 * @interface MapPositionMutableRequest
 */
export interface MapPositionMutableRequest {
    /**
     * 
     * @type {string}
     * @memberof MapPositionMutableRequest
     */
    'position_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MapPositionMutableRequest
     */
    'labels'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MapRequest
 */
export interface MapRequest {
    /**
     * 
     * @type {string}
     * @memberof MapRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MapRequest
     */
    'organization': string;
    /**
     * 
     * @type {boolean}
     * @memberof MapRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface MiniMap
 */
export interface MiniMap {
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'organization': string;
    /**
     * 
     * @type {boolean}
     * @memberof MiniMap
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'positions': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof MiniMap
     */
    'characters': string;
    /**
     * The position of the current user\'s character on the map.
     * @type {string}
     * @memberof MiniMap
     */
    'current_position': string;
}
/**
 * 
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'organization': string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelMap
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'positions': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    'characters': string;
    /**
     * The position of the current user\'s character on the map.
     * @type {string}
     * @memberof ModelMap
     */
    'current_position': string;
}
/**
 * 
 * @export
 * @interface Modificator
 */
export interface Modificator {
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Modificator
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ModificatorRequest
 */
export interface ModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModificatorRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof ModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof ModificatorRequest
     */
    'stat_modificators': Array<StatModificatorRequest>;
}
/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof Nested
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'npc'?: boolean;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof Nested
     */
    'behavior'?: BehaviorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'polymorphic_ctype': number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'last_safe_position'?: string | null;
}


/**
 * 
 * @export
 * @interface NestedRequest
 */
export interface NestedRequest {
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof NestedRequest
     */
    'tags'?: any;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'experience'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_health_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_energy_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'current_active_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'school_slots'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'npc'?: boolean;
    /**
     * 
     * @type {BehaviorEnum}
     * @memberof NestedRequest
     */
    'behavior'?: BehaviorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NestedRequest
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NestedRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'rank'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'place_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedRequest
     */
    'last_safe_position'?: string | null;
}


/**
 * 
 * @export
 * @interface NewCoordinatesRequest
 */
export interface NewCoordinatesRequest {
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof NewCoordinatesRequest
     */
    'grid_z': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewCoordinatesRequest
     */
    'labels'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OfferedItem
 */
export interface OfferedItem {
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'item': string;
    /**
     * 
     * @type {string}
     * @memberof OfferedItem
     */
    'bargain': string;
}
/**
 * 
 * @export
 * @interface OfferedItemRequest
 */
export interface OfferedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof OfferedItemRequest
     */
    'item': string;
}
/**
 * 
 * @export
 * @interface OpenAIClientManagement
 */
export interface OpenAIClientManagement {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'updated_at': string;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OpenAIClientManagement
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenAIClientManagement
     */
    'is_staff': boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagement
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagement
     */
    'user_permissions'?: Array<number>;
}


/**
 * 
 * @export
 * @interface OpenAIClientManagementRequest
 */
export interface OpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof OpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof OpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface OpenaiCharacter
 */
export interface OpenaiCharacter {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacter
     */
    'name': string;
    /**
     * 
     * @type {OpenaiCharacterBio}
     * @memberof OpenaiCharacter
     */
    'biography': OpenaiCharacterBio;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'npc'?: boolean;
    /**
     * 
     * @type {Rank}
     * @memberof OpenaiCharacter
     */
    'rank': Rank;
    /**
     * 
     * @type {ThePath}
     * @memberof OpenaiCharacter
     */
    'path': ThePath;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacter
     */
    'experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof OpenaiCharacter
     */
    'tags'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'resetting_base_stats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiCharacter
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface OpenaiCharacterBio
 */
export interface OpenaiCharacterBio {
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiCharacterBio
     */
    'age': number;
    /**
     * 
     * @type {GenderEnum}
     * @memberof OpenaiCharacterBio
     */
    'gender'?: GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'background'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'appearance'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiCharacterBio
     */
    'character': string;
}


/**
 * 
 * @export
 * @interface OpenaiPath
 */
export interface OpenaiPath {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPath
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface OpenaiPathRequest
 */
export interface OpenaiPathRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof OpenaiPathRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface OpenaiPathWithSchools
 */
export interface OpenaiPathWithSchools {
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'id': string;
    /**
     * 
     * @type {Array<OpenaiSchool>}
     * @memberof OpenaiPathWithSchools
     */
    'schools': Array<OpenaiSchool>;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiPathWithSchools
     */
    'icon'?: string | null;
}
/**
 * 
 * @export
 * @interface OpenaiSchool
 */
export interface OpenaiSchool {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchool
     */
    'icon'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSchool
     */
    'is_base'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof OpenaiSchool
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OpenaiSchoolRequest
 */
export interface OpenaiSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchoolRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchoolRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSchoolRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof OpenaiSchoolRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSchoolRequest
     */
    'is_base'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof OpenaiSchoolRequest
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OpenaiSkill
 */
export interface OpenaiSkill {
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkill
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'multi_target': boolean;
    /**
     * 
     * @type {OpenaiSkillTypeEnum}
     * @memberof OpenaiSkill
     */
    'type'?: OpenaiSkillTypeEnum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkill
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof OpenaiSkill
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'icon'?: string | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof OpenaiSkill
     */
    'immediate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkill
     */
    'school': string | null;
}


/**
 * 
 * @export
 * @interface OpenaiSkillRequest
 */
export interface OpenaiSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OpenaiSkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenaiSkillRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'multi_target': boolean;
    /**
     * 
     * @type {OpenaiSkillTypeEnum}
     * @memberof OpenaiSkillRequest
     */
    'type'?: OpenaiSkillTypeEnum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof OpenaiSkillRequest
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof OpenaiSkillRequest
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {File}
     * @memberof OpenaiSkillRequest
     */
    'icon'?: File | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof OpenaiSkillRequest
     */
    'immediate'?: boolean;
}


/**
 * * `attack` - attack * `defense` - defense * `heal` - heal * `buff` - buff * `debuff` - debuff * `utility` - utility * `special` - special
 * @export
 * @enum {string}
 */

export const OpenaiSkillTypeEnum = {
    Attack: 'attack',
    Defense: 'defense',
    Heal: 'heal',
    Buff: 'buff',
    Debuff: 'debuff',
    Utility: 'utility',
    Special: 'special'
} as const;

export type OpenaiSkillTypeEnum = typeof OpenaiSkillTypeEnum[keyof typeof OpenaiSkillTypeEnum];


/**
 * * `Critical Fail` - Critical Fail * `Critical Success` - Critical Success * `Bad Luck` - Bad Luck * `Base Value` - Base Value * `Good Luck` - Good Luck
 * @export
 * @enum {string}
 */

export const OutcomeEnum = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type OutcomeEnum = typeof OutcomeEnum[keyof typeof OutcomeEnum];


/**
 * 
 * @export
 * @interface PaginatedCharacterActionLogList
 */
export interface PaginatedCharacterActionLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCharacterActionLogList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacterActionLogList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CharacterActionLog>}
     * @memberof PaginatedCharacterActionLogList
     */
    'results': Array<CharacterActionLog>;
}
/**
 * 
 * @export
 * @interface PaginatedGameMasterCharacterActionLogList
 */
export interface PaginatedGameMasterCharacterActionLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GameMasterCharacterActionLog>}
     * @memberof PaginatedGameMasterCharacterActionLogList
     */
    'results': Array<GameMasterCharacterActionLog>;
}
/**
 * 
 * @export
 * @interface PaginatedLearnedSkillList
 */
export interface PaginatedLearnedSkillList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLearnedSkillList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLearnedSkillList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LearnedSkill>}
     * @memberof PaginatedLearnedSkillList
     */
    'results': Array<LearnedSkill>;
}
/**
 * 
 * @export
 * @interface PatchedActiveEffectRequest
 */
export interface PatchedActiveEffectRequest {
    /**
     * 
     * @type {EffectRequest}
     * @memberof PatchedActiveEffectRequest
     */
    'effect'?: EffectRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedActiveEffectRequest
     */
    'cycle_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedActiveEffectRequest
     */
    'ends_in'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedActiveEffectRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {any}
     * @memberof PatchedActiveEffectRequest
     */
    'impact'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedActiveEffectRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof PatchedActiveEffectRequest
     */
    '_data'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedActiveEffectRequest
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface PatchedAreaRequest
 */
export interface PatchedAreaRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedAreaRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAreaRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAreaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedAreaRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedAreaRequest
     */
    'area'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAreaRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedAreaRequest
     */
    'city'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedAreaRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedCharacterCurrencyRequest
 */
export interface PatchedCharacterCurrencyRequest {
    /**
     * 
     * @type {CurrencyTokenRequest}
     * @memberof PatchedCharacterCurrencyRequest
     */
    'currency'?: CurrencyTokenRequest;
}
/**
 * 
 * @export
 * @interface PatchedCharacterInfoRequest
 */
export interface PatchedCharacterInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCharacterInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCharacterInfoRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCharacterInfoRequest
     */
    'rank_grade'?: number;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof PatchedCharacterInfoRequest
     */
    'attributes'?: Array<AttributeRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedCharacterInfoRequest
     */
    'dimension'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCharacterInfoRequest
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCharacterInfoRequest
     */
    'fight'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedCharacterInfoRequest
     */
    'duel_invitations'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedCharacterItemRequest
 */
export interface PatchedCharacterItemRequest {
    /**
     * 
     * @type {WorldItemRequest}
     * @memberof PatchedCharacterItemRequest
     */
    'world_item'?: WorldItemRequest;
}
/**
 * 
 * @export
 * @interface PatchedCityRequest
 */
export interface PatchedCityRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCityRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCityRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCityRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedCityRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCityRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedCityRequest
     */
    'country'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedCityRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedContinentRequest
 */
export interface PatchedContinentRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedContinentRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedContinentRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedContinentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedContinentRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedContinentRequest
     */
    'area'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedContinentRequest
     */
    'population'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedContinentRequest
     */
    'number_of_countries'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedContinentRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedContinentRequest
     */
    'planet'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedContinentRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedCountryRequest
 */
export interface PatchedCountryRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCountryRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCountryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCountryRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedCountryRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedCountryRequest
     */
    'area'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCountryRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedCountryRequest
     */
    'continent'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedCountryRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedCurrencyTokenRequest
 */
export interface PatchedCurrencyTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrencyTokenRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedCurrencyTokenRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface PatchedDimensionRequest
 */
export interface PatchedDimensionRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedDimensionRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDimensionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedDimensionRequest
     */
    'speed'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDimensionRequest
     */
    'energy'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDimensionRequest
     */
    'shift_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDimensionRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedDimensionRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedEffectRequest
 */
export interface PatchedEffectRequest {
    /**
     * 
     * @type {EffectIdEnum}
     * @memberof PatchedEffectRequest
     */
    'id'?: EffectIdEnum;
    /**
     * 
     * @type {File}
     * @memberof PatchedEffectRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedEffectRequest
     */
    'permanent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedEffectRequest
     */
    'ends_in'?: number | null;
}


/**
 * 
 * @export
 * @interface PatchedGameMasterCharacterActionLogRequest
 */
export interface PatchedGameMasterCharacterActionLogRequest {
    /**
     * 
     * @type {ActionType46dEnum}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'action_type'?: ActionType46dEnum;
    /**
     * 
     * @type {any}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'performed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameMasterCharacterActionLogRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface PatchedGameObjectRequest
 */
export interface PatchedGameObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedGameObjectRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedGameObjectRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedGameObjectRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedGameObjectRequest
     */
    'campaign'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedItemRequest
 */
export interface PatchedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedItemRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedItemRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {ItemTypeEnum}
     * @memberof PatchedItemRequest
     */
    'type'?: ItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedItemRequest
     */
    'base_price'?: number;
}


/**
 * 
 * @export
 * @interface PatchedLearnedSchoolRequest
 */
export interface PatchedLearnedSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedLearnedSchoolRequest
     */
    'school'?: string;
}
/**
 * 
 * @export
 * @interface PatchedLearnedSkillRequest
 */
export interface PatchedLearnedSkillRequest {
    /**
     * 
     * @type {OpenaiSkillRequest}
     * @memberof PatchedLearnedSkillRequest
     */
    'skill'?: OpenaiSkillRequest;
}
/**
 * 
 * @export
 * @interface PatchedLocationRequest
 */
export interface PatchedLocationRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedLocationRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedLocationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedLocationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedLocationRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedLocationRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedLocationRequest
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedLocationRequest
     */
    'area'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedLocationRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedMapRequest
 */
export interface PatchedMapRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMapRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMapRequest
     */
    'organization'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMapRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedModificatorRequest
 */
export interface PatchedModificatorRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedModificatorRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedModificatorRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {Array<StatModificatorRequest>}
     * @memberof PatchedModificatorRequest
     */
    'stat_modificators'?: Array<StatModificatorRequest>;
}
/**
 * 
 * @export
 * @interface PatchedOpenAIClientManagementRequest
 */
export interface PatchedOpenAIClientManagementRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_login'?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'main_character'?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'groups'?: Array<number>;
    /**
     * Specific permissions for this user.
     * @type {Array<number>}
     * @memberof PatchedOpenAIClientManagementRequest
     */
    'user_permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedOpenaiPathRequest
 */
export interface PatchedOpenaiPathRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiPathRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiPathRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiPathRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedOpenaiPathRequest
     */
    'icon'?: File | null;
}
/**
 * 
 * @export
 * @interface PatchedOpenaiSchoolRequest
 */
export interface PatchedOpenaiSchoolRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'icon'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'is_base'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedOpenaiSchoolRequest
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedOpenaiSkillRequest
 */
export interface PatchedOpenaiSkillRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSkillRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSkillRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOpenaiSkillRequest
     */
    'grade'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOpenaiSkillRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOpenaiSkillRequest
     */
    'multi_target'?: boolean;
    /**
     * 
     * @type {OpenaiSkillTypeEnum}
     * @memberof PatchedOpenaiSkillRequest
     */
    'type'?: OpenaiSkillTypeEnum;
    /**
     * A list of dictionaries representing the impact of the skill.
     * @type {any}
     * @memberof PatchedOpenaiSkillRequest
     */
    'impact'?: any;
    /**
     * A list of dictionaries representing the cost of the skill.
     * @type {any}
     * @memberof PatchedOpenaiSkillRequest
     */
    'cost'?: any;
    /**
     * A list of dictionaries representing the effects of the skill.
     * @type {any}
     * @memberof PatchedOpenaiSkillRequest
     */
    'effect'?: any;
    /**
     * Special type of the skill  * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
     * @type {SpecialEnum}
     * @memberof PatchedOpenaiSkillRequest
     */
    'special'?: SpecialEnum;
    /**
     * 
     * @type {File}
     * @memberof PatchedOpenaiSkillRequest
     */
    'icon'?: File | null;
    /**
     * If true, the skill will be performed immediately
     * @type {boolean}
     * @memberof PatchedOpenaiSkillRequest
     */
    'immediate'?: boolean;
}


/**
 * 
 * @export
 * @interface PatchedPlanetRequest
 */
export interface PatchedPlanetRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlanetRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlanetRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlanetRequest
     */
    'description'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedPlanetRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'distance_from_star'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'diameter'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'mass'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'gravity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlanetRequest
     */
    'atmosphere'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlanetRequest
     */
    'number_of_moons'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPlanetRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedPlanetRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedPositionRequest
 */
export interface PatchedPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPositionRequest
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionRequest
     */
    'sub_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPositionRequest
     */
    'location'?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchedPositionRequest
     */
    'labels'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPositionRequest
     */
    'is_safe'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedWorldItemRequest
 */
export interface PatchedWorldItemRequest {
    /**
     * 
     * @type {ItemRequest}
     * @memberof PatchedWorldItemRequest
     */
    'item'?: ItemRequest;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedWorldItemRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedWorldItemRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedWorldItemRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedWorldItemRequest
     */
    'campaign'?: string | null;
}
/**
 * 
 * @export
 * @interface Planet
 */
export interface Planet {
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'distance_from_star': number;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'diameter': number;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'mass': number;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'gravity': number;
    /**
     * 
     * @type {string}
     * @memberof Planet
     */
    'atmosphere': string;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'temperature': number;
    /**
     * 
     * @type {number}
     * @memberof Planet
     */
    'number_of_moons': number;
    /**
     * 
     * @type {boolean}
     * @memberof Planet
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Planet
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlanetRequest
 */
export interface PlanetRequest {
    /**
     * 
     * @type {string}
     * @memberof PlanetRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanetRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlanetRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof PlanetRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'distance_from_star': number;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'diameter': number;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'mass': number;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'gravity': number;
    /**
     * 
     * @type {string}
     * @memberof PlanetRequest
     */
    'atmosphere': string;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'temperature': number;
    /**
     * 
     * @type {number}
     * @memberof PlanetRequest
     */
    'number_of_moons': number;
    /**
     * 
     * @type {boolean}
     * @memberof PlanetRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlanetRequest
     */
    'border_with'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'sub_location': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'location': string;
    /**
     * 
     * @type {any}
     * @memberof Position
     */
    'labels'?: any;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'connections': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'characters': string;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof Position
     */
    'is_safe'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'anomalies': string;
}
/**
 * 
 * @export
 * @interface PositionRequest
 */
export interface PositionRequest {
    /**
     * 
     * @type {string}
     * @memberof PositionRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRequest
     */
    'grid_z'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionRequest
     */
    'sub_location': string;
    /**
     * 
     * @type {string}
     * @memberof PositionRequest
     */
    'location': string;
    /**
     * 
     * @type {any}
     * @memberof PositionRequest
     */
    'labels'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PositionRequest
     */
    'is_safe'?: boolean;
}
/**
 * * `openai` - OpenAI * `google` - Google * `local` - Local
 * @export
 * @enum {string}
 */

export const ProviderEnum = {
    Openai: 'openai',
    Google: 'google',
    Local: 'local'
} as const;

export type ProviderEnum = typeof ProviderEnum[keyof typeof ProviderEnum];


/**
 * 
 * @export
 * @interface Rank
 */
export interface Rank {
    /**
     * 
     * @type {string}
     * @memberof Rank
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    'grade'?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    'experience_needed'?: number;
}
/**
 * 
 * @export
 * @interface RegisterImpactAction
 */
export interface RegisterImpactAction {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactAction
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactAction
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactAction
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegisterImpactActionRequest
 */
export interface RegisterImpactActionRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'initiator': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterImpactActionRequest
     */
    'target': string;
    /**
     * 
     * @type {ImpactTypeEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_type': ImpactTypeEnum;
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof RegisterImpactActionRequest
     */
    'impact_violation': ImpactViolationEnum;
}


/**
 * 
 * @export
 * @interface RegistrationForm
 */
export interface RegistrationForm {
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationForm
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationFormRequest
 */
export interface RegistrationFormRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationFormRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RollOutcome = {
    CriticalFail: 'Critical Fail',
    CriticalSuccess: 'Critical Success',
    BadLuck: 'Bad Luck',
    BaseValue: 'Base Value',
    GoodLuck: 'Good Luck'
} as const;

export type RollOutcome = typeof RollOutcome[keyof typeof RollOutcome];


/**
 * 
 * @export
 * @interface School
 */
export interface School {
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof School
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof School
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface Shield
 */
export interface Shield {
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof Shield
     */
    'id'?: ImpactViolationEnum;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'icon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_health'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'base_efficiency'?: number;
}


/**
 * 
 * @export
 * @interface SpecialAction
 */
export interface SpecialAction {
    /**
     * 
     * @type {SpecialActionActionTypeEnum}
     * @memberof SpecialAction
     */
    'action_type': SpecialActionActionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'description': string;
    /**
     * If true, the action will be performed immediately
     * @type {boolean}
     * @memberof SpecialAction
     */
    'immediate'?: boolean;
    /**
     * If true, the action will spend all remaining action points
     * @type {boolean}
     * @memberof SpecialAction
     */
    'final'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SpecialAction
     */
    'icon'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof SpecialAction
     */
    'cost'?: any;
}


/**
 * * `INSPECT` - INSPECT * `SNATCH_ITEM` - SNATCH_ITEM * `BARGAIN` - BARGAIN * `GIFT` - GIFT * `LONG_REST` - LONG_REST * `BACK_TO_SAFE_ZONE` - BACK_TO_SAFE_ZONE
 * @export
 * @enum {string}
 */

export const SpecialActionActionTypeEnum = {
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM',
    Bargain: 'BARGAIN',
    Gift: 'GIFT',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE'
} as const;

export type SpecialActionActionTypeEnum = typeof SpecialActionActionTypeEnum[keyof typeof SpecialActionActionTypeEnum];


/**
 * * `ACTION` - ACTION * `TELEPORT` - TELEPORT * `TELEPORT_TO_CHARACTER` - TELEPORT_TO_CHARACTER * `TELEPORT_TO_SAFE_ZONE` - TELEPORT_TO_SAFE_ZONE * `RESET_STATS` - RESET_STATS * `FLOW_ACCUMULATION` - FLOW_ACCUMULATION
 * @export
 * @enum {string}
 */

export const SpecialEnum = {
    Action: 'ACTION',
    Teleport: 'TELEPORT',
    TeleportToCharacter: 'TELEPORT_TO_CHARACTER',
    TeleportToSafeZone: 'TELEPORT_TO_SAFE_ZONE',
    ResetStats: 'RESET_STATS',
    FlowAccumulation: 'FLOW_ACCUMULATION'
} as const;

export type SpecialEnum = typeof SpecialEnum[keyof typeof SpecialEnum];


/**
 * 
 * @export
 * @interface Spell
 */
export interface Spell {
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'school': string;
    /**
     * 
     * @type {number}
     * @memberof Spell
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface Stat
 */
export interface Stat {
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'id': string;
    /**
     * 
     * @type {StatEnum}
     * @memberof Stat
     */
    'name'?: StatEnum;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'additional_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'base_value'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Stat
     */
    'dice_rolls': Array<string>;
}


/**
 * * `Physical Strength` - Physical Strength * `Mental Strength` - Mental Strength * `Flow Resonance` - Flow Resonance * `Concentration` - Concentration * `Flow Manipulation` - Flow Manipulation * `Flow Connection` - Flow Connection * `Knowledge` - Knowledge * `Speed` - Speed * `Luck` - Luck * `Charisma` - Charisma
 * @export
 * @enum {string}
 */

export const StatEnum = {
    PhysicalStrength: 'Physical Strength',
    MentalStrength: 'Mental Strength',
    FlowResonance: 'Flow Resonance',
    Concentration: 'Concentration',
    FlowManipulation: 'Flow Manipulation',
    FlowConnection: 'Flow Connection',
    Knowledge: 'Knowledge',
    Speed: 'Speed',
    Luck: 'Luck',
    Charisma: 'Charisma'
} as const;

export type StatEnum = typeof StatEnum[keyof typeof StatEnum];


/**
 * 
 * @export
 * @interface StatModificatorRequest
 */
export interface StatModificatorRequest {
    /**
     * 
     * @type {StatEnum}
     * @memberof StatModificatorRequest
     */
    'stat'?: StatEnum;
    /**
     * 
     * @type {number}
     * @memberof StatModificatorRequest
     */
    'value'?: number;
}


/**
 * 
 * @export
 * @interface StatObject
 */
export interface StatObject {
    /**
     * 
     * @type {StatEnum}
     * @memberof StatObject
     */
    'id': StatEnum;
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface SubLocation
 */
export interface SubLocation {
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'image'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocation
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubLocation
     */
    'location': string;
}
/**
 * 
 * @export
 * @interface SubLocationRequest
 */
export interface SubLocationRequest {
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'description': string;
    /**
     * 
     * @type {File}
     * @memberof SubLocationRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {boolean}
     * @memberof SubLocationRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubLocationRequest
     */
    'location': string;
}
/**
 * 
 * @export
 * @interface SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeRequest
     */
    'channel': string;
}
/**
 * 
 * @export
 * @interface SwipeBaseStatRequest
 */
export interface SwipeBaseStatRequest {
    /**
     * The first result of the base stat generation.
     * @type {string}
     * @memberof SwipeBaseStatRequest
     */
    'from_stat': string;
    /**
     * The second result of the base stat generation.
     * @type {string}
     * @memberof SwipeBaseStatRequest
     */
    'to_stat': string;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinates
 */
export interface TeleportCoordinates {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinates
     */
    'grid_z': number;
}
/**
 * References an existing position by coordinates only.
 * @export
 * @interface TeleportCoordinatesRequest
 */
export interface TeleportCoordinatesRequest {
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportCoordinatesRequest
     */
    'grid_z': number;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPosition
 */
export interface TeleportPosition {
    /**
     * 
     * @type {string}
     * @memberof TeleportPosition
     */
    'id': string;
}
/**
 * References an existing position by ID only.
 * @export
 * @interface TeleportPositionRequest
 */
export interface TeleportPositionRequest {
    /**
     * 
     * @type {string}
     * @memberof TeleportPositionRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ThePath
 */
export interface ThePath {
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThePath
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPairRequest
 */
export interface TokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPairRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyRequest
 */
export interface TokenVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TurnActionResultGameEventData
 */
export interface TurnActionResultGameEventData {
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'turn_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'initiator_id': string;
    /**
     * 
     * @type {string}
     * @memberof TurnActionResultGameEventData
     */
    'target_id': string;
    /**
     * 
     * @type {ActionModel}
     * @memberof TurnActionResultGameEventData
     */
    'action': ActionModel;
    /**
     * 
     * @type {ActionImpactModel}
     * @memberof TurnActionResultGameEventData
     */
    'impact': ActionImpactModel;
}
/**
 * * `None` - None * `Knock out` - Knock out * `Damage` - Damage * `Heal` - Heal * `Shield` - Shield * `Buff` - Buff * `Debuff` - Debuff * `Stun` - Stun * `Sleep` - Sleep * `Confusion` - Confusion * `Paralysis` - Paralysis * `Fear` - Fear * `Freeze` - Freeze * `Burn` - Burn * `Poison` - Poison * `Slow` - Slow * `Haste` - Haste * `Blind` - Blind * `Silence` - Silence * `Bleed` - Bleed * `Disarm` - Disarm * `Root` - Root * `Energy Decrease` - Energy Decrease * `Reflect` - Reflect * `Absorb` - Absorb * `Dodge` - Dodge * `Resist` - Resist * `Immunity` - Immunity * `Regeneration` - Regeneration * `Lifesteal` - Lifesteal
 * @export
 * @enum {string}
 */

export const TypeBf3Enum = {
    None: 'None',
    KnockOut: 'Knock out',
    Damage: 'Damage',
    Heal: 'Heal',
    Shield: 'Shield',
    Buff: 'Buff',
    Debuff: 'Debuff',
    Stun: 'Stun',
    Sleep: 'Sleep',
    Confusion: 'Confusion',
    Paralysis: 'Paralysis',
    Fear: 'Fear',
    Freeze: 'Freeze',
    Burn: 'Burn',
    Poison: 'Poison',
    Slow: 'Slow',
    Haste: 'Haste',
    Blind: 'Blind',
    Silence: 'Silence',
    Bleed: 'Bleed',
    Disarm: 'Disarm',
    Root: 'Root',
    EnergyDecrease: 'Energy Decrease',
    Reflect: 'Reflect',
    Absorb: 'Absorb',
    Dodge: 'Dodge',
    Resist: 'Resist',
    Immunity: 'Immunity',
    Regeneration: 'Regeneration',
    Lifesteal: 'Lifesteal'
} as const;

export type TypeBf3Enum = typeof TypeBf3Enum[keyof typeof TypeBf3Enum];


/**
 * 
 * @export
 * @interface ViolationObject
 */
export interface ViolationObject {
    /**
     * 
     * @type {ImpactViolationEnum}
     * @memberof ViolationObject
     */
    'id': ImpactViolationEnum;
    /**
     * 
     * @type {string}
     * @memberof ViolationObject
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ViolationObject
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface WorldItem
 */
export interface WorldItem {
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'id': string;
    /**
     * 
     * @type {Item}
     * @memberof WorldItem
     */
    'item': Item;
    /**
     * 
     * @type {boolean}
     * @memberof WorldItem
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorldItem
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorldItem
     */
    'campaign'?: string | null;
}
/**
 * 
 * @export
 * @interface WorldItemRequest
 */
export interface WorldItemRequest {
    /**
     * 
     * @type {ItemRequest}
     * @memberof WorldItemRequest
     */
    'item': ItemRequest;
    /**
     * 
     * @type {boolean}
     * @memberof WorldItemRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'charges_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'visibility'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorldItemRequest
     */
    'position'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorldItemRequest
     */
    'dimension'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorldItemRequest
     */
    'campaign'?: string | null;
}

/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate: async (characterActionRequest?: CharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/current_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate: async (gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmDestroy', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate: async (id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmPartialUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate: async (gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMasterCharacterActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterCharacterActionCreate', 'gameMasterCharacterActionRequest', gameMasterCharacterActionRequest)
            const localVarPath = `/api/action/gm/register_character_action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate: async (registerImpactActionRequest: RegisterImpactActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerImpactActionRequest' is not null or undefined
            assertParamExists('actionGmRegisterImpactCreate', 'registerImpactActionRequest', registerImpactActionRequest)
            const localVarPath = `/api/action/gm/register_impact/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerImpactActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmRetrieve', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate: async (id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actionGmUpdate', 'id', id)
            const localVarPath = `/api/action/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameMasterCharacterActionLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList: async (limit?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/next_cycle/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/scheduled_actions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialAvailableRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/special/available/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/action/special/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialRetrieve: async (actionType: ActionSpecialRetrieveActionTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionType' is not null or undefined
            assertParamExists('actionSpecialRetrieve', 'actionType', actionType)
            const localVarPath = `/api/action/special/{action_type}/`
                .replace(`{${"action_type"}}`, encodeURIComponent(String(actionType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCreate(characterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCurrentCycleRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionCurrentCycleRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmCreate(gameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGameMasterCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterCharacterActionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterImpactAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRegisterImpactCreate(registerImpactActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRegisterImpactCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameMasterCharacterActionLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGmUpdate(id, gameMasterCharacterActionLogRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionGmUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCharacterActionLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionLogList(limit, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionLogList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionNextCycleCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionNextCycleCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionNextCycleCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionScheduledActionsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionScheduledActionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialAvailableRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecialAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialAvailableRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialAvailableRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecialAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecialAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionSpecialRetrieve(actionType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionApi.actionSpecialRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionApiFp(configuration)
    return {
        /**
         * 
         * @param {CharacterActionRequest} [characterActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCreate(characterActionRequest?: CharacterActionRequest, options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionCreate(characterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCurrentCycleRetrieve(options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionCurrentCycleRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmCreate(gameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.actionGmDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedGameMasterCharacterActionLogList> {
            return localVarFp.actionGmList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: any): AxiosPromise<GameMasterCharacterAction> {
            return localVarFp.actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterImpactActionRequest} registerImpactActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: any): AxiosPromise<RegisterImpactAction> {
            return localVarFp.actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmRetrieve(id: string, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character action.
         * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: any): AxiosPromise<GameMasterCharacterActionLog> {
            return localVarFp.actionGmUpdate(id, gameMasterCharacterActionLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionLogList(limit?: number, offset?: number, search?: string, options?: any): AxiosPromise<PaginatedCharacterActionLogList> {
            return localVarFp.actionLogList(limit, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionNextCycleCreate(options?: any): AxiosPromise<void> {
            return localVarFp.actionNextCycleCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionScheduledActionsRetrieve(options?: any): AxiosPromise<CharacterAction> {
            return localVarFp.actionScheduledActionsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialAvailableRetrieve(options?: any): AxiosPromise<SpecialAction> {
            return localVarFp.actionSpecialAvailableRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialList(options?: any): AxiosPromise<Array<SpecialAction>> {
            return localVarFp.actionSpecialList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: any): AxiosPromise<SpecialAction> {
            return localVarFp.actionSpecialRetrieve(actionType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * 
     * @param {CharacterActionRequest} [characterActionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCreate(characterActionRequest?: CharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCreate(characterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionCurrentCycleRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionCurrentCycleRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmCreate(gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmCreate(gameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {PatchedGameMasterCharacterActionLogRequest} [patchedGameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmPartialUpdate(id: string, patchedGameMasterCharacterActionLogRequest?: PatchedGameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmPartialUpdate(id, patchedGameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameMasterCharacterActionRequest} gameMasterCharacterActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest: GameMasterCharacterActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterCharacterActionCreate(gameMasterCharacterActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterImpactActionRequest} registerImpactActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRegisterImpactCreate(registerImpactActionRequest: RegisterImpactActionRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRegisterImpactCreate(registerImpactActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character action.
     * @param {GameMasterCharacterActionLogRequest} [gameMasterCharacterActionLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionGmUpdate(id: string, gameMasterCharacterActionLogRequest?: GameMasterCharacterActionLogRequest, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionGmUpdate(id, gameMasterCharacterActionLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionLogList(limit?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionLogList(limit, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionNextCycleCreate(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionNextCycleCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionScheduledActionsRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionScheduledActionsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialAvailableRetrieve(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialAvailableRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialList(options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ActionSpecialRetrieveActionTypeEnum} actionType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public actionSpecialRetrieve(actionType: ActionSpecialRetrieveActionTypeEnum, options?: RawAxiosRequestConfig) {
        return ActionApiFp(this.configuration).actionSpecialRetrieve(actionType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ActionSpecialRetrieveActionTypeEnum = {
    Inspect: 'INSPECT',
    SnatchItem: 'SNATCH_ITEM',
    Bargain: 'BARGAIN',
    Gift: 'GIFT',
    LongRest: 'LONG_REST',
    BackToSafeZone: 'BACK_TO_SAFE_ZONE'
} as const;
export type ActionSpecialRetrieveActionTypeEnum = typeof ActionSpecialRetrieveActionTypeEnum[keyof typeof ActionSpecialRetrieveActionTypeEnum];


/**
 * AdaptersApi - axios parameter creator
 * @export
 */
export const AdaptersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate: async (connectRequest: ConnectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoConnectCreate', 'connectRequest', connectRequest)
            const localVarPath = `/api/adapters/centrifugo/connect/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate: async (gameEventRequest: GameEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameEventRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoPublishCreate', 'gameEventRequest', gameEventRequest)
            const localVarPath = `/api/adapters/centrifugo/publish/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('adaptersCentrifugoSubscribeCreate', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/api/adapters/centrifugo/subscribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdaptersApi - functional programming interface
 * @export
 */
export const AdaptersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdaptersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoConnectCreate(connectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoConnectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoPublishCreate(gameEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoPublishCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adaptersCentrifugoSubscribeCreate(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdaptersApi.adaptersCentrifugoSubscribeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdaptersApi - factory interface
 * @export
 */
export const AdaptersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdaptersApiFp(configuration)
    return {
        /**
         * 
         * @param {ConnectRequest} connectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GameEventRequest} gameEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdaptersApi - object-oriented interface
 * @export
 * @class AdaptersApi
 * @extends {BaseAPI}
 */
export class AdaptersApi extends BaseAPI {
    /**
     * 
     * @param {ConnectRequest} connectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoConnectCreate(connectRequest: ConnectRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoConnectCreate(connectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GameEventRequest} gameEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoPublishCreate(gameEventRequest: GameEventRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoPublishCreate(gameEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdaptersApi
     */
    public adaptersCentrifugoSubscribeCreate(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return AdaptersApiFp(this.configuration).adaptersCentrifugoSubscribeCreate(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate: async (tokenObtainPairRequest: TokenObtainPairRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPairRequest' is not null or undefined
            assertParamExists('authJwtTokenCreate', 'tokenObtainPairRequest', tokenObtainPairRequest)
            const localVarPath = `/auth/jwt/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('authJwtTokenRefreshCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/auth/jwt/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate: async (tokenVerifyRequest: TokenVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyRequest' is not null or undefined
            assertParamExists('authJwtTokenVerifyCreate', 'tokenVerifyRequest', tokenVerifyRequest)
            const localVarPath = `/auth/jwt/token/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenCreate(tokenObtainPairRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenRefreshCreate(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtTokenVerifyCreate(tokenVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwtTokenVerifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPairRequest} tokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerifyRequest} tokenVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPairRequest} tokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenCreate(tokenObtainPairRequest: TokenObtainPairRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenCreate(tokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerifyRequest} tokenVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtTokenVerifyCreate(tokenVerifyRequest: TokenVerifyRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtTokenVerifyCreate(tokenVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BargainApi - axios parameter creator
 * @export
 */
export const BargainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsAcceptCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsAcceptCreate', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/accept/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsGiftCreate: async (bargainCreateRequest: BargainCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainCreateRequest' is not null or undefined
            assertParamExists('bargainOpenBargainsGiftCreate', 'bargainCreateRequest', bargainCreateRequest)
            const localVarPath = `/api/bargain/open_bargains/gift/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bargainCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsCreate: async (bargainPk: string, offeredItemRequest: OfferedItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsCreate', 'bargainPk', bargainPk)
            // verify required parameter 'offeredItemRequest' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsCreate', 'offeredItemRequest', offeredItemRequest)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offeredItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsDestroy: async (bargainPk: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsDestroy', 'bargainPk', bargainPk)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsDestroy', 'itemId', itemId)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/{item_id}/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsList: async (bargainPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bargainPk' is not null or undefined
            assertParamExists('bargainOpenBargainsItemsList', 'bargainPk', bargainPk)
            const localVarPath = `/api/bargain/open_bargains/{bargain_pk}/items/`
                .replace(`{${"bargain_pk"}}`, encodeURIComponent(String(bargainPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bargain/open_bargains/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRejectCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsRejectCreate', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/reject/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bargainOpenBargainsRetrieve', 'id', id)
            const localVarPath = `/api/bargain/open_bargains/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BargainApi - functional programming interface
 * @export
 */
export const BargainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BargainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsAcceptCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsAcceptCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsAcceptCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsGiftCreate(bargainCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsGiftCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferedItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsDestroy(bargainPk, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsItemsList(bargainPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferedItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsItemsList(bargainPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bargain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsRejectCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsRejectCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsRejectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bargainOpenBargainsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedBargain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bargainOpenBargainsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BargainApi.bargainOpenBargainsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BargainApi - factory interface
 * @export
 */
export const BargainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BargainApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsAcceptCreate(id: string, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsAcceptCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BargainCreateRequest} bargainCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsGiftCreate(bargainCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {OfferedItemRequest} offeredItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: any): AxiosPromise<OfferedItem> {
            return localVarFp.bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.bargainOpenBargainsItemsDestroy(bargainPk, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Nested viewset for adding and removing items from a bargain
         * @param {string} bargainPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsItemsList(bargainPk: string, options?: any): AxiosPromise<Array<OfferedItem>> {
            return localVarFp.bargainOpenBargainsItemsList(bargainPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsList(options?: any): AxiosPromise<Array<Bargain>> {
            return localVarFp.bargainOpenBargainsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRejectCreate(id: string, options?: any): AxiosPromise<Bargain> {
            return localVarFp.bargainOpenBargainsRejectCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this bargain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bargainOpenBargainsRetrieve(id: string, options?: any): AxiosPromise<DetailedBargain> {
            return localVarFp.bargainOpenBargainsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BargainApi - object-oriented interface
 * @export
 * @class BargainApi
 * @extends {BaseAPI}
 */
export class BargainApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsAcceptCreate(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsAcceptCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BargainCreateRequest} bargainCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsGiftCreate(bargainCreateRequest: BargainCreateRequest, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsGiftCreate(bargainCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {OfferedItemRequest} offeredItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsCreate(bargainPk: string, offeredItemRequest: OfferedItemRequest, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsCreate(bargainPk, offeredItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsDestroy(bargainPk: string, itemId: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsDestroy(bargainPk, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Nested viewset for adding and removing items from a bargain
     * @param {string} bargainPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsItemsList(bargainPk: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsItemsList(bargainPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsList(options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsRejectCreate(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsRejectCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this bargain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BargainApi
     */
    public bargainOpenBargainsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return BargainApiFp(this.configuration).bargainOpenBargainsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CharacterApi - axios parameter creator
 * @export
 */
export const CharacterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmCharacterInfoRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/character_info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/gm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterGmRetrieve', 'id', id)
            const localVarPath = `/api/character/gm/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterDetailsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_details/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterStatsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/character_template/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate: async (characterPathRequest?: CharacterPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/chose_path/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate: async (characterGenericDataRequest: CharacterGenericDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterGenericDataRequest' is not null or undefined
            assertParamExists('characterPlayerImportCharacterCreate', 'characterGenericDataRequest', characterGenericDataRequest)
            const localVarPath = `/api/character/player/import_character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterGenericDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList: async (npc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/player/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterPlayerRetrieve', 'id', id)
            const localVarPath = `/api/character/player/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsResetBaseStatsCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/character/stats/reset_base_stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('characterStatsRetrieve', 'id', id)
            const localVarPath = `/api/character/stats/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsSwipeBaseStatCreate: async (swipeBaseStatRequest: SwipeBaseStatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'swipeBaseStatRequest' is not null or undefined
            assertParamExists('characterStatsSwipeBaseStatCreate', 'swipeBaseStatRequest', swipeBaseStatRequest)
            const localVarPath = `/api/character/stats/swipe_base_stat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swipeBaseStatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterApi - functional programming interface
 * @export
 */
export const CharacterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmCharacterInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterGmRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterGmRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterGmRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterDetailsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterDetailsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterDetailsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterInfoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterStatsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterStatsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterTemplateFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerCharacterTemplateRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerCharacterTemplateRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerChosePathCreate(characterPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerChosePathCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterGenericData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerImportCharacterCreate(characterGenericDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerImportCharacterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiCharacter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerList(npc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiCharacter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterPlayerRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterPlayerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsResetBaseStatsCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsResetBaseStatsCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsResetBaseStatsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.characterStatsSwipeBaseStatCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CharacterApi - factory interface
 * @export
 */
export const CharacterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmCharacterInfoRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterGmCharacterInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterGmList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterGmRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterGmRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterDetailsRetrieve(options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerCharacterDetailsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterInfoRetrieve(options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.characterPlayerCharacterInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterStatsRetrieve(options?: any): AxiosPromise<CharacterStats> {
            return localVarFp.characterPlayerCharacterStatsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerCharacterTemplateRetrieve(options?: any): AxiosPromise<CharacterTemplateFull> {
            return localVarFp.characterPlayerCharacterTemplateRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CharacterPathRequest} [characterPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: any): AxiosPromise<CharacterPath> {
            return localVarFp.characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new character for the user.
         * @param {CharacterGenericDataRequest} characterGenericDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: any): AxiosPromise<CharacterGenericData> {
            return localVarFp.characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [npc] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerList(npc?: boolean, options?: any): AxiosPromise<Array<OpenaiCharacter>> {
            return localVarFp.characterPlayerList(npc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterPlayerRetrieve(id: string, options?: any): AxiosPromise<OpenaiCharacter> {
            return localVarFp.characterPlayerRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsList(options?: any): AxiosPromise<Array<DetailStat>> {
            return localVarFp.characterStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsResetBaseStatsCreate(options?: any): AxiosPromise<Array<DetailStat>> {
            return localVarFp.characterStatsResetBaseStatsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this stat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsRetrieve(id: string, options?: any): AxiosPromise<DetailStat> {
            return localVarFp.characterStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: any): AxiosPromise<DetailStat> {
            return localVarFp.characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterApi - object-oriented interface
 * @export
 * @class CharacterApi
 * @extends {BaseAPI}
 */
export class CharacterApi extends BaseAPI {
    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmCharacterInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterGmRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterGmRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterDetailsRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterDetailsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterInfoRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterStatsRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterStatsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerCharacterTemplateRetrieve(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerCharacterTemplateRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CharacterPathRequest} [characterPathRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerChosePathCreate(characterPathRequest?: CharacterPathRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerChosePathCreate(characterPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new character for the user.
     * @param {CharacterGenericDataRequest} characterGenericDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerImportCharacterCreate(characterGenericDataRequest: CharacterGenericDataRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerImportCharacterCreate(characterGenericDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [npc] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerList(npc?: boolean, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerList(npc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterPlayerRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterPlayerRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsList(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsResetBaseStatsCreate(options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsResetBaseStatsCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this stat.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwipeBaseStatRequest} swipeBaseStatRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public characterStatsSwipeBaseStatCreate(swipeBaseStatRequest: SwipeBaseStatRequest, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).characterStatsSwipeBaseStatCreate(swipeBaseStatRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate: async (openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientCreate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientDestroy', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate: async (id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientPartialUpdate', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate: async (registrationFormRequest: RegistrationFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationFormRequest' is not null or undefined
            assertParamExists('clientRegisterLocalClientCreate', 'registrationFormRequest', registrationFormRequest)
            const localVarPath = `/api/client/register_local_client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientRetrieve', 'id', id)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate: async (id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientUpdate', 'id', id)
            // verify required parameter 'openAIClientManagementRequest' is not null or undefined
            assertParamExists('clientUpdate', 'openAIClientManagementRequest', openAIClientManagementRequest)
            const localVarPath = `/api/client/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openAIClientManagementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCreate(openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenAIClientManagement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRegisterLocalClientCreate(registrationFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRegisterLocalClientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIClientManagement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientUpdate(id, openAIClientManagementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.clientUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientCreate(openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientList(options?: any): AxiosPromise<Array<OpenAIClientManagement>> {
            return localVarFp.clientList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegistrationFormRequest} registrationFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: any): AxiosPromise<RegistrationForm> {
            return localVarFp.clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRetrieve(id: string, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this client.
         * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: any): AxiosPromise<OpenAIClientManagement> {
            return localVarFp.clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientCreate(openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientCreate(openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientList(options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {PatchedOpenAIClientManagementRequest} [patchedOpenAIClientManagementRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientPartialUpdate(id: string, patchedOpenAIClientManagementRequest?: PatchedOpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientPartialUpdate(id, patchedOpenAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegistrationFormRequest} registrationFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRegisterLocalClientCreate(registrationFormRequest: RegistrationFormRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRegisterLocalClientCreate(registrationFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this client.
     * @param {OpenAIClientManagementRequest} openAIClientManagementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public clientUpdate(id: string, openAIClientManagementRequest: OpenAIClientManagementRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).clientUpdate(id, openAIClientManagementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreApi - axios parameter creator
 * @export
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/character/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsRetrieve: async (id: CoreStatsRetrieveIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coreStatsRetrieve', 'id', id)
            const localVarPath = `/api/core/stats/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/violations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsRetrieve: async (id: CoreViolationsRetrieveIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coreViolationsRetrieve', 'id', id)
            const localVarPath = `/api/core/violations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreCharacterStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterStat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreCharacterStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreCharacterStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreStatsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreStatsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreStatsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreViolationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ViolationObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreViolationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreViolationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViolationObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coreViolationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.coreViolationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreCharacterStatsList(options?: any): AxiosPromise<Array<CharacterStat>> {
            return localVarFp.coreCharacterStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsList(options?: any): AxiosPromise<Array<StatObject>> {
            return localVarFp.coreStatsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CoreStatsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: any): AxiosPromise<StatObject> {
            return localVarFp.coreStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsList(options?: any): AxiosPromise<Array<ViolationObject>> {
            return localVarFp.coreViolationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CoreViolationsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: any): AxiosPromise<ViolationObject> {
            return localVarFp.coreViolationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreCharacterStatsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreCharacterStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreStatsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreStatsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CoreStatsRetrieveIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreStatsRetrieve(id: CoreStatsRetrieveIdEnum, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreViolationsList(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreViolationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CoreViolationsRetrieveIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public coreViolationsRetrieve(id: CoreViolationsRetrieveIdEnum, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).coreViolationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CoreStatsRetrieveIdEnum = {
    PhysicalStrength: 'Physical Strength',
    MentalStrength: 'Mental Strength',
    FlowResonance: 'Flow Resonance',
    Concentration: 'Concentration',
    FlowManipulation: 'Flow Manipulation',
    FlowConnection: 'Flow Connection',
    Knowledge: 'Knowledge',
    Speed: 'Speed',
    Luck: 'Luck',
    Charisma: 'Charisma'
} as const;
export type CoreStatsRetrieveIdEnum = typeof CoreStatsRetrieveIdEnum[keyof typeof CoreStatsRetrieveIdEnum];
/**
 * @export
 */
export const CoreViolationsRetrieveIdEnum = {
    Physical: 'Physical',
    Mental: 'Mental',
    Energy: 'Energy',
    Heat: 'Heat',
    Cold: 'Cold',
    Light: 'Light',
    Darkness: 'Darkness',
    None: 'None'
} as const;
export type CoreViolationsRetrieveIdEnum = typeof CoreViolationsRetrieveIdEnum[keyof typeof CoreViolationsRetrieveIdEnum];


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyCharacterRetrieve', 'id', id)
            const localVarPath = `/api/currency/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate: async (currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldCreate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldDestroy', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/currency/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate: async (id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCurrencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldRetrieve', 'id', id)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate: async (id: string, currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'id', id)
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('currencyWorldUpdate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/currency/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldCreate(currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencyToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currencyWorldUpdate(id, currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.currencyWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterList(options?: any): AxiosPromise<Array<CharacterCurrency>> {
            return localVarFp.currencyCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.currencyCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldCreate(currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.currencyWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldList(options?: any): AxiosPromise<Array<CurrencyToken>> {
            return localVarFp.currencyWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldRetrieve(id: string, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldCreate(currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldList(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this currency token.
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public currencyWorldUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).currencyWorldUpdate(id, currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EffectsApi - axios parameter creator
 * @export
 */
export const EffectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/effects/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('effectsActiveRetrieve', 'id', id)
            const localVarPath = `/api/effects/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EffectsApi - functional programming interface
 * @export
 */
export const EffectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EffectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveEffect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.effectsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EffectsApi.effectsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EffectsApi - factory interface
 * @export
 */
export const EffectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EffectsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveList(options?: any): AxiosPromise<Array<ActiveEffect>> {
            return localVarFp.effectsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        effectsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.effectsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EffectsApi - object-oriented interface
 * @export
 * @class EffectsApi
 * @extends {BaseAPI}
 */
export class EffectsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveList(options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EffectsApi
     */
    public effectsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return EffectsApiFp(this.configuration).effectsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GalleryApi - axios parameter creator
 * @export
 */
export const GalleryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gallery/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('galleryWorldRetrieve', 'id', id)
            const localVarPath = `/api/gallery/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GalleryApi - functional programming interface
 * @export
 */
export const GalleryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GalleryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Art>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Art>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.galleryWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GalleryApi.galleryWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GalleryApi - factory interface
 * @export
 */
export const GalleryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GalleryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldList(options?: any): AxiosPromise<Array<Art>> {
            return localVarFp.galleryWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this art.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        galleryWorldRetrieve(id: string, options?: any): AxiosPromise<Art> {
            return localVarFp.galleryWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GalleryApi - object-oriented interface
 * @export
 * @class GalleryApi
 * @extends {BaseAPI}
 */
export class GalleryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldList(options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this art.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GalleryApi
     */
    public galleryWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GalleryApiFp(this.configuration).galleryWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GamemasterApi - axios parameter creator
 * @export
 */
export const GamemasterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsCreate: async (activeEffectRequest: ActiveEffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeEffectRequest' is not null or undefined
            assertParamExists('gamemasterActiveEffectsCreate', 'activeEffectRequest', activeEffectRequest)
            const localVarPath = `/api/gamemaster/active-effects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activeEffectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterActiveEffectsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/active-effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/active-effects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {PatchedActiveEffectRequest} [patchedActiveEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsPartialUpdate: async (id: string, patchedActiveEffectRequest?: PatchedActiveEffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterActiveEffectsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/active-effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedActiveEffectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterActiveEffectsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/active-effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsUpdate: async (id: string, activeEffectRequest: ActiveEffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterActiveEffectsUpdate', 'id', id)
            // verify required parameter 'activeEffectRequest' is not null or undefined
            assertParamExists('gamemasterActiveEffectsUpdate', 'activeEffectRequest', activeEffectRequest)
            const localVarPath = `/api/gamemaster/active-effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activeEffectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasCreate: async (areaRequest: AreaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'areaRequest' is not null or undefined
            assertParamExists('gamemasterAreasCreate', 'areaRequest', areaRequest)
            const localVarPath = `/api/gamemaster/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(areaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterAreasDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {PatchedAreaRequest} [patchedAreaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasPartialUpdate: async (id: string, patchedAreaRequest?: PatchedAreaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterAreasPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAreaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterAreasRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasUpdate: async (id: string, areaRequest: AreaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterAreasUpdate', 'id', id)
            // verify required parameter 'areaRequest' is not null or undefined
            assertParamExists('gamemasterAreasUpdate', 'areaRequest', areaRequest)
            const localVarPath = `/api/gamemaster/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(areaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesCreate: async (characterCurrencyRequest: CharacterCurrencyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterCurrencyRequest' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesCreate', 'characterCurrencyRequest', characterCurrencyRequest)
            const localVarPath = `/api/gamemaster/character-currencies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/character-currencies/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/character-currencies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {PatchedCharacterCurrencyRequest} [patchedCharacterCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesPartialUpdate: async (id: string, patchedCharacterCurrencyRequest?: PatchedCharacterCurrencyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/character-currencies/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCharacterCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/character-currencies/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesUpdate: async (id: string, characterCurrencyRequest: CharacterCurrencyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesUpdate', 'id', id)
            // verify required parameter 'characterCurrencyRequest' is not null or undefined
            assertParamExists('gamemasterCharacterCurrenciesUpdate', 'characterCurrencyRequest', characterCurrencyRequest)
            const localVarPath = `/api/gamemaster/character-currencies/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsCreate: async (characterItemRequest: CharacterItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterItemRequest' is not null or undefined
            assertParamExists('gamemasterCharacterItemsCreate', 'characterItemRequest', characterItemRequest)
            const localVarPath = `/api/gamemaster/character-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterItemsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/character-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/character-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {PatchedCharacterItemRequest} [patchedCharacterItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsPartialUpdate: async (id: string, patchedCharacterItemRequest?: PatchedCharacterItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterItemsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/character-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCharacterItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterItemsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/character-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsUpdate: async (id: string, characterItemRequest: CharacterItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharacterItemsUpdate', 'id', id)
            // verify required parameter 'characterItemRequest' is not null or undefined
            assertParamExists('gamemasterCharacterItemsUpdate', 'characterItemRequest', characterItemRequest)
            const localVarPath = `/api/gamemaster/character-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterInfoRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersCharacterStatsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/character_stats/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCreate: async (characterInfoRequest: CharacterInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterInfoRequest' is not null or undefined
            assertParamExists('gamemasterCharactersCreate', 'characterInfoRequest', characterInfoRequest)
            const localVarPath = `/api/gamemaster/characters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersList: async (npc?: boolean, position?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/characters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (npc !== undefined) {
                localVarQueryParameter['npc'] = npc;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedCharacterInfoRequest} [patchedCharacterInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersPartialUpdate: async (id: string, patchedCharacterInfoRequest?: PatchedCharacterInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCharacterInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/characters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersUpdate: async (id: string, characterInfoRequest: CharacterInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCharactersUpdate', 'id', id)
            // verify required parameter 'characterInfoRequest' is not null or undefined
            assertParamExists('gamemasterCharactersUpdate', 'characterInfoRequest', characterInfoRequest)
            const localVarPath = `/api/gamemaster/characters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characterInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesCreate: async (cityRequest: CityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cityRequest' is not null or undefined
            assertParamExists('gamemasterCitiesCreate', 'cityRequest', cityRequest)
            const localVarPath = `/api/gamemaster/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCitiesDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {PatchedCityRequest} [patchedCityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesPartialUpdate: async (id: string, patchedCityRequest?: PatchedCityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCitiesPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCitiesRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesUpdate: async (id: string, cityRequest: CityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCitiesUpdate', 'id', id)
            // verify required parameter 'cityRequest' is not null or undefined
            assertParamExists('gamemasterCitiesUpdate', 'cityRequest', cityRequest)
            const localVarPath = `/api/gamemaster/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsCreate: async (continentRequest: ContinentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'continentRequest' is not null or undefined
            assertParamExists('gamemasterContinentsCreate', 'continentRequest', continentRequest)
            const localVarPath = `/api/gamemaster/continents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(continentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterContinentsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/continents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/continents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {PatchedContinentRequest} [patchedContinentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsPartialUpdate: async (id: string, patchedContinentRequest?: PatchedContinentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterContinentsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/continents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContinentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterContinentsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/continents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsUpdate: async (id: string, continentRequest: ContinentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterContinentsUpdate', 'id', id)
            // verify required parameter 'continentRequest' is not null or undefined
            assertParamExists('gamemasterContinentsUpdate', 'continentRequest', continentRequest)
            const localVarPath = `/api/gamemaster/continents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(continentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesCreate: async (countryRequest: CountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryRequest' is not null or undefined
            assertParamExists('gamemasterCountriesCreate', 'countryRequest', countryRequest)
            const localVarPath = `/api/gamemaster/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCountriesDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/countries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {PatchedCountryRequest} [patchedCountryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesPartialUpdate: async (id: string, patchedCountryRequest?: PatchedCountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCountriesPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/countries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCountryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCountriesRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/countries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesUpdate: async (id: string, countryRequest: CountryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCountriesUpdate', 'id', id)
            // verify required parameter 'countryRequest' is not null or undefined
            assertParamExists('gamemasterCountriesUpdate', 'countryRequest', countryRequest)
            const localVarPath = `/api/gamemaster/countries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensCreate: async (currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensCreate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/gamemaster/currency-tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/currency-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/currency-tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensPartialUpdate: async (id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/currency-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCurrencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/currency-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensUpdate: async (id: string, currencyTokenRequest: CurrencyTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensUpdate', 'id', id)
            // verify required parameter 'currencyTokenRequest' is not null or undefined
            assertParamExists('gamemasterCurrencyTokensUpdate', 'currencyTokenRequest', currencyTokenRequest)
            const localVarPath = `/api/gamemaster/currency-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsCreate: async (dimensionRequest: DimensionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dimensionRequest' is not null or undefined
            assertParamExists('gamemasterDimensionsCreate', 'dimensionRequest', dimensionRequest)
            const localVarPath = `/api/gamemaster/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dimensionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterDimensionsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {PatchedDimensionRequest} [patchedDimensionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsPartialUpdate: async (id: number, patchedDimensionRequest?: PatchedDimensionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterDimensionsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDimensionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterDimensionsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsUpdate: async (id: number, dimensionRequest: DimensionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterDimensionsUpdate', 'id', id)
            // verify required parameter 'dimensionRequest' is not null or undefined
            assertParamExists('gamemasterDimensionsUpdate', 'dimensionRequest', dimensionRequest)
            const localVarPath = `/api/gamemaster/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dimensionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsCreate: async (effectRequest?: EffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/effects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsDestroyIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsDestroy: async (id: GamemasterEffectsDestroyIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterEffectsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/effects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsPartialUpdateIdEnum} id 
         * @param {PatchedEffectRequest} [patchedEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsPartialUpdate: async (id: GamemasterEffectsPartialUpdateIdEnum, patchedEffectRequest?: PatchedEffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterEffectsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEffectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsRetrieve: async (id: GamemasterEffectsRetrieveIdEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterEffectsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsUpdateIdEnum} id 
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsUpdate: async (id: GamemasterEffectsUpdateIdEnum, effectRequest?: EffectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterEffectsUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/effects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(effectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCloneCreate: async (id: string, gameObjectRequest?: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsCloneCreate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/clone/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCreate: async (gameObjectRequest?: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/game-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsList: async (campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/game-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (positionGridZ !== undefined) {
                localVarQueryParameter['position_grid_z'] = positionGridZ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsMoveCreate: async (id: string, gameObjectRequest?: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsMoveCreate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/move/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsPartialUpdate: async (id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsToggleActiveCreate: async (id: string, gameObjectRequest?: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsToggleActiveCreate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/toggle_active/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsUpdate: async (id: string, gameObjectRequest?: GameObjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterGameObjectsUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/game-objects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsCreate: async (itemRequest: ItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemRequest' is not null or undefined
            assertParamExists('gamemasterItemsCreate', 'itemRequest', itemRequest)
            const localVarPath = `/api/gamemaster/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterItemsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsPartialUpdate: async (id: string, patchedItemRequest?: PatchedItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterItemsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterItemsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsUpdate: async (id: string, itemRequest: ItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterItemsUpdate', 'id', id)
            // verify required parameter 'itemRequest' is not null or undefined
            assertParamExists('gamemasterItemsUpdate', 'itemRequest', itemRequest)
            const localVarPath = `/api/gamemaster/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsCreate: async (learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsCreate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/api/gamemaster/learned-schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/learned-schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/learned-schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {PatchedLearnedSchoolRequest} [patchedLearnedSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsPartialUpdate: async (id: string, patchedLearnedSchoolRequest?: PatchedLearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/learned-schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLearnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/learned-schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsUpdate: async (id: string, learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsUpdate', 'id', id)
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('gamemasterLearnedSchoolsUpdate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/api/gamemaster/learned-schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsCreate: async (learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsCreate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/api/gamemaster/learned-skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/learned-skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/learned-skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {PatchedLearnedSkillRequest} [patchedLearnedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsPartialUpdate: async (id: string, patchedLearnedSkillRequest?: PatchedLearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/learned-skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLearnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/learned-skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsUpdate: async (id: string, learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsUpdate', 'id', id)
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('gamemasterLearnedSkillsUpdate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/api/gamemaster/learned-skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsCreate: async (locationRequest: LocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationRequest' is not null or undefined
            assertParamExists('gamemasterLocationsCreate', 'locationRequest', locationRequest)
            const localVarPath = `/api/gamemaster/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLocationsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {PatchedLocationRequest} [patchedLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsPartialUpdate: async (id: string, patchedLocationRequest?: PatchedLocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLocationsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLocationsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsUpdate: async (id: string, locationRequest: LocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterLocationsUpdate', 'id', id)
            // verify required parameter 'locationRequest' is not null or undefined
            assertParamExists('gamemasterLocationsUpdate', 'locationRequest', locationRequest)
            const localVarPath = `/api/gamemaster/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsCreate: async (mapRequest: MapRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mapRequest' is not null or undefined
            assertParamExists('gamemasterMapsCreate', 'mapRequest', mapRequest)
            const localVarPath = `/api/gamemaster/maps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mapRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterMapsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/maps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/maps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {PatchedMapRequest} [patchedMapRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsPartialUpdate: async (id: string, patchedMapRequest?: PatchedMapRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterMapsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/maps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMapRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterMapsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/maps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsUpdate: async (id: string, mapRequest: MapRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterMapsUpdate', 'id', id)
            // verify required parameter 'mapRequest' is not null or undefined
            assertParamExists('gamemasterMapsUpdate', 'mapRequest', mapRequest)
            const localVarPath = `/api/gamemaster/maps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mapRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsCreate: async (openaiPathRequest: OpenaiPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openaiPathRequest' is not null or undefined
            assertParamExists('gamemasterPathsCreate', 'openaiPathRequest', openaiPathRequest)
            const localVarPath = `/api/gamemaster/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPathsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {PatchedOpenaiPathRequest} [patchedOpenaiPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsPartialUpdate: async (id: string, patchedOpenaiPathRequest?: PatchedOpenaiPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPathsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenaiPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPathsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsUpdate: async (id: string, openaiPathRequest: OpenaiPathRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPathsUpdate', 'id', id)
            // verify required parameter 'openaiPathRequest' is not null or undefined
            assertParamExists('gamemasterPathsUpdate', 'openaiPathRequest', openaiPathRequest)
            const localVarPath = `/api/gamemaster/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiPathRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a path with its schools.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsWithSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPathsWithSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/paths/{id}/with_schools/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsCreate: async (planetRequest: PlanetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planetRequest' is not null or undefined
            assertParamExists('gamemasterPlanetsCreate', 'planetRequest', planetRequest)
            const localVarPath = `/api/gamemaster/planets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPlanetsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/planets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/planets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PatchedPlanetRequest} [patchedPlanetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsPartialUpdate: async (id: string, patchedPlanetRequest?: PatchedPlanetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPlanetsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/planets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlanetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPlanetsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/planets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsUpdate: async (id: string, planetRequest: PlanetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPlanetsUpdate', 'id', id)
            // verify required parameter 'planetRequest' is not null or undefined
            assertParamExists('gamemasterPlanetsUpdate', 'planetRequest', planetRequest)
            const localVarPath = `/api/gamemaster/planets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsCreate: async (positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterPositionsCreate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPositionsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/positions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsPartialUpdate: async (id: string, patchedPositionRequest?: PatchedPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPositionsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPositionsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsUpdate: async (id: string, positionRequest: PositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterPositionsUpdate', 'id', id)
            // verify required parameter 'positionRequest' is not null or undefined
            assertParamExists('gamemasterPositionsUpdate', 'positionRequest', positionRequest)
            const localVarPath = `/api/gamemaster/positions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(positionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsCreate: async (openaiSchoolRequest: OpenaiSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openaiSchoolRequest' is not null or undefined
            assertParamExists('gamemasterSchoolsCreate', 'openaiSchoolRequest', openaiSchoolRequest)
            const localVarPath = `/api/gamemaster/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSchoolsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {PatchedOpenaiSchoolRequest} [patchedOpenaiSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsPartialUpdate: async (id: string, patchedOpenaiSchoolRequest?: PatchedOpenaiSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSchoolsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenaiSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsUpdate: async (id: string, openaiSchoolRequest: OpenaiSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSchoolsUpdate', 'id', id)
            // verify required parameter 'openaiSchoolRequest' is not null or undefined
            assertParamExists('gamemasterSchoolsUpdate', 'openaiSchoolRequest', openaiSchoolRequest)
            const localVarPath = `/api/gamemaster/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsCreate: async (openaiSkillRequest: OpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openaiSkillRequest' is not null or undefined
            assertParamExists('gamemasterSkillsCreate', 'openaiSkillRequest', openaiSkillRequest)
            const localVarPath = `/api/gamemaster/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSkillsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {PatchedOpenaiSkillRequest} [patchedOpenaiSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsPartialUpdate: async (id: number, patchedOpenaiSkillRequest?: PatchedOpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSkillsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOpenaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSkillsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsUpdate: async (id: number, openaiSkillRequest: OpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterSkillsUpdate', 'id', id)
            // verify required parameter 'openaiSkillRequest' is not null or undefined
            assertParamExists('gamemasterSkillsUpdate', 'openaiSkillRequest', openaiSkillRequest)
            const localVarPath = `/api/gamemaster/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsCreate: async (worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('gamemasterWorldItemsCreate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/gamemaster/world-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldItemsDestroy', 'id', id)
            const localVarPath = `/api/gamemaster/world-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gamemaster/world-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsPartialUpdate: async (id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldItemsPartialUpdate', 'id', id)
            const localVarPath = `/api/gamemaster/world-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldItemsRetrieve', 'id', id)
            const localVarPath = `/api/gamemaster/world-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsUpdate: async (id: string, worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gamemasterWorldItemsUpdate', 'id', id)
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('gamemasterWorldItemsUpdate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/gamemaster/world-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GamemasterApi - functional programming interface
 * @export
 */
export const GamemasterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GamemasterApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsCreate(activeEffectRequest: ActiveEffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsCreate(activeEffectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveEffect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {PatchedActiveEffectRequest} [patchedActiveEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsPartialUpdate(id: string, patchedActiveEffectRequest?: PatchedActiveEffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsPartialUpdate(id, patchedActiveEffectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterActiveEffectsUpdate(id: string, activeEffectRequest: ActiveEffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveEffect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterActiveEffectsUpdate(id, activeEffectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterActiveEffectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasCreate(areaRequest: AreaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasCreate(areaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {PatchedAreaRequest} [patchedAreaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasPartialUpdate(id: string, patchedAreaRequest?: PatchedAreaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasPartialUpdate(id, patchedAreaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterAreasUpdate(id: string, areaRequest: AreaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterAreasUpdate(id, areaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterAreasUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesCreate(characterCurrencyRequest: CharacterCurrencyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesCreate(characterCurrencyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {PatchedCharacterCurrencyRequest} [patchedCharacterCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesPartialUpdate(id: string, patchedCharacterCurrencyRequest?: PatchedCharacterCurrencyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesPartialUpdate(id, patchedCharacterCurrencyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterCurrenciesUpdate(id: string, characterCurrencyRequest: CharacterCurrencyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterCurrenciesUpdate(id, characterCurrencyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterCurrenciesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsCreate(characterItemRequest: CharacterItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsCreate(characterItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {PatchedCharacterItemRequest} [patchedCharacterItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsPartialUpdate(id: string, patchedCharacterItemRequest?: PatchedCharacterItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsPartialUpdate(id, patchedCharacterItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharacterItemsUpdate(id: string, characterItemRequest: CharacterItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharacterItemsUpdate(id, characterItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharacterItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCharacterStatsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCharacterStatsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCharacterStatsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersCreate(characterInfoRequest: CharacterInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersCreate(characterInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersList(npc, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedCharacterInfoRequest} [patchedCharacterInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersPartialUpdate(id: string, patchedCharacterInfoRequest?: PatchedCharacterInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersPartialUpdate(id, patchedCharacterInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCharactersUpdate(id: string, characterInfoRequest: CharacterInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCharactersUpdate(id, characterInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCharactersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesCreate(cityRequest: CityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesCreate(cityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {PatchedCityRequest} [patchedCityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesPartialUpdate(id: string, patchedCityRequest?: PatchedCityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesPartialUpdate(id, patchedCityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCitiesUpdate(id: string, cityRequest: CityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCitiesUpdate(id, cityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCitiesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsCreate(continentRequest: ContinentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsCreate(continentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Continent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {PatchedContinentRequest} [patchedContinentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsPartialUpdate(id: string, patchedContinentRequest?: PatchedContinentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsPartialUpdate(id, patchedContinentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterContinentsUpdate(id: string, continentRequest: ContinentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterContinentsUpdate(id, continentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterContinentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesCreate(countryRequest: CountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesCreate(countryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {PatchedCountryRequest} [patchedCountryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesPartialUpdate(id: string, patchedCountryRequest?: PatchedCountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesPartialUpdate(id, patchedCountryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCountriesUpdate(id: string, countryRequest: CountryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCountriesUpdate(id, countryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCountriesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensCreate(currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencyToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensPartialUpdate(id, patchedCurrencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterCurrencyTokensUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterCurrencyTokensUpdate(id, currencyTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterCurrencyTokensUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsCreate(dimensionRequest: DimensionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsCreate(dimensionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dimension>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {PatchedDimensionRequest} [patchedDimensionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsPartialUpdate(id: number, patchedDimensionRequest?: PatchedDimensionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsPartialUpdate(id, patchedDimensionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterDimensionsUpdate(id: number, dimensionRequest: DimensionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterDimensionsUpdate(id, dimensionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterDimensionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsCreate(effectRequest?: EffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Effect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsCreate(effectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsDestroyIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsDestroy(id: GamemasterEffectsDestroyIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Effect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsPartialUpdateIdEnum} id 
         * @param {PatchedEffectRequest} [patchedEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsPartialUpdate(id: GamemasterEffectsPartialUpdateIdEnum, patchedEffectRequest?: PatchedEffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Effect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsPartialUpdate(id, patchedEffectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsRetrieve(id: GamemasterEffectsRetrieveIdEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Effect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsUpdateIdEnum} id 
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterEffectsUpdate(id: GamemasterEffectsUpdateIdEnum, effectRequest?: EffectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Effect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterEffectsUpdate(id, effectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterEffectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsCloneCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsCreate(gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsCreate(gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsMoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsToggleActiveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterGameObjectsUpdate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterGameObjectsUpdate(id, gameObjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterGameObjectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsCreate(itemRequest: ItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsCreate(itemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsPartialUpdate(id, patchedItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterItemsUpdate(id: string, itemRequest: ItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterItemsUpdate(id, itemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsCreate(learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {PatchedLearnedSchoolRequest} [patchedLearnedSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsPartialUpdate(id: string, patchedLearnedSchoolRequest?: PatchedLearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsPartialUpdate(id, patchedLearnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSchoolsUpdate(id: string, learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSchoolsUpdate(id, learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSchoolsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsCreate(learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {PatchedLearnedSkillRequest} [patchedLearnedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsPartialUpdate(id: string, patchedLearnedSkillRequest?: PatchedLearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsPartialUpdate(id, patchedLearnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLearnedSkillsUpdate(id: string, learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLearnedSkillsUpdate(id, learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLearnedSkillsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsCreate(locationRequest: LocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsCreate(locationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {PatchedLocationRequest} [patchedLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsPartialUpdate(id: string, patchedLocationRequest?: PatchedLocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsPartialUpdate(id, patchedLocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterLocationsUpdate(id: string, locationRequest: LocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterLocationsUpdate(id, locationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterLocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsCreate(mapRequest: MapRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsCreate(mapRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {PatchedMapRequest} [patchedMapRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsPartialUpdate(id: string, patchedMapRequest?: PatchedMapRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsPartialUpdate(id, patchedMapRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterMapsUpdate(id: string, mapRequest: MapRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterMapsUpdate(id, mapRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterMapsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsCreate(openaiPathRequest: OpenaiPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsCreate(openaiPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {PatchedOpenaiPathRequest} [patchedOpenaiPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsPartialUpdate(id: string, patchedOpenaiPathRequest?: PatchedOpenaiPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsPartialUpdate(id, patchedOpenaiPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsUpdate(id: string, openaiPathRequest: OpenaiPathRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsUpdate(id, openaiPathRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a path with its schools.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPathsWithSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPathWithSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPathsWithSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPathsWithSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsCreate(planetRequest: PlanetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Planet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsCreate(planetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Planet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PatchedPlanetRequest} [patchedPlanetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsPartialUpdate(id: string, patchedPlanetRequest?: PatchedPlanetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Planet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsPartialUpdate(id, patchedPlanetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Planet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPlanetsUpdate(id: string, planetRequest: PlanetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Planet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPlanetsUpdate(id, planetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPlanetsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsCreate(positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsPartialUpdate(id, patchedPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterPositionsUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterPositionsUpdate(id, positionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterPositionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsCreate(openaiSchoolRequest: OpenaiSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsCreate(openaiSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {PatchedOpenaiSchoolRequest} [patchedOpenaiSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsPartialUpdate(id: string, patchedOpenaiSchoolRequest?: PatchedOpenaiSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsPartialUpdate(id, patchedOpenaiSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSchoolsUpdate(id: string, openaiSchoolRequest: OpenaiSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSchoolsUpdate(id, openaiSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSchoolsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsCreate(openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsCreate(openaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {PatchedOpenaiSkillRequest} [patchedOpenaiSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsPartialUpdate(id: number, patchedOpenaiSkillRequest?: PatchedOpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsPartialUpdate(id, patchedOpenaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterSkillsUpdate(id: number, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterSkillsUpdate(id, openaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterSkillsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsCreate(worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorldItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsPartialUpdate(id, patchedWorldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gamemasterWorldItemsUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gamemasterWorldItemsUpdate(id, worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamemasterApi.gamemasterWorldItemsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GamemasterApi - factory interface
 * @export
 */
export const GamemasterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GamemasterApiFp(configuration)
    return {
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsCreate(activeEffectRequest: ActiveEffectRequest, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.gamemasterActiveEffectsCreate(activeEffectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterActiveEffectsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsList(options?: any): AxiosPromise<Array<ActiveEffect>> {
            return localVarFp.gamemasterActiveEffectsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {PatchedActiveEffectRequest} [patchedActiveEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsPartialUpdate(id: string, patchedActiveEffectRequest?: PatchedActiveEffectRequest, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.gamemasterActiveEffectsPartialUpdate(id, patchedActiveEffectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsRetrieve(id: string, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.gamemasterActiveEffectsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
         * @param {string} id A UUID string identifying this active effect.
         * @param {ActiveEffectRequest} activeEffectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterActiveEffectsUpdate(id: string, activeEffectRequest: ActiveEffectRequest, options?: any): AxiosPromise<ActiveEffect> {
            return localVarFp.gamemasterActiveEffectsUpdate(id, activeEffectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasCreate(areaRequest: AreaRequest, options?: any): AxiosPromise<Area> {
            return localVarFp.gamemasterAreasCreate(areaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterAreasDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasList(options?: any): AxiosPromise<Array<Area>> {
            return localVarFp.gamemasterAreasList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {PatchedAreaRequest} [patchedAreaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasPartialUpdate(id: string, patchedAreaRequest?: PatchedAreaRequest, options?: any): AxiosPromise<Area> {
            return localVarFp.gamemasterAreasPartialUpdate(id, patchedAreaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasRetrieve(id: string, options?: any): AxiosPromise<Area> {
            return localVarFp.gamemasterAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
         * @param {string} id A UUID string identifying this area.
         * @param {AreaRequest} areaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterAreasUpdate(id: string, areaRequest: AreaRequest, options?: any): AxiosPromise<Area> {
            return localVarFp.gamemasterAreasUpdate(id, areaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesCreate(characterCurrencyRequest: CharacterCurrencyRequest, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.gamemasterCharacterCurrenciesCreate(characterCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCharacterCurrenciesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesList(options?: any): AxiosPromise<Array<CharacterCurrency>> {
            return localVarFp.gamemasterCharacterCurrenciesList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {PatchedCharacterCurrencyRequest} [patchedCharacterCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesPartialUpdate(id: string, patchedCharacterCurrencyRequest?: PatchedCharacterCurrencyRequest, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.gamemasterCharacterCurrenciesPartialUpdate(id, patchedCharacterCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesRetrieve(id: string, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.gamemasterCharacterCurrenciesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
         * @param {string} id A UUID string identifying this character currency.
         * @param {CharacterCurrencyRequest} characterCurrencyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterCurrenciesUpdate(id: string, characterCurrencyRequest: CharacterCurrencyRequest, options?: any): AxiosPromise<CharacterCurrency> {
            return localVarFp.gamemasterCharacterCurrenciesUpdate(id, characterCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsCreate(characterItemRequest: CharacterItemRequest, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.gamemasterCharacterItemsCreate(characterItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCharacterItemsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsList(options?: any): AxiosPromise<Array<CharacterItem>> {
            return localVarFp.gamemasterCharacterItemsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {PatchedCharacterItemRequest} [patchedCharacterItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsPartialUpdate(id: string, patchedCharacterItemRequest?: PatchedCharacterItemRequest, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.gamemasterCharacterItemsPartialUpdate(id, patchedCharacterItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsRetrieve(id: string, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.gamemasterCharacterItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
         * @param {string} id A UUID string identifying this character item.
         * @param {CharacterItemRequest} characterItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharacterItemsUpdate(id: string, characterItemRequest: CharacterItemRequest, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.gamemasterCharacterItemsUpdate(id, characterItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a character.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterInfoRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersCharacterInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get character stats.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCharacterStatsRetrieve(id: string, options?: any): AxiosPromise<CharacterStats> {
            return localVarFp.gamemasterCharactersCharacterStatsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersCreate(characterInfoRequest: CharacterInfoRequest, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersCreate(characterInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCharactersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {boolean} [npc] 
         * @param {string} [position] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersList(npc?: boolean, position?: string, options?: any): AxiosPromise<Array<CharacterInfo>> {
            return localVarFp.gamemasterCharactersList(npc, position, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {PatchedCharacterInfoRequest} [patchedCharacterInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersPartialUpdate(id: string, patchedCharacterInfoRequest?: PatchedCharacterInfoRequest, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersPartialUpdate(id, patchedCharacterInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersRetrieve(id: string, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
         * @param {string} id A UUID string identifying this character.
         * @param {CharacterInfoRequest} characterInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCharactersUpdate(id: string, characterInfoRequest: CharacterInfoRequest, options?: any): AxiosPromise<CharacterInfo> {
            return localVarFp.gamemasterCharactersUpdate(id, characterInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesCreate(cityRequest: CityRequest, options?: any): AxiosPromise<City> {
            return localVarFp.gamemasterCitiesCreate(cityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCitiesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesList(options?: any): AxiosPromise<Array<City>> {
            return localVarFp.gamemasterCitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {PatchedCityRequest} [patchedCityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesPartialUpdate(id: string, patchedCityRequest?: PatchedCityRequest, options?: any): AxiosPromise<City> {
            return localVarFp.gamemasterCitiesPartialUpdate(id, patchedCityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesRetrieve(id: string, options?: any): AxiosPromise<City> {
            return localVarFp.gamemasterCitiesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
         * @param {string} id A UUID string identifying this city.
         * @param {CityRequest} cityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCitiesUpdate(id: string, cityRequest: CityRequest, options?: any): AxiosPromise<City> {
            return localVarFp.gamemasterCitiesUpdate(id, cityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsCreate(continentRequest: ContinentRequest, options?: any): AxiosPromise<Continent> {
            return localVarFp.gamemasterContinentsCreate(continentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterContinentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsList(options?: any): AxiosPromise<Array<Continent>> {
            return localVarFp.gamemasterContinentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {PatchedContinentRequest} [patchedContinentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsPartialUpdate(id: string, patchedContinentRequest?: PatchedContinentRequest, options?: any): AxiosPromise<Continent> {
            return localVarFp.gamemasterContinentsPartialUpdate(id, patchedContinentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsRetrieve(id: string, options?: any): AxiosPromise<Continent> {
            return localVarFp.gamemasterContinentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
         * @param {string} id A UUID string identifying this continent.
         * @param {ContinentRequest} continentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterContinentsUpdate(id: string, continentRequest: ContinentRequest, options?: any): AxiosPromise<Continent> {
            return localVarFp.gamemasterContinentsUpdate(id, continentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesCreate(countryRequest: CountryRequest, options?: any): AxiosPromise<Country> {
            return localVarFp.gamemasterCountriesCreate(countryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCountriesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesList(options?: any): AxiosPromise<Array<Country>> {
            return localVarFp.gamemasterCountriesList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {PatchedCountryRequest} [patchedCountryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesPartialUpdate(id: string, patchedCountryRequest?: PatchedCountryRequest, options?: any): AxiosPromise<Country> {
            return localVarFp.gamemasterCountriesPartialUpdate(id, patchedCountryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesRetrieve(id: string, options?: any): AxiosPromise<Country> {
            return localVarFp.gamemasterCountriesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
         * @param {string} id A UUID string identifying this country.
         * @param {CountryRequest} countryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCountriesUpdate(id: string, countryRequest: CountryRequest, options?: any): AxiosPromise<Country> {
            return localVarFp.gamemasterCountriesUpdate(id, countryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensCreate(currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.gamemasterCurrencyTokensCreate(currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterCurrencyTokensDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensList(options?: any): AxiosPromise<Array<CurrencyToken>> {
            return localVarFp.gamemasterCurrencyTokensList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.gamemasterCurrencyTokensPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensRetrieve(id: string, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.gamemasterCurrencyTokensRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
         * @param {string} id A UUID string identifying this currency token.
         * @param {CurrencyTokenRequest} currencyTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterCurrencyTokensUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: any): AxiosPromise<CurrencyToken> {
            return localVarFp.gamemasterCurrencyTokensUpdate(id, currencyTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsCreate(dimensionRequest: DimensionRequest, options?: any): AxiosPromise<Dimension> {
            return localVarFp.gamemasterDimensionsCreate(dimensionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterDimensionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsList(options?: any): AxiosPromise<Array<Dimension>> {
            return localVarFp.gamemasterDimensionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {PatchedDimensionRequest} [patchedDimensionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsPartialUpdate(id: number, patchedDimensionRequest?: PatchedDimensionRequest, options?: any): AxiosPromise<Dimension> {
            return localVarFp.gamemasterDimensionsPartialUpdate(id, patchedDimensionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsRetrieve(id: number, options?: any): AxiosPromise<Dimension> {
            return localVarFp.gamemasterDimensionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
         * @param {number} id A unique value identifying this dimension.
         * @param {DimensionRequest} dimensionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterDimensionsUpdate(id: number, dimensionRequest: DimensionRequest, options?: any): AxiosPromise<Dimension> {
            return localVarFp.gamemasterDimensionsUpdate(id, dimensionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsCreate(effectRequest?: EffectRequest, options?: any): AxiosPromise<Effect> {
            return localVarFp.gamemasterEffectsCreate(effectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsDestroyIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsDestroy(id: GamemasterEffectsDestroyIdEnum, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterEffectsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsList(options?: any): AxiosPromise<Array<Effect>> {
            return localVarFp.gamemasterEffectsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsPartialUpdateIdEnum} id 
         * @param {PatchedEffectRequest} [patchedEffectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsPartialUpdate(id: GamemasterEffectsPartialUpdateIdEnum, patchedEffectRequest?: PatchedEffectRequest, options?: any): AxiosPromise<Effect> {
            return localVarFp.gamemasterEffectsPartialUpdate(id, patchedEffectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsRetrieveIdEnum} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsRetrieve(id: GamemasterEffectsRetrieveIdEnum, options?: any): AxiosPromise<Effect> {
            return localVarFp.gamemasterEffectsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
         * @param {GamemasterEffectsUpdateIdEnum} id 
         * @param {EffectRequest} [effectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterEffectsUpdate(id: GamemasterEffectsUpdateIdEnum, effectRequest?: EffectRequest, options?: any): AxiosPromise<Effect> {
            return localVarFp.gamemasterEffectsUpdate(id, effectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Clone a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsCreate(gameObjectRequest?: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsCreate(gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterGameObjectsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} [campaign] 
         * @param {number} [dimension] 
         * @param {boolean} [isActive] 
         * @param {string} [objectType] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [positionGridZ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: any): AxiosPromise<Array<GameObject>> {
            return localVarFp.gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options).then((request) => request(axios, basePath));
        },
        /**
         * Move a game object to a new position.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsRetrieve(id: string, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle the active status of a game object.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
         * @param {string} id A UUID string identifying this game object.
         * @param {GameObjectRequest} [gameObjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterGameObjectsUpdate(id: string, gameObjectRequest?: GameObjectRequest, options?: any): AxiosPromise<GameObject> {
            return localVarFp.gamemasterGameObjectsUpdate(id, gameObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsCreate(itemRequest: ItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.gamemasterItemsCreate(itemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterItemsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsList(options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.gamemasterItemsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {PatchedItemRequest} [patchedItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.gamemasterItemsPartialUpdate(id, patchedItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsRetrieve(id: string, options?: any): AxiosPromise<Item> {
            return localVarFp.gamemasterItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
         * @param {string} id A UUID string identifying this item.
         * @param {ItemRequest} itemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterItemsUpdate(id: string, itemRequest: ItemRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.gamemasterItemsUpdate(id, itemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.gamemasterLearnedSchoolsCreate(learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterLearnedSchoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsList(options?: any): AxiosPromise<Array<LearnedSchool>> {
            return localVarFp.gamemasterLearnedSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {PatchedLearnedSchoolRequest} [patchedLearnedSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsPartialUpdate(id: string, patchedLearnedSchoolRequest?: PatchedLearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.gamemasterLearnedSchoolsPartialUpdate(id, patchedLearnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsRetrieve(id: string, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.gamemasterLearnedSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
         * @param {string} id A UUID string identifying this learned school.
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSchoolsUpdate(id: string, learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.gamemasterLearnedSchoolsUpdate(id, learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.gamemasterLearnedSkillsCreate(learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterLearnedSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsList(options?: any): AxiosPromise<Array<LearnedSkill>> {
            return localVarFp.gamemasterLearnedSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {PatchedLearnedSkillRequest} [patchedLearnedSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsPartialUpdate(id: string, patchedLearnedSkillRequest?: PatchedLearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.gamemasterLearnedSkillsPartialUpdate(id, patchedLearnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.gamemasterLearnedSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
         * @param {string} id A UUID string identifying this learned skill.
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLearnedSkillsUpdate(id: string, learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.gamemasterLearnedSkillsUpdate(id, learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsCreate(locationRequest: LocationRequest, options?: any): AxiosPromise<Location> {
            return localVarFp.gamemasterLocationsCreate(locationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterLocationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsList(options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.gamemasterLocationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {PatchedLocationRequest} [patchedLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsPartialUpdate(id: string, patchedLocationRequest?: PatchedLocationRequest, options?: any): AxiosPromise<Location> {
            return localVarFp.gamemasterLocationsPartialUpdate(id, patchedLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsRetrieve(id: string, options?: any): AxiosPromise<Location> {
            return localVarFp.gamemasterLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
         * @param {string} id A UUID string identifying this location.
         * @param {LocationRequest} locationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterLocationsUpdate(id: string, locationRequest: LocationRequest, options?: any): AxiosPromise<Location> {
            return localVarFp.gamemasterLocationsUpdate(id, locationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsCreate(mapRequest: MapRequest, options?: any): AxiosPromise<any> {
            return localVarFp.gamemasterMapsCreate(mapRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterMapsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsList(options?: any): AxiosPromise<Array<any>> {
            return localVarFp.gamemasterMapsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {PatchedMapRequest} [patchedMapRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsPartialUpdate(id: string, patchedMapRequest?: PatchedMapRequest, options?: any): AxiosPromise<any> {
            return localVarFp.gamemasterMapsPartialUpdate(id, patchedMapRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsRetrieve(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.gamemasterMapsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
         * @param {string} id A UUID string identifying this map.
         * @param {MapRequest} mapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterMapsUpdate(id: string, mapRequest: MapRequest, options?: any): AxiosPromise<any> {
            return localVarFp.gamemasterMapsUpdate(id, mapRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsCreate(openaiPathRequest: OpenaiPathRequest, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.gamemasterPathsCreate(openaiPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterPathsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsList(options?: any): AxiosPromise<Array<OpenaiPath>> {
            return localVarFp.gamemasterPathsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {PatchedOpenaiPathRequest} [patchedOpenaiPathRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsPartialUpdate(id: string, patchedOpenaiPathRequest?: PatchedOpenaiPathRequest, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.gamemasterPathsPartialUpdate(id, patchedOpenaiPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.gamemasterPathsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
         * @param {string} id A UUID string identifying this the path.
         * @param {OpenaiPathRequest} openaiPathRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsUpdate(id: string, openaiPathRequest: OpenaiPathRequest, options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.gamemasterPathsUpdate(id, openaiPathRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a path with its schools.
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPathsWithSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPathWithSchools> {
            return localVarFp.gamemasterPathsWithSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsCreate(planetRequest: PlanetRequest, options?: any): AxiosPromise<Planet> {
            return localVarFp.gamemasterPlanetsCreate(planetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterPlanetsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsList(options?: any): AxiosPromise<Array<Planet>> {
            return localVarFp.gamemasterPlanetsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PatchedPlanetRequest} [patchedPlanetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsPartialUpdate(id: string, patchedPlanetRequest?: PatchedPlanetRequest, options?: any): AxiosPromise<Planet> {
            return localVarFp.gamemasterPlanetsPartialUpdate(id, patchedPlanetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsRetrieve(id: string, options?: any): AxiosPromise<Planet> {
            return localVarFp.gamemasterPlanetsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
         * @param {string} id A UUID string identifying this planet.
         * @param {PlanetRequest} planetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPlanetsUpdate(id: string, planetRequest: PlanetRequest, options?: any): AxiosPromise<Planet> {
            return localVarFp.gamemasterPlanetsUpdate(id, planetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsCreate(positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterPositionsCreate(positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterPositionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsList(options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.gamemasterPositionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PatchedPositionRequest} [patchedPositionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterPositionsPartialUpdate(id, patchedPositionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsRetrieve(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterPositionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
         * @param {string} id A UUID string identifying this position.
         * @param {PositionRequest} positionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterPositionsUpdate(id: string, positionRequest: PositionRequest, options?: any): AxiosPromise<Position> {
            return localVarFp.gamemasterPositionsUpdate(id, positionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsCreate(openaiSchoolRequest: OpenaiSchoolRequest, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.gamemasterSchoolsCreate(openaiSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterSchoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsList(options?: any): AxiosPromise<Array<OpenaiSchool>> {
            return localVarFp.gamemasterSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {PatchedOpenaiSchoolRequest} [patchedOpenaiSchoolRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsPartialUpdate(id: string, patchedOpenaiSchoolRequest?: PatchedOpenaiSchoolRequest, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.gamemasterSchoolsPartialUpdate(id, patchedOpenaiSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.gamemasterSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
         * @param {string} id A UUID string identifying this school.
         * @param {OpenaiSchoolRequest} openaiSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSchoolsUpdate(id: string, openaiSchoolRequest: OpenaiSchoolRequest, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.gamemasterSchoolsUpdate(id, openaiSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsCreate(openaiSkillRequest: OpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.gamemasterSkillsCreate(openaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsList(options?: any): AxiosPromise<Array<OpenaiSkill>> {
            return localVarFp.gamemasterSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {PatchedOpenaiSkillRequest} [patchedOpenaiSkillRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsPartialUpdate(id: number, patchedOpenaiSkillRequest?: PatchedOpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.gamemasterSkillsPartialUpdate(id, patchedOpenaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsRetrieve(id: number, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.gamemasterSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
         * @param {number} id A unique integer value identifying this skill.
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterSkillsUpdate(id: number, openaiSkillRequest: OpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.gamemasterSkillsUpdate(id, openaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsCreate(worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.gamemasterWorldItemsCreate(worldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gamemasterWorldItemsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsList(options?: any): AxiosPromise<Array<WorldItem>> {
            return localVarFp.gamemasterWorldItemsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.gamemasterWorldItemsPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsRetrieve(id: string, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.gamemasterWorldItemsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gamemasterWorldItemsUpdate(id: string, worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.gamemasterWorldItemsUpdate(id, worldItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GamemasterApi - object-oriented interface
 * @export
 * @class GamemasterApi
 * @extends {BaseAPI}
 */
export class GamemasterApi extends BaseAPI {
    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {ActiveEffectRequest} activeEffectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsCreate(activeEffectRequest: ActiveEffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsCreate(activeEffectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {string} id A UUID string identifying this active effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {string} id A UUID string identifying this active effect.
     * @param {PatchedActiveEffectRequest} [patchedActiveEffectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsPartialUpdate(id: string, patchedActiveEffectRequest?: PatchedActiveEffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsPartialUpdate(id, patchedActiveEffectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {string} id A UUID string identifying this active effect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage active effects. This viewset provides full CRUD operations for active effects.
     * @param {string} id A UUID string identifying this active effect.
     * @param {ActiveEffectRequest} activeEffectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterActiveEffectsUpdate(id: string, activeEffectRequest: ActiveEffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterActiveEffectsUpdate(id, activeEffectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {AreaRequest} areaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasCreate(areaRequest: AreaRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasCreate(areaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {string} id A UUID string identifying this area.
     * @param {PatchedAreaRequest} [patchedAreaRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasPartialUpdate(id: string, patchedAreaRequest?: PatchedAreaRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasPartialUpdate(id, patchedAreaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage areas. This viewset provides full CRUD operations for areas.
     * @param {string} id A UUID string identifying this area.
     * @param {AreaRequest} areaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterAreasUpdate(id: string, areaRequest: AreaRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterAreasUpdate(id, areaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {CharacterCurrencyRequest} characterCurrencyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesCreate(characterCurrencyRequest: CharacterCurrencyRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesCreate(characterCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {string} id A UUID string identifying this character currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {string} id A UUID string identifying this character currency.
     * @param {PatchedCharacterCurrencyRequest} [patchedCharacterCurrencyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesPartialUpdate(id: string, patchedCharacterCurrencyRequest?: PatchedCharacterCurrencyRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesPartialUpdate(id, patchedCharacterCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {string} id A UUID string identifying this character currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character currencies. This viewset provides full CRUD operations for character currencies.
     * @param {string} id A UUID string identifying this character currency.
     * @param {CharacterCurrencyRequest} characterCurrencyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterCurrenciesUpdate(id: string, characterCurrencyRequest: CharacterCurrencyRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterCurrenciesUpdate(id, characterCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {CharacterItemRequest} characterItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsCreate(characterItemRequest: CharacterItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsCreate(characterItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {string} id A UUID string identifying this character item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {string} id A UUID string identifying this character item.
     * @param {PatchedCharacterItemRequest} [patchedCharacterItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsPartialUpdate(id: string, patchedCharacterItemRequest?: PatchedCharacterItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsPartialUpdate(id, patchedCharacterItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {string} id A UUID string identifying this character item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage character items. This viewset provides full CRUD operations for character items.
     * @param {string} id A UUID string identifying this character item.
     * @param {CharacterItemRequest} characterItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharacterItemsUpdate(id: string, characterItemRequest: CharacterItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharacterItemsUpdate(id, characterItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a character.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get character stats.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCharacterStatsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCharacterStatsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {CharacterInfoRequest} characterInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersCreate(characterInfoRequest: CharacterInfoRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersCreate(characterInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {boolean} [npc] 
     * @param {string} [position] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersList(npc?: boolean, position?: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersList(npc, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {string} id A UUID string identifying this character.
     * @param {PatchedCharacterInfoRequest} [patchedCharacterInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersPartialUpdate(id: string, patchedCharacterInfoRequest?: PatchedCharacterInfoRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersPartialUpdate(id, patchedCharacterInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage characters. This viewset provides full CRUD operations for characters.
     * @param {string} id A UUID string identifying this character.
     * @param {CharacterInfoRequest} characterInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCharactersUpdate(id: string, characterInfoRequest: CharacterInfoRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCharactersUpdate(id, characterInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {CityRequest} cityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesCreate(cityRequest: CityRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesCreate(cityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {string} id A UUID string identifying this city.
     * @param {PatchedCityRequest} [patchedCityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesPartialUpdate(id: string, patchedCityRequest?: PatchedCityRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesPartialUpdate(id, patchedCityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage cities. This viewset provides full CRUD operations for cities.
     * @param {string} id A UUID string identifying this city.
     * @param {CityRequest} cityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCitiesUpdate(id: string, cityRequest: CityRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCitiesUpdate(id, cityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {ContinentRequest} continentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsCreate(continentRequest: ContinentRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsCreate(continentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {string} id A UUID string identifying this continent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {string} id A UUID string identifying this continent.
     * @param {PatchedContinentRequest} [patchedContinentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsPartialUpdate(id: string, patchedContinentRequest?: PatchedContinentRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsPartialUpdate(id, patchedContinentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {string} id A UUID string identifying this continent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage continents. This viewset provides full CRUD operations for continents.
     * @param {string} id A UUID string identifying this continent.
     * @param {ContinentRequest} continentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterContinentsUpdate(id: string, continentRequest: ContinentRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterContinentsUpdate(id, continentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {CountryRequest} countryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesCreate(countryRequest: CountryRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesCreate(countryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {string} id A UUID string identifying this country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {string} id A UUID string identifying this country.
     * @param {PatchedCountryRequest} [patchedCountryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesPartialUpdate(id: string, patchedCountryRequest?: PatchedCountryRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesPartialUpdate(id, patchedCountryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {string} id A UUID string identifying this country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage countries. This viewset provides full CRUD operations for countries.
     * @param {string} id A UUID string identifying this country.
     * @param {CountryRequest} countryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCountriesUpdate(id: string, countryRequest: CountryRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCountriesUpdate(id, countryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensCreate(currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensCreate(currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {string} id A UUID string identifying this currency token.
     * @param {PatchedCurrencyTokenRequest} [patchedCurrencyTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensPartialUpdate(id: string, patchedCurrencyTokenRequest?: PatchedCurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensPartialUpdate(id, patchedCurrencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {string} id A UUID string identifying this currency token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage currency tokens. This viewset provides full CRUD operations for currency tokens.
     * @param {string} id A UUID string identifying this currency token.
     * @param {CurrencyTokenRequest} currencyTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterCurrencyTokensUpdate(id: string, currencyTokenRequest: CurrencyTokenRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterCurrencyTokensUpdate(id, currencyTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {DimensionRequest} dimensionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsCreate(dimensionRequest: DimensionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsCreate(dimensionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {number} id A unique value identifying this dimension.
     * @param {PatchedDimensionRequest} [patchedDimensionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsPartialUpdate(id: number, patchedDimensionRequest?: PatchedDimensionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsPartialUpdate(id, patchedDimensionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage dimensions. This viewset provides full CRUD operations for dimensions.
     * @param {number} id A unique value identifying this dimension.
     * @param {DimensionRequest} dimensionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterDimensionsUpdate(id: number, dimensionRequest: DimensionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterDimensionsUpdate(id, dimensionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {EffectRequest} [effectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsCreate(effectRequest?: EffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsCreate(effectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {GamemasterEffectsDestroyIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsDestroy(id: GamemasterEffectsDestroyIdEnum, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {GamemasterEffectsPartialUpdateIdEnum} id 
     * @param {PatchedEffectRequest} [patchedEffectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsPartialUpdate(id: GamemasterEffectsPartialUpdateIdEnum, patchedEffectRequest?: PatchedEffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsPartialUpdate(id, patchedEffectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {GamemasterEffectsRetrieveIdEnum} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsRetrieve(id: GamemasterEffectsRetrieveIdEnum, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage effects. This viewset provides full CRUD operations for effects.
     * @param {GamemasterEffectsUpdateIdEnum} id 
     * @param {EffectRequest} [effectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterEffectsUpdate(id: GamemasterEffectsUpdateIdEnum, effectRequest?: EffectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterEffectsUpdate(id, effectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clone a game object.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} [gameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsCloneCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsCloneCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {GameObjectRequest} [gameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsCreate(gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsCreate(gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} [campaign] 
     * @param {number} [dimension] 
     * @param {boolean} [isActive] 
     * @param {string} [objectType] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [positionGridZ] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsList(campaign?: string, dimension?: number, isActive?: boolean, objectType?: string, ordering?: string, positionGridZ?: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsList(campaign, dimension, isActive, objectType, ordering, positionGridZ, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move a game object to a new position.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} [gameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsMoveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsMoveCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {PatchedGameObjectRequest} [patchedGameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsPartialUpdate(id: string, patchedGameObjectRequest?: PatchedGameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsPartialUpdate(id, patchedGameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle the active status of a game object.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} [gameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsToggleActiveCreate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsToggleActiveCreate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage game objects. This viewset provides operations for listing, retrieving, creating, updating, and deleting game objects. It also provides custom actions for moving, cloning, and disabling/enabling game objects.
     * @param {string} id A UUID string identifying this game object.
     * @param {GameObjectRequest} [gameObjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterGameObjectsUpdate(id: string, gameObjectRequest?: GameObjectRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterGameObjectsUpdate(id, gameObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {ItemRequest} itemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsCreate(itemRequest: ItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsCreate(itemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {string} id A UUID string identifying this item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {string} id A UUID string identifying this item.
     * @param {PatchedItemRequest} [patchedItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsPartialUpdate(id: string, patchedItemRequest?: PatchedItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsPartialUpdate(id, patchedItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {string} id A UUID string identifying this item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage items. This viewset provides full CRUD operations for items.
     * @param {string} id A UUID string identifying this item.
     * @param {ItemRequest} itemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterItemsUpdate(id: string, itemRequest: ItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterItemsUpdate(id, itemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsCreate(learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {string} id A UUID string identifying this learned school.
     * @param {PatchedLearnedSchoolRequest} [patchedLearnedSchoolRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsPartialUpdate(id: string, patchedLearnedSchoolRequest?: PatchedLearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsPartialUpdate(id, patchedLearnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned schools. This viewset provides full CRUD operations for learned schools.
     * @param {string} id A UUID string identifying this learned school.
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSchoolsUpdate(id: string, learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSchoolsUpdate(id, learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsCreate(learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {string} id A UUID string identifying this learned skill.
     * @param {PatchedLearnedSkillRequest} [patchedLearnedSkillRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsPartialUpdate(id: string, patchedLearnedSkillRequest?: PatchedLearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsPartialUpdate(id, patchedLearnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage learned skills. This viewset provides full CRUD operations for learned skills.
     * @param {string} id A UUID string identifying this learned skill.
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLearnedSkillsUpdate(id: string, learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLearnedSkillsUpdate(id, learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {LocationRequest} locationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsCreate(locationRequest: LocationRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsCreate(locationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {string} id A UUID string identifying this location.
     * @param {PatchedLocationRequest} [patchedLocationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsPartialUpdate(id: string, patchedLocationRequest?: PatchedLocationRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsPartialUpdate(id, patchedLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage locations. This viewset provides full CRUD operations for locations.
     * @param {string} id A UUID string identifying this location.
     * @param {LocationRequest} locationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterLocationsUpdate(id: string, locationRequest: LocationRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterLocationsUpdate(id, locationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {MapRequest} mapRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsCreate(mapRequest: MapRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsCreate(mapRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {string} id A UUID string identifying this map.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {string} id A UUID string identifying this map.
     * @param {PatchedMapRequest} [patchedMapRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsPartialUpdate(id: string, patchedMapRequest?: PatchedMapRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsPartialUpdate(id, patchedMapRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {string} id A UUID string identifying this map.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage maps. This viewset provides full CRUD operations for maps.
     * @param {string} id A UUID string identifying this map.
     * @param {MapRequest} mapRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterMapsUpdate(id: string, mapRequest: MapRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterMapsUpdate(id, mapRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {OpenaiPathRequest} openaiPathRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsCreate(openaiPathRequest: OpenaiPathRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsCreate(openaiPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {string} id A UUID string identifying this the path.
     * @param {PatchedOpenaiPathRequest} [patchedOpenaiPathRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsPartialUpdate(id: string, patchedOpenaiPathRequest?: PatchedOpenaiPathRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsPartialUpdate(id, patchedOpenaiPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage paths. This viewset provides full CRUD operations for paths.
     * @param {string} id A UUID string identifying this the path.
     * @param {OpenaiPathRequest} openaiPathRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsUpdate(id: string, openaiPathRequest: OpenaiPathRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsUpdate(id, openaiPathRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a path with its schools.
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPathsWithSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPathsWithSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {PlanetRequest} planetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsCreate(planetRequest: PlanetRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsCreate(planetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {string} id A UUID string identifying this planet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {string} id A UUID string identifying this planet.
     * @param {PatchedPlanetRequest} [patchedPlanetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsPartialUpdate(id: string, patchedPlanetRequest?: PatchedPlanetRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsPartialUpdate(id, patchedPlanetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {string} id A UUID string identifying this planet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage planets. This viewset provides full CRUD operations for planets.
     * @param {string} id A UUID string identifying this planet.
     * @param {PlanetRequest} planetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPlanetsUpdate(id: string, planetRequest: PlanetRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPlanetsUpdate(id, planetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsCreate(positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsCreate(positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {string} id A UUID string identifying this position.
     * @param {PatchedPositionRequest} [patchedPositionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsPartialUpdate(id: string, patchedPositionRequest?: PatchedPositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsPartialUpdate(id, patchedPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {string} id A UUID string identifying this position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage positions. This viewset provides full CRUD operations for positions.
     * @param {string} id A UUID string identifying this position.
     * @param {PositionRequest} positionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterPositionsUpdate(id: string, positionRequest: PositionRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterPositionsUpdate(id, positionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {OpenaiSchoolRequest} openaiSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsCreate(openaiSchoolRequest: OpenaiSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsCreate(openaiSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {string} id A UUID string identifying this school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {string} id A UUID string identifying this school.
     * @param {PatchedOpenaiSchoolRequest} [patchedOpenaiSchoolRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsPartialUpdate(id: string, patchedOpenaiSchoolRequest?: PatchedOpenaiSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsPartialUpdate(id, patchedOpenaiSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {string} id A UUID string identifying this school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage schools. This viewset provides full CRUD operations for schools.
     * @param {string} id A UUID string identifying this school.
     * @param {OpenaiSchoolRequest} openaiSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSchoolsUpdate(id: string, openaiSchoolRequest: OpenaiSchoolRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSchoolsUpdate(id, openaiSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {OpenaiSkillRequest} openaiSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsCreate(openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsCreate(openaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {number} id A unique integer value identifying this skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {number} id A unique integer value identifying this skill.
     * @param {PatchedOpenaiSkillRequest} [patchedOpenaiSkillRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsPartialUpdate(id: number, patchedOpenaiSkillRequest?: PatchedOpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsPartialUpdate(id, patchedOpenaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {number} id A unique integer value identifying this skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage skills. This viewset provides full CRUD operations for skills.
     * @param {number} id A unique integer value identifying this skill.
     * @param {OpenaiSkillRequest} openaiSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterSkillsUpdate(id: number, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterSkillsUpdate(id, openaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsCreate(worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsList(options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {string} id A UUID string identifying this world item.
     * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for game masters to manage world items. This viewset provides full CRUD operations for world items.
     * @param {string} id A UUID string identifying this world item.
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamemasterApi
     */
    public gamemasterWorldItemsUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return GamemasterApiFp(this.configuration).gamemasterWorldItemsUpdate(id, worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GamemasterEffectsDestroyIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;
export type GamemasterEffectsDestroyIdEnum = typeof GamemasterEffectsDestroyIdEnum[keyof typeof GamemasterEffectsDestroyIdEnum];
/**
 * @export
 */
export const GamemasterEffectsPartialUpdateIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;
export type GamemasterEffectsPartialUpdateIdEnum = typeof GamemasterEffectsPartialUpdateIdEnum[keyof typeof GamemasterEffectsPartialUpdateIdEnum];
/**
 * @export
 */
export const GamemasterEffectsRetrieveIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;
export type GamemasterEffectsRetrieveIdEnum = typeof GamemasterEffectsRetrieveIdEnum[keyof typeof GamemasterEffectsRetrieveIdEnum];
/**
 * @export
 */
export const GamemasterEffectsUpdateIdEnum = {
    KnockedOut: 'Knocked out',
    Coma: 'Coma',
    None: 'None',
    Burning: 'Burning',
    Poisoned: 'Poisoned',
    Sleeping: 'Sleeping',
    Confused: 'Confused',
    Paralyzed: 'Paralyzed',
    Fear: 'Fear',
    Slowness: 'Slowness',
    Cold: 'Cold',
    Cursed: 'Cursed',
    Blindness: 'Blindness',
    Haste: 'Haste',
    Regeneration: 'Regeneration',
    Blessed: 'Blessed',
    ArcaneSurge: 'Arcane Surge',
    Marked: 'Marked'
} as const;
export type GamemasterEffectsUpdateIdEnum = typeof GamemasterEffectsUpdateIdEnum[keyof typeof GamemasterEffectsUpdateIdEnum];


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/items/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate: async (worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('itemsWorldCreate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldDestroy', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/items/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate: async (id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldRetrieve', 'id', id)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate: async (id: string, worldItemRequest: WorldItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'id', id)
            // verify required parameter 'worldItemRequest' is not null or undefined
            assertParamExists('itemsWorldUpdate', 'worldItemRequest', worldItemRequest)
            const localVarPath = `/api/items/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(worldItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldCreate(worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorldItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldPartialUpdate(id, patchedWorldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsWorldUpdate(id, worldItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterList(options?: any): AxiosPromise<Array<CharacterItem>> {
            return localVarFp.itemsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterItem> {
            return localVarFp.itemsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldCreate(worldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldList(options?: any): AxiosPromise<Array<WorldItem>> {
            return localVarFp.itemsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldRetrieve(id: string, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this world item.
         * @param {WorldItemRequest} worldItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: any): AxiosPromise<WorldItem> {
            return localVarFp.itemsWorldUpdate(id, worldItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldCreate(worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldCreate(worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldList(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {PatchedWorldItemRequest} [patchedWorldItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldPartialUpdate(id: string, patchedWorldItemRequest?: PatchedWorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldPartialUpdate(id, patchedWorldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this world item.
     * @param {WorldItemRequest} worldItemRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsWorldUpdate(id: string, worldItemRequest: WorldItemRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemsWorldUpdate(id, worldItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModificatorsApi - axios parameter creator
 * @export
 */
export const ModificatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/character/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsCharacterRetrieve', 'id', id)
            const localVarPath = `/api/modificators/character/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate: async (modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldCreate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldDestroy', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/get_all_modificators/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/modificators/world/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate: async (id: string, patchedModificatorRequest?: PatchedModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldPartialUpdate', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedModificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldRetrieve', 'id', id)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate: async (id: string, modificatorRequest: ModificatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'id', id)
            // verify required parameter 'modificatorRequest' is not null or undefined
            assertParamExists('modificatorsWorldUpdate', 'modificatorRequest', modificatorRequest)
            const localVarPath = `/api/modificators/world/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModificatorsApi - functional programming interface
 * @export
 */
export const ModificatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModificatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CharacterModificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterModificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsCharacterRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsCharacterRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldCreate(modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldGetAllModificatorsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldGetAllModificatorsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Modificator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Modificator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modificatorsWorldUpdate(id, modificatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModificatorsApi.modificatorsWorldUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModificatorsApi - factory interface
 * @export
 */
export const ModificatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModificatorsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterList(options?: any): AxiosPromise<Array<CharacterModificator>> {
            return localVarFp.modificatorsCharacterList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsCharacterRetrieve(id: string, options?: any): AxiosPromise<CharacterModificator> {
            return localVarFp.modificatorsCharacterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldCreate(modificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.modificatorsWorldDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldGetAllModificatorsRetrieve(options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldList(options?: any): AxiosPromise<Array<Modificator>> {
            return localVarFp.modificatorsWorldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldRetrieve(id: string, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this modificator.
         * @param {ModificatorRequest} modificatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: any): AxiosPromise<Modificator> {
            return localVarFp.modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModificatorsApi - object-oriented interface
 * @export
 * @class ModificatorsApi
 * @extends {BaseAPI}
 */
export class ModificatorsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsCharacterRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsCharacterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldCreate(modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldCreate(modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldGetAllModificatorsRetrieve(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldGetAllModificatorsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldList(options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {PatchedModificatorRequest} [patchedModificatorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldPartialUpdate(id: string, patchedModificatorRequest?: PatchedModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldPartialUpdate(id, patchedModificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this modificator.
     * @param {ModificatorRequest} modificatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModificatorsApi
     */
    public modificatorsWorldUpdate(id: string, modificatorRequest: ModificatorRequest, options?: RawAxiosRequestConfig) {
        return ModificatorsApiFp(this.configuration).modificatorsWorldUpdate(id, modificatorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/get_all_paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolPathsRetrieve', 'id', id)
            const localVarPath = `/api/school/paths/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate: async (id: string, openaiSkillRequest: OpenaiSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'id', id)
            // verify required parameter 'openaiSkillRequest' is not null or undefined
            assertParamExists('schoolSchoolsCreateSkillCreate', 'openaiSkillRequest', openaiSkillRequest)
            const localVarPath = `/api/school/schools/{id}/create_skill/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openaiSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/get_all_skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/school/schools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsRetrieve', 'id', id)
            const localVarPath = `/api/school/schools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsGetAllSchoolSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/get_all_school_skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList: async (schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsList', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/`
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve: async (id: string, schoolPk: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'id', id)
            // verify required parameter 'schoolPk' is not null or undefined
            assertParamExists('schoolSchoolsSkillsRetrieve', 'schoolPk', schoolPk)
            const localVarPath = `/api/school/schools/{school_pk}/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"school_pk"}}`, encodeURIComponent(String(schoolPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsGetAllPathsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsGetAllPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiPathWithSchools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolPathsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolPathsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsCreateSkillCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSchoolsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsGetAllSkillsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsGetAllSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenaiSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsList(schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenaiSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolSchoolsSkillsRetrieve(id, schoolPk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchoolApi.schoolSchoolsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsGetAllPathsRetrieve(options?: any): AxiosPromise<OpenaiPath> {
            return localVarFp.schoolPathsGetAllPathsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsList(options?: any): AxiosPromise<Array<OpenaiPath>> {
            return localVarFp.schoolPathsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolPathsRetrieve(id: string, options?: any): AxiosPromise<OpenaiPathWithSchools> {
            return localVarFp.schoolPathsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {OpenaiSkillRequest} openaiSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSchoolsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsGetAllSkillsRetrieve(options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsList(options?: any): AxiosPromise<Array<OpenaiSchool>> {
            return localVarFp.schoolSchoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsRetrieve(id: string, options?: any): AxiosPromise<OpenaiSchool> {
            return localVarFp.schoolSchoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsList(schoolPk: string, options?: any): AxiosPromise<Array<OpenaiSkill>> {
            return localVarFp.schoolSchoolsSkillsList(schoolPk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} schoolPk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: any): AxiosPromise<OpenaiSkill> {
            return localVarFp.schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsGetAllPathsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsGetAllPathsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolPathsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolPathsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {OpenaiSkillRequest} openaiSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsCreateSkillCreate(id: string, openaiSkillRequest: OpenaiSkillRequest, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsCreateSkillCreate(id, openaiSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSchoolsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSchoolsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsGetAllSkillsRetrieve(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsGetAllSkillsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsList(options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsGetAllSchoolSkillsRetrieve(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsList(schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsList(schoolPk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} schoolPk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolSchoolsSkillsRetrieve(id: string, schoolPk: string, options?: RawAxiosRequestConfig) {
        return SchoolApiFp(this.configuration).schoolSchoolsSkillsRetrieve(id, schoolPk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShieldsApi - axios parameter creator
 * @export
 */
export const ShieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shields/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shieldsActiveRetrieve', 'id', id)
            const localVarPath = `/api/shields/active/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsGmActiveList: async (target?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shields/gm/active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShieldsApi - functional programming interface
 * @export
 */
export const ShieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveShield>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveShield>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsActiveRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsActiveRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldsGmActiveList(target?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveShield>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldsGmActiveList(target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShieldsApi.shieldsGmActiveList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShieldsApi - factory interface
 * @export
 */
export const ShieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShieldsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveList(options?: any): AxiosPromise<Array<ActiveShield>> {
            return localVarFp.shieldsActiveList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this active shield.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsActiveRetrieve(id: string, options?: any): AxiosPromise<ActiveShield> {
            return localVarFp.shieldsActiveRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [target] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldsGmActiveList(target?: string, options?: any): AxiosPromise<Array<ActiveShield>> {
            return localVarFp.shieldsGmActiveList(target, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShieldsApi - object-oriented interface
 * @export
 * @class ShieldsApi
 * @extends {BaseAPI}
 */
export class ShieldsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveList(options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this active shield.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsActiveRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsActiveRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [target] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShieldsApi
     */
    public shieldsGmActiveList(target?: string, options?: RawAxiosRequestConfig) {
        return ShieldsApiFp(this.configuration).shieldsGmActiveList(target, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList: async (character?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/gm/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (character !== undefined) {
                localVarQueryParameter['character'] = character;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsGmSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/gm/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate: async (learnedSchoolRequest: LearnedSchoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSchoolRequest' is not null or undefined
            assertParamExists('skillsShoolsCreate', 'learnedSchoolRequest', learnedSchoolRequest)
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSchoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsDestroy', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/shools/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsShoolsRetrieve', 'id', id)
            const localVarPath = `/api/skills/shools/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate: async (learnedSkillRequest: LearnedSkillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'learnedSkillRequest' is not null or undefined
            assertParamExists('skillsSkillsCreate', 'learnedSkillRequest', learnedSkillRequest)
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(learnedSkillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsDestroy', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/skills/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('skillsSkillsRetrieve', 'id', id)
            const localVarPath = `/api/skills/skills/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLearnedSkillList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsList(character, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGmSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsGmSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsCreate(learnedSchoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSchool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSchool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsShoolsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsShoolsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsCreate(learnedSkillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LearnedSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LearnedSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skillsSkillsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.skillsSkillsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [character] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedLearnedSkillList> {
            return localVarFp.skillsGmSkillsList(character, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsGmSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsGmSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSchoolRequest} learnedSchoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsShoolsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsList(options?: any): AxiosPromise<Array<LearnedSchool>> {
            return localVarFp.skillsShoolsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned school.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsShoolsRetrieve(id: string, options?: any): AxiosPromise<LearnedSchool> {
            return localVarFp.skillsShoolsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LearnedSkillRequest} learnedSkillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.skillsSkillsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsList(options?: any): AxiosPromise<Array<LearnedSkill>> {
            return localVarFp.skillsSkillsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this learned skill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skillsSkillsRetrieve(id: string, options?: any): AxiosPromise<LearnedSkill> {
            return localVarFp.skillsSkillsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * 
     * @param {string} [character] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsList(character?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsList(character, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsGmSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsGmSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSchoolRequest} learnedSchoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsCreate(learnedSchoolRequest: LearnedSchoolRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsCreate(learnedSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned school.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsShoolsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsShoolsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LearnedSkillRequest} learnedSkillRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsCreate(learnedSkillRequest: LearnedSkillRequest, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsCreate(learnedSkillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsList(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this learned skill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public skillsSkillsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).skillsSkillsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorldApi - axios parameter creator
 * @export
 */
export const WorldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldAreasRetrieve', 'id', id)
            const localVarPath = `/api/world/areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/cities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldCitiesRetrieve', 'id', id)
            const localVarPath = `/api/world/cities/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/dimensions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldDimensionsRetrieve', 'id', id)
            const localVarPath = `/api/world/dimensions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsChangeCreate', 'id', id)
            const localVarPath = `/api/world/locations/{id}/change/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldLocationsRetrieve', 'id', id)
            const localVarPath = `/api/world/locations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/mapped-position/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionMapPositionCreate: async (newCoordinatesRequest: NewCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCoordinatesRequest' is not null or undefined
            assertParamExists('worldMappedPositionMapPositionCreate', 'newCoordinatesRequest', newCoordinatesRequest)
            const localVarPath = `/api/world/mapped-position/map_position/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldMappedPositionRetrieve', 'id', id)
            const localVarPath = `/api/world/mapped-position/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsMiniMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/maps/mini_map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionAddCreate: async (newCoordinatesRequest: NewCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCoordinatesRequest' is not null or undefined
            assertParamExists('worldMapsPositionAddCreate', 'newCoordinatesRequest', newCoordinatesRequest)
            const localVarPath = `/api/world/maps/position_add/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionRemoveCreate: async (genericPositionIdRequest: GenericPositionIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genericPositionIdRequest' is not null or undefined
            assertParamExists('worldMapsPositionRemoveCreate', 'genericPositionIdRequest', genericPositionIdRequest)
            const localVarPath = `/api/world/maps/position_remove/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(genericPositionIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionUpdateCreate: async (mapPositionMutableRequest: MapPositionMutableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mapPositionMutableRequest' is not null or undefined
            assertParamExists('worldMapsPositionUpdateCreate', 'mapPositionMutableRequest', mapPositionMutableRequest)
            const localVarPath = `/api/world/maps/position_update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mapPositionMutableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsWorldMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/maps/world_map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/current/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionInfoRetrieve', 'id', id)
            const localVarPath = `/api/world/position/{id}/info/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/world/position/map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionMoveToPositionCreate', 'id', id)
            const localVarPath = `/api/world/position/{id}/move_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate: async (id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'id', id)
            // verify required parameter 'teleportCoordinatesRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToCoordinatesCreate', 'teleportCoordinatesRequest', teleportCoordinatesRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_coordinates/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportCoordinatesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate: async (id: string, teleportPositionRequest: TeleportPositionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'id', id)
            // verify required parameter 'teleportPositionRequest' is not null or undefined
            assertParamExists('worldPositionTeleportToPositionCreate', 'teleportPositionRequest', teleportPositionRequest)
            const localVarPath = `/api/world/position/{id}/teleport_to_position/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportPositionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldApi - functional programming interface
 * @export
 */
export const WorldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldAreasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldAreasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldCitiesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldCitiesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dimension>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dimension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldDimensionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldDimensionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsChangeCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsChangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldLocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldLocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MapPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionMapPositionCreate(newCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionMapPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMappedPositionRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMappedPositionRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMappedPositionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsMiniMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniMap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsMiniMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsMiniMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionAddCreate(newCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericPositionId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionRemoveCreate(genericPositionIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionRemoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsPositionUpdateCreate(mapPositionMutableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsPositionUpdateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldMapsWorldMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldMapsWorldMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldMapsWorldMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionCurrentRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionCurrentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionInfoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionInfoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMapRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Position>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMapRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMapRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionMoveToPositionCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionMoveToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportCoordinates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToCoordinatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeleportPosition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorldApi.worldPositionTeleportToPositionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorldApi - factory interface
 * @export
 */
export const WorldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorldApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasCurrentRetrieve(options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasList(options?: any): AxiosPromise<Array<Area>> {
            return localVarFp.worldAreasList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldAreasRetrieve(id: string, options?: any): AxiosPromise<Area> {
            return localVarFp.worldAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesCurrentRetrieve(options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesList(options?: any): AxiosPromise<Array<City>> {
            return localVarFp.worldCitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this city.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldCitiesRetrieve(id: string, options?: any): AxiosPromise<City> {
            return localVarFp.worldCitiesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsCurrentRetrieve(options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsList(options?: any): AxiosPromise<Array<Dimension>> {
            return localVarFp.worldDimensionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique value identifying this dimension.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldDimensionsRetrieve(id: number, options?: any): AxiosPromise<Dimension> {
            return localVarFp.worldDimensionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsChangeCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldLocationsChangeCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsCurrentRetrieve(options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsList(options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.worldLocationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldLocationsRetrieve(id: string, options?: any): AxiosPromise<Location> {
            return localVarFp.worldLocationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionList(options?: any): AxiosPromise<Array<MapPosition>> {
            return localVarFp.worldMappedPositionList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMappedPositionMapPositionCreate(newCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this map position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMappedPositionRetrieve(id: string, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMappedPositionRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the mini map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsMiniMapRetrieve(options?: any): AxiosPromise<MiniMap> {
            return localVarFp.worldMapsMiniMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewCoordinatesRequest} newCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: any): AxiosPromise<MapPosition> {
            return localVarFp.worldMapsPositionAddCreate(newCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenericPositionIdRequest} genericPositionIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: any): AxiosPromise<GenericPositionId> {
            return localVarFp.worldMapsPositionRemoveCreate(genericPositionIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MapPositionMutableRequest} mapPositionMutableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: any): AxiosPromise<any> {
            return localVarFp.worldMapsPositionUpdateCreate(mapPositionMutableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the world map of the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldMapsWorldMapRetrieve(options?: any): AxiosPromise<any> {
            return localVarFp.worldMapsWorldMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current position of the character and possible movements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionCurrentRetrieve(options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionCurrentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionInfoRetrieve(id: string, options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionInfoRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the map of the current location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMapRetrieve(options?: any): AxiosPromise<Position> {
            return localVarFp.worldPositionMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionMoveToPositionCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.worldPositionMoveToPositionCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: any): AxiosPromise<TeleportCoordinates> {
            return localVarFp.worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this character.
         * @param {TeleportPositionRequest} teleportPositionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: any): AxiosPromise<TeleportPosition> {
            return localVarFp.worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorldApi - object-oriented interface
 * @export
 * @class WorldApi
 * @extends {BaseAPI}
 */
export class WorldApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldAreasRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldAreasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this city.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldCitiesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldCitiesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique value identifying this dimension.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldDimensionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldDimensionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsChangeCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsChangeCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldLocationsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldLocationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionList(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewCoordinatesRequest} newCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionMapPositionCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionMapPositionCreate(newCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this map position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMappedPositionRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMappedPositionRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the mini map of the current organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsMiniMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsMiniMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewCoordinatesRequest} newCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionAddCreate(newCoordinatesRequest: NewCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionAddCreate(newCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenericPositionIdRequest} genericPositionIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionRemoveCreate(genericPositionIdRequest: GenericPositionIdRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionRemoveCreate(genericPositionIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MapPositionMutableRequest} mapPositionMutableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsPositionUpdateCreate(mapPositionMutableRequest: MapPositionMutableRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsPositionUpdateCreate(mapPositionMutableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the world map of the current organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldMapsWorldMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldMapsWorldMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current position of the character and possible movements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionCurrentRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionCurrentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionInfoRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionInfoRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the map of the current location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMapRetrieve(options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionMoveToPositionCreate(id: string, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionMoveToPositionCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportCoordinatesRequest} teleportCoordinatesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToCoordinatesCreate(id: string, teleportCoordinatesRequest: TeleportCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToCoordinatesCreate(id, teleportCoordinatesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this character.
     * @param {TeleportPositionRequest} teleportPositionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldApi
     */
    public worldPositionTeleportToPositionCreate(id: string, teleportPositionRequest: TeleportPositionRequest, options?: RawAxiosRequestConfig) {
        return WorldApiFp(this.configuration).worldPositionTeleportToPositionCreate(id, teleportPositionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



